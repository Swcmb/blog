{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1},{"_id":"source/img/Icon.jpg","path":"img/Icon.jpg","modified":1,"renderable":0},{"_id":"source/img/abc.png","path":"img/abc.png","modified":1,"renderable":0},{"_id":"source/img/warma.jpg","path":"img/warma.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/深刻哀悼.md","hash":"39e7538fd7cfc7abb9473483df1e14a635073eb1","modified":1725984809922},{"_id":"source/_posts/QFNU_GuidanceForElectiveCoursesInSoftwareDevelopmentDirection.md","hash":"696c6d1166de2d7972aeafb3c02b6050687cd09e","modified":1730293339747},{"_id":"source/_posts/埃拉托斯特尼筛法.md","hash":"98d5e0b1ff0c50af9e7509327f5ec8431b0206e4","modified":1727058224669},{"_id":"source/_posts/编写C语言程序时必须有-include-stdio-h-这一行吗？为什么有时候不需要？.md","hash":"ae9c8fc5ea79a45f891763f223391393fc659fef","modified":1732865136097},{"_id":"source/_posts/题解-算法竞赛团队培训第一次考核.md","hash":"2f7917edb464d8e1e372a6e8168460c3bc0245c9","modified":1730030302160},{"_id":"source/about/index.md","hash":"33744adbe6c4be42c04b6c47c7b07960bbbf0ab6","modified":1732867472073},{"_id":"source/img/avatar.jpg","hash":"ead98690cd137cd0bd92d35c3f5eb8ff7363c569","modified":1732867786680},{"_id":"source/_posts/DataStructures-FromConceptToCppImplementation.md","hash":"d3feac567fbc860c009a259feadcfd04875798c2","modified":1730293267668},{"_id":"source/img/Icon.jpg","hash":"aa073892333b4baa481c084b790a3e808f467283","modified":1732866340225},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1732863322985},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1732863322954},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1732863322842},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"e62d2e25cae57e8469e3f48c9d17be1fd284a969","modified":1732863322989},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1732863322953},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1732863322991},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1732863322992},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1732863322992},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1732863322993},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1732863322993},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1732863322994},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1732863322995},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1732863322995},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1732863322995},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1732863322845},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1732863322845},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1732863322847},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1732863322849},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1732863322851},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1732863322858},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1732863322859},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1732863322895},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1732863322905},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1732863322908},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1732863322914},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1732863322914},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1732863322847},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1732863322850},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1732863322853},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1732863322851},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1732863322854},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1732863322856},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1732863322857},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1732863322857},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1732863322898},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1732863322906},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1732863322910},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1732863322911},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1732863322933},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1732863322925},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1732863322936},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1732863322945},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1732863322932},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1732863322935},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1732863322940},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1732863322924},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1732863322925},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1732863322926},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1732863322932},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1732863322934},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1732863322939},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1732863322947},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1732863322951},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1732863322951},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1732863322953},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1732863322920},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1732863322921},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1732863322927},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1732863322929},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1732863322934},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1732863322938},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1732863322938},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1732863322922},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1732863322923},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1732863322939},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1732863322946},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1732863322950},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1732863322844},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1732863322969},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1732863322970},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1732863322974},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1732863322919},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1732863322921},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1732863322926},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1732863322931},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1732863322935},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1732863322936},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1732863322943},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1732863322952},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1732863322954},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1732863322957},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1732863322919},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1732863322958},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1732863322988},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1732863322948},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1732863322852},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1732863322855},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1732863322854},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1732863322856},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1732863322855},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1732863322856},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1732863322897},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1732863322909},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1732863322915},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1732863322916},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1732863322918},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1732863322918},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1732863322913},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1732863322849},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1732863322848},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1732863322904},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1732863322846},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1732863322847},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1732863322853},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1732863322855},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1732863322856},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1732863322858},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1732863322898},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1732863322899},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1732863322905},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1732863322903},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1732863322916},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1732863322850},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1732863322853},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1732863322900},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1732863322902},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1732863322911},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1732863322913},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1732863322915},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1732863322923},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1732863322928},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1732863322929},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1732863322931},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1732863322933},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1732863322934},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1732863322937},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1732863322963},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1732863322977},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1732863322962},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1732863322964},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1732863322959},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1732863322961},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1732863322963},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1732863322967},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1732863322972},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1732863322972},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1732863322980},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1732863322965},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1732863322965},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1732863322966},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1732863322971},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1732863322974},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1732863322967},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1732863322970},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1732863322975},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1732863322978},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1732863322979},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1732863322986},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1732863322961},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1732863322962},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1732863322964},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1732863322966},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1732863322968},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1732863322968},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1732863322969},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1732863322976},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1732863322969},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1732863322977},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1732863322978},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1732863322983},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1732863322981},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1732863322975},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1732863322984},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1732863322987},{"_id":"source/img/warma.jpg","hash":"72d524ee5ebca1370d3023c0ecf4b8e87cdbdd96","modified":1633169748000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1732863322957},{"_id":"source/img/abc.png","hash":"0e38f59b70bb4ce8723ac936f01d65418f826e7d","modified":1698408713776},{"_id":"public/img/avatar.png","hash":"9658ed8a36f7617349cb887684892ba9037c0ef4","modified":1732871354875},{"_id":"public/img/fluid.png","hash":"2b66a5f82571b1593e83c40bf85d9930ff709dd2","modified":1732871354875},{"_id":"public/img/Icon.jpg","hash":"a74cdfd51e1fcf4516e0fb67b6699cd5716f092b","modified":1732871354875},{"_id":"public/img/abc.png","hash":"06cafe733d18ffa6d0e6a41c09b8842633e287bf","modified":1732871354875},{"_id":"public/local-search.xml","hash":"39320f55913039c04233db894b42ce1d38377df5","modified":1732871354875},{"_id":"public/img/warma.jpg","hash":"8c6c072347d452d0e1c54dde5df38638b480dfde","modified":1732871354875},{"_id":"public/img/avatar.jpg","hash":"5f0fa2a9686da11ac7c9e4ce5c0ff732f3c578d4","modified":1732871354875},{"_id":"public/2024/11/26/编写C语言程序时必须有-include-stdio-h-这一行吗？为什么有时候不需要？/index.html","hash":"3aefa181115b7c9b1bab93b86f3bca23810d84ff","modified":1732871354875},{"_id":"public/about/index.html","hash":"0f4d5c7536d43a07b299521f9b0969e8c1253a22","modified":1732871354875},{"_id":"public/2024/10/30/DataStructures-FromConceptToCppImplementation/index.html","hash":"b845dcc528337064bfe49a2110652f77403c0d41","modified":1732871354875},{"_id":"public/2024/10/27/题解-算法竞赛团队培训第一次考核/index.html","hash":"ea8070bbe1b16bf2c936a0146fa8ccb00891c914","modified":1732871354875},{"_id":"public/2024/09/23/埃拉托斯特尼筛法/index.html","hash":"4ae4c19d0e22f4d3fa641c89178e9dc338bb8673","modified":1732871354875},{"_id":"public/2024/09/11/深刻哀悼/index.html","hash":"2f395bf918fa1af91b6f1cafabf0d7a9bfd322a6","modified":1732871354875},{"_id":"public/2024/08/18/QFNU_GuidanceForElectiveCoursesInSoftwareDevelopmentDirection/index.html","hash":"fc4a1e693b0263641c6082f0993ec370d82306a2","modified":1732871354875},{"_id":"public/archives/index.html","hash":"c46951fd050a5640190ec966d018246306241ff4","modified":1732871354875},{"_id":"public/archives/2024/index.html","hash":"dcf183041af738250010e1ef46d4cb08e7a720d8","modified":1732871354875},{"_id":"public/archives/2024/08/index.html","hash":"cd489eb1d32df9fbb02cd243cd3e838d18a38507","modified":1732871354875},{"_id":"public/archives/2024/11/index.html","hash":"987c5232998eda6c95671e6f8c26754ab6190007","modified":1732871354875},{"_id":"public/index.html","hash":"29802c82c7d0cd3b166dfb1080060827fa9682f9","modified":1732871354875},{"_id":"public/archives/2024/09/index.html","hash":"5e87a1e7ca7c7f2193475d186d62b3f9611f87e9","modified":1732871354875},{"_id":"public/archives/2024/10/index.html","hash":"de10abcc182ff65ed72415401d1cb337ff33926a","modified":1732871354875},{"_id":"public/404.html","hash":"493320dc84124eb1a678eb88cb89466f5ef20b00","modified":1732871354875},{"_id":"public/tags/数据结构/index.html","hash":"f3e96f3c25dc970729833f3631e0da1f352ddb0e","modified":1732871354875},{"_id":"public/tags/index.html","hash":"031cd28e25b28e5d78462dc68abb864a224511fe","modified":1732871354875},{"_id":"public/categories/index.html","hash":"1039a803eb2692e9e0e3f929f392aa19192fb66f","modified":1732871354875},{"_id":"public/links/index.html","hash":"6e66c11fea3757add09530a385d93b6ca181adba","modified":1732871354875},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1732871354875},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1732871354875},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1732871354875},{"_id":"public/css/gitalk.css","hash":"2234d7496740d11b5b53aaaef9155dcb2c6f3f73","modified":1732871354875},{"_id":"public/js/color-schema.js","hash":"eedf9f2349fd0342029287f281f3e48fb6f9bcfe","modified":1732871354875},{"_id":"public/css/highlight-dark.css","hash":"5ab9082a6fd29f7f8ffad02a606967bb841a2ab4","modified":1732871354875},{"_id":"public/css/main.css","hash":"c11861a375d1fdc7a5d6a4bea271e12566cb2dcc","modified":1732871354875},{"_id":"public/js/boot.js","hash":"f82f9de36c6d046fd69471af5d1e916e5004e823","modified":1732871354875},{"_id":"public/js/leancloud.js","hash":"0bdb6d430ad4c41112b9d7db785a4169740f2521","modified":1732871354875},{"_id":"public/css/highlight.css","hash":"54b718c687ce8460e10d501c1eb53a8098942c1e","modified":1732871354875},{"_id":"public/js/img-lazyload.js","hash":"5806e10dc0776dcab1353ce4530179ca25cfc5e0","modified":1732871354875},{"_id":"public/js/local-search.js","hash":"cb1ba2e970e9e82d3cb2863df9735103f4db5880","modified":1732871354875},{"_id":"public/js/events.js","hash":"ba6d18cabec2f40432a2bb8524c0b52e1ac29de9","modified":1732871354875},{"_id":"public/js/utils.js","hash":"2fcfe97c6f342ecd30752ffbde3a6004fcb1bed4","modified":1732871354875},{"_id":"public/js/umami-view.js","hash":"112f8ee00c4cbf8cfe6a4e77bb975e1dc2d1bc93","modified":1732871354875},{"_id":"public/js/plugins.js","hash":"346a6a24966f7dcde0036f69720bc645eddbc8b4","modified":1732871354875},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1732871354875}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2024-11-29T08:04:32.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-11-29 16:04:32\n---\n","updated":"2024-11-29T08:04:32.073Z","path":"about/index.html","comments":1,"layout":"page","_id":"cm42iv3eo0001c0wc8yothpt5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"埃拉托斯特尼筛法","date":"2024-09-23T02:14:59.000Z","_content":"\nSieve of Eratosthenes（埃拉托斯特尼筛法）是一种古老且有效的算法，用于找出一定范围内所有的质数。这个名字来源于古希腊的数学家埃拉托斯特尼，他在公元前3世纪提出了这个算法。\n埃拉托斯特尼筛法的基本思想是从最小的质数开始，逐步筛选掉其倍数，剩下的就是质数。以下是该算法的步骤：\n\n1. 创建一个列表，包含从2开始到你想找到的最大数 $ n $ 的所有整数。\n2. 选择列表中的第一个数（它是2，是唯一的偶数质数），然后将其所有的倍数（除了它自己）标记为非质数。\n3. 找到列表中的下一个未被标记的数，它是下一个质数，然后重复步骤2，将其所有的倍数标记为非质数。\n4. 继续这个过程，直到你到达列表的末尾。\n5. 在这个过程中未被标记的数就是质数。\n以下是埃拉托斯特尼筛法的伪代码示例：\n```\nfunction SieveOfEratosthenes(n)\n    create a list \"prime[0..n]\" and initialize all entries as true.\n    A value in prime[i] will finally be false if i is Not a prime, else true bool prime[n+1];\n    memset(prime, true, sizeof(prime));\n    for p = 2 to sqrt(n)\n        if prime[p] is true\n            for i = p*p to n step p\n                prime[i] = false\n    for p = 2 to n\n        if prime[p] is true\n            print p\n```\n埃拉托斯特尼筛法的时间复杂度是 $ O(n \\log \\log n) $，这使得它非常适用于寻找小于一百万或更大的范围内的所有质数。尽管这个算法在处理非常大的数字时效率不是最高的，但它因其简单性和易于实现而广受欢迎。\n\n```-\ndef sieve_of_eratosthenes(n):\n    # 初始化一个布尔数组，所有的值都设为True\n    prime = [True for _ in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        # 如果prime[p]没有被改变，那么它是一个质数\n        if prime[p] == True:\n            # 更新所有p的倍数为非质数\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\n    # 收集所有质数\n    primes = []\n    for p in range(2, n):\n        if prime[p]:\n            primes.append(p)\n    return primes\n\n# 示例：找出小于30的所有质数\nprint(sieve_of_eratosthenes(30))\n```\n","source":"_posts/埃拉托斯特尼筛法.md","raw":"---\ntitle: 埃拉托斯特尼筛法\ndate: 2024-09-23 10:14:59\ntags:\n---\n\nSieve of Eratosthenes（埃拉托斯特尼筛法）是一种古老且有效的算法，用于找出一定范围内所有的质数。这个名字来源于古希腊的数学家埃拉托斯特尼，他在公元前3世纪提出了这个算法。\n埃拉托斯特尼筛法的基本思想是从最小的质数开始，逐步筛选掉其倍数，剩下的就是质数。以下是该算法的步骤：\n\n1. 创建一个列表，包含从2开始到你想找到的最大数 $ n $ 的所有整数。\n2. 选择列表中的第一个数（它是2，是唯一的偶数质数），然后将其所有的倍数（除了它自己）标记为非质数。\n3. 找到列表中的下一个未被标记的数，它是下一个质数，然后重复步骤2，将其所有的倍数标记为非质数。\n4. 继续这个过程，直到你到达列表的末尾。\n5. 在这个过程中未被标记的数就是质数。\n以下是埃拉托斯特尼筛法的伪代码示例：\n```\nfunction SieveOfEratosthenes(n)\n    create a list \"prime[0..n]\" and initialize all entries as true.\n    A value in prime[i] will finally be false if i is Not a prime, else true bool prime[n+1];\n    memset(prime, true, sizeof(prime));\n    for p = 2 to sqrt(n)\n        if prime[p] is true\n            for i = p*p to n step p\n                prime[i] = false\n    for p = 2 to n\n        if prime[p] is true\n            print p\n```\n埃拉托斯特尼筛法的时间复杂度是 $ O(n \\log \\log n) $，这使得它非常适用于寻找小于一百万或更大的范围内的所有质数。尽管这个算法在处理非常大的数字时效率不是最高的，但它因其简单性和易于实现而广受欢迎。\n\n```-\ndef sieve_of_eratosthenes(n):\n    # 初始化一个布尔数组，所有的值都设为True\n    prime = [True for _ in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        # 如果prime[p]没有被改变，那么它是一个质数\n        if prime[p] == True:\n            # 更新所有p的倍数为非质数\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\n    # 收集所有质数\n    primes = []\n    for p in range(2, n):\n        if prime[p]:\n            primes.append(p)\n    return primes\n\n# 示例：找出小于30的所有质数\nprint(sieve_of_eratosthenes(30))\n```\n","slug":"埃拉托斯特尼筛法","published":1,"updated":"2024-09-23T02:23:44.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3el0000c0wcacxp1yh7","content":"<p>Sieve of Eratosthenes（埃拉托斯特尼筛法）是一种古老且有效的算法，用于找出一定范围内所有的质数。这个名字来源于古希腊的数学家埃拉托斯特尼，他在公元前3世纪提出了这个算法。<br>埃拉托斯特尼筛法的基本思想是从最小的质数开始，逐步筛选掉其倍数，剩下的就是质数。以下是该算法的步骤：</p>\n<ol>\n<li>创建一个列表，包含从2开始到你想找到的最大数 $ n $ 的所有整数。</li>\n<li>选择列表中的第一个数（它是2，是唯一的偶数质数），然后将其所有的倍数（除了它自己）标记为非质数。</li>\n<li>找到列表中的下一个未被标记的数，它是下一个质数，然后重复步骤2，将其所有的倍数标记为非质数。</li>\n<li>继续这个过程，直到你到达列表的末尾。</li>\n<li>在这个过程中未被标记的数就是质数。<br>以下是埃拉托斯特尼筛法的伪代码示例：<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">function</span> SieveOfEratosthenes(n)<br>    <span class=\"hljs-keyword\">create</span> a list &quot;prime[0..n]&quot; <span class=\"hljs-keyword\">and</span> initialize <span class=\"hljs-keyword\">all</span> entries <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">true</span>.<br>    A <span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">in</span> prime[i] will finally be <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">Not</span> a prime, <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">true</span> <span class=\"hljs-type\">bool</span> prime[n+<span class=\"hljs-number\">1</span>];<br>    memset(prime, <span class=\"hljs-keyword\">true</span>, sizeof(prime));<br>    <span class=\"hljs-keyword\">for</span> p = <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">to</span> sqrt(n)<br>        <span class=\"hljs-keyword\">if</span> prime[p] <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">true</span><br>            <span class=\"hljs-keyword\">for</span> i = p*p <span class=\"hljs-keyword\">to</span> n step p<br>                prime[i] = <span class=\"hljs-keyword\">false</span><br>    <span class=\"hljs-keyword\">for</span> p = <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">to</span> n<br>        <span class=\"hljs-keyword\">if</span> prime[p] <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">true</span><br>            print p<br></code></pre></td></tr></table></figure>\n埃拉托斯特尼筛法的时间复杂度是 $ O(n \\log \\log n) $，这使得它非常适用于寻找小于一百万或更大的范围内的所有质数。尽管这个算法在处理非常大的数字时效率不是最高的，但它因其简单性和易于实现而广受欢迎。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs -\">def sieve_of_eratosthenes(n):<br>    # 初始化一个布尔数组，所有的值都设为True<br>    prime = [True for _ in range(n+1)]<br>    p = 2<br>    while (p * p &lt;= n):<br>        # 如果prime[p]没有被改变，那么它是一个质数<br>        if prime[p] == True:<br>            # 更新所有p的倍数为非质数<br>            for i in range(p * p, n+1, p):<br>                prime[i] = False<br>        p += 1<br><br>    # 收集所有质数<br>    primes = []<br>    for p in range(2, n):<br>        if prime[p]:<br>            primes.append(p)<br>    return primes<br><br># 示例：找出小于30的所有质数<br>print(sieve_of_eratosthenes(30))<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Sieve of Eratosthenes（埃拉托斯特尼筛法）是一种古老且有效的算法，用于找出一定范围内所有的质数。这个名字来源于古希腊的数学家埃拉托斯特尼，他在公元前3世纪提出了这个算法。<br>埃拉托斯特尼筛法的基本思想是从最小的质数开始，逐步筛选掉其倍数，剩下的就是质数。以下是该算法的步骤：</p>\n<ol>\n<li>创建一个列表，包含从2开始到你想找到的最大数 $ n $ 的所有整数。</li>\n<li>选择列表中的第一个数（它是2，是唯一的偶数质数），然后将其所有的倍数（除了它自己）标记为非质数。</li>\n<li>找到列表中的下一个未被标记的数，它是下一个质数，然后重复步骤2，将其所有的倍数标记为非质数。</li>\n<li>继续这个过程，直到你到达列表的末尾。</li>\n<li>在这个过程中未被标记的数就是质数。<br>以下是埃拉托斯特尼筛法的伪代码示例：<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">function</span> SieveOfEratosthenes(n)<br>    <span class=\"hljs-keyword\">create</span> a list &quot;prime[0..n]&quot; <span class=\"hljs-keyword\">and</span> initialize <span class=\"hljs-keyword\">all</span> entries <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">true</span>.<br>    A <span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">in</span> prime[i] will finally be <span class=\"hljs-keyword\">false</span> <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">Not</span> a prime, <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">true</span> <span class=\"hljs-type\">bool</span> prime[n+<span class=\"hljs-number\">1</span>];<br>    memset(prime, <span class=\"hljs-keyword\">true</span>, sizeof(prime));<br>    <span class=\"hljs-keyword\">for</span> p = <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">to</span> sqrt(n)<br>        <span class=\"hljs-keyword\">if</span> prime[p] <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">true</span><br>            <span class=\"hljs-keyword\">for</span> i = p*p <span class=\"hljs-keyword\">to</span> n step p<br>                prime[i] = <span class=\"hljs-keyword\">false</span><br>    <span class=\"hljs-keyword\">for</span> p = <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">to</span> n<br>        <span class=\"hljs-keyword\">if</span> prime[p] <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">true</span><br>            print p<br></code></pre></td></tr></table></figure>\n埃拉托斯特尼筛法的时间复杂度是 $ O(n \\log \\log n) $，这使得它非常适用于寻找小于一百万或更大的范围内的所有质数。尽管这个算法在处理非常大的数字时效率不是最高的，但它因其简单性和易于实现而广受欢迎。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs -\">def sieve_of_eratosthenes(n):<br>    # 初始化一个布尔数组，所有的值都设为True<br>    prime = [True for _ in range(n+1)]<br>    p = 2<br>    while (p * p &lt;= n):<br>        # 如果prime[p]没有被改变，那么它是一个质数<br>        if prime[p] == True:<br>            # 更新所有p的倍数为非质数<br>            for i in range(p * p, n+1, p):<br>                prime[i] = False<br>        p += 1<br><br>    # 收集所有质数<br>    primes = []<br>    for p in range(2, n):<br>        if prime[p]:<br>            primes.append(p)<br>    return primes<br><br># 示例：找出小于30的所有质数<br>print(sieve_of_eratosthenes(30))<br></code></pre></td></tr></table></figure>\n"},{"title":"数据结构（cpp实现）","date":"2024-10-30T12:56:55.000Z","_content":"\n\n# 第一章\n\n## 七桥问题\n\n七桥问题是一个经典的图论问题，它是由数学家欧拉在18世纪提出的。问题的背景是哥尼斯堡（今俄罗斯的加里宁格勒）的一个地区，该地区被普雷格尔河分成四个区域，并由七座桥连接。问题是：是否有可能从某个区域出发，不重复地走过所有七座桥，并且回到起点。\n我们可以这样求解七桥问题：\n\n1. 首先，我们需要确定每个顶点（即每个城区）相关联的边数（即桥的数量）。\n2. 然后，我们根据以下规则进行判定：\n   - 如果所有顶点相关联的边数都是偶数，则存在欧拉回路。\n   - 如果有超过两个顶点相关联的边数是奇数，则不存在欧拉回路。\n   - 如果恰好有两个顶点相关联的边数是奇数，则不存在欧拉回路，但存在一条从这两个顶点之一出发的欧拉路径（不会回到起点）。\n   对于七桥问题，我们可以将四个区域视为四个顶点，七座桥视为连接这些顶点的边。通过计算每个顶点相关联的边数，我们可以得到以下结果：\n- 两个区域（顶点）各有三座桥相连，因此这两个区域相关联的边数是奇数。\n- 另外两个区域（顶点）各有两座桥相连，因此这两个区域相关联的边数是偶数。\n根据判定规则，因为有超过两个顶点相关联的边数是奇数（具体来说，有两个顶点），所以七桥问题中不存在欧拉回路。同时，也不存在从这两个顶点之一出发的欧拉路径，因为路径要求不重复地走过所有边，而这是不可能的。\n因此，结论是：在七桥问题中，不可能找到一条不重复地走过所有七座桥的路径，并且返回起点。\n\n```c++\n#include<iostream>\nusing namespace std;\nconst int MaxSize=4;\nclass EulerCircuit {\npublic:\n    EulerCircuit(int a[][MaxSize],int n);\n    int oddVertexNum();\nprivate:\n    int mat[MaxSize][MaxSize];\n    int vertexNum;\n};\nEulerCircuit::EulerCircuit(int a[][MaxSize],int n){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            mat[i][j]=a[i][j];\n        }\n    }\n    vertexNum=n;\n}\nint EulerCircuit::oddVertexNum(){\n    int count=0,i,j,degree;\n    for(i=0;i<vertexNum;i++){\n        degree=0;\n        for(j=0;j<vertexNum;j++){ // 这里应该是 j++ 而不是 i++\n            degree=degree+mat[i][j];\n        }\n        if(degree%2!=0){\n            count++;\n        }\n    }\n    return count;\n}\nint main(){\n    int a[4][MaxSize]={\n        {0,1,2,2},\n        {1,0,1,1},\n        {2,1,0,0},\n        {2,1,0,0}\n    };\n    EulerCircuit G{a,4};\n    int num=G.oddVertexNum();\n    if(num>=2){\n        cout<<num<<\"个地方通奇数桥，不存在欧拉回路\";\n    }\n    else{\n        cout<<\"存在欧拉回路\";\n    }\n    return 0;\n}\n```\n\n## 欧几里得算法\n\n欧几里得算法用自然语言描述如下：\n\n步骤1：将m除以n得到余数r\n\n步骤2：若r等于0，则n为最大公约数，算法结束；否则执行步骤3\n\n步骤3：将n的值放在m中，将r的值放在n中，重新执行步骤1\n\n```c++\n#include <iostream>\nusing namespace std;\nint ComFactor(int m,int n) {\n    int r=m%n;\n    while (r!=0) {\n        m=n;\n        n=r;\n        r=m%n;\n    }\n    return n;\n}\nint main() {\n    cout<<\"最大公约数是\"<<ComFactor(35,25)<<endl;\n    return 0;\n}\n```\n\n# 第二章\n\n## 线性表的定义\n\n线性表简称表，是n个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度，长度等于零的线性表称为空表，一个非空表通常记为：\n$$\nL=(a1,a2,...,an)\n$$\n其中，ai称为数据元素，下角标i表示该元素在线性表中的位置或序号，称元素ai位于表的第i个位置，或称是ai是表中的第i的元素。a1称为表头元素，an称为表尾元素，任意一对相邻的数据元素a（i-1）和ai（1<i<=n）之间存在序偶关系<a(i-1),ai>，且a(i-1)称为ai的前驱，ai称为a(i-1)的后继。在这个序列中，元素a1无前驱，元素an无后继，其他每个元素有且仅有一个前驱和一个后继\n\n线性表的基本操作包括：\n\n1. **初始化**：创建一个空的线性表。\n2. **销毁**：销毁线性表，释放其占用的内存空间。\n3. **插入**：在指定位置插入一个元素。\n4. **删除**：删除指定位置的元素。\n5. **查找**：查找并返回指定元素的位置。\n6. **取值**：获取指定位置的元素。\n7. **修改**：修改指定位置的元素。\n8. **长度**：返回线性表的长度（元素个数）。\n9. **判空**：判断线性表是否为空。\n\n## 线性表的顺序存储结构及实现\n\n线性表的顺序存储结构称为顺序表，其基本思想是用一段地址连续的存储单元依次存储线性表的数据元素\n\n设顺序表的每个元素占用c个存储单元，则第i个元素的存储地址为：\n$$\nLoc(ai)=Loc(a1)+(i-1)*c\n$$\n顺序表中数据元素的存储地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任何一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存取结构\n\n通常用一维数组来实现顺序表\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int MaxSize=100;//根据实际问题具体定义\ntemplate <typename DataType>//由于线性表的数据元素类型不确定，所以采用模板机制\nclass SeqList {\npublic:\n    SeqList();//创建一个空的线性表\n    SeqList(DataType a[],int n);//建立长度为n的顺序表\n    ~SeqList();//析构函数，销毁线性表，释放其占用的内存空间\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DataType data[MaxSize];//存放数据元素的数组\n    int length;//线性表的长度\n};\ntemplate<typename DataType>\nSeqList<DataType>::SeqList() {\n    length=0;\n}\n\ntemplate<typename DataType>\nSeqList<DataType>::SeqList(DataType a[], int n) {\n    if(n>MaxSize)throw\"参数非法\";\n    for(int i=0;i<n;i++) {\n        data[i]=a[i];\n    }\n    length=n;\n}\n\ntemplate<typename DataType>\nSeqList<DataType>::~SeqList() {}//\n\ntemplate<typename DataType>\nint SeqList<DataType>::Empty() {\n    return length==0;\n}\n\ntemplate<typename DataType>\nint SeqList<DataType>::Length() {\n    return length;\n}\n\ntemplate<typename DataType>\nvoid SeqList<DataType>::PrintList() {\n    for(int i=0;i<length;i++) {\n        cout<<data[i]<<'\\t';\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nDataType SeqList<DataType>::Get(int i) {//时间复杂度为O(1)\n    if(i<1||i>length)throw\"查找位置非法\";\n    else {\n        return data[i-1];\n    }\n}\n\ntemplate<typename DataType>\nint SeqList<DataType>::Locate(DataType x) {//平均时间性能是O(n)\n    for(int i=0;i<length;i++) {\n        if(data[i]==x)return i+1;\n    }\n    return 0;\n}\n\ntemplate<typename DataType>\nvoid SeqList<DataType>::Insert(int i, DataType x) {//平均时间性能是O(n)\n    if(length==MaxSize)throw\"表满，上溢\";\n    if(i<1||i>length+1)throw\"插入位置错误\";\n    for(int j=length;j>=i;j--) {\n        data[j]==data[j-1];\n    }\n    data[i-1]=x;\n    length++;\n}\n\ntemplate<typename DataType>\nDataType SeqList<DataType>::Delete(int i) {//平均时间性能是O(n)\n    DataType x;\n    if(length==0)throw\"空表 下溢\";\n    if(i<1||i>length)throw\"删除位置错误\";\n    x=data[i-1];\n    for(int j=i;j<length;j++) {\n        data[j-1]=data[j];\n    }\n    length--;\n    return x;\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    SeqList<int>L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 线性表的链接存储结构及其实现\n\n单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。为了能正确表示元素之间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成了数据元素的存储映像，称为结点。\n\n### 单链表的结点定义\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n在使用单链表时，关心的只是数据元素以及数据元素之间的逻辑关系\n\n单链表中每个结点的存储地址存放在其前驱结点的next域中，而第一个结点无前驱，所以设头指针指向第一个元素所在结点，整个单链表的存取必须从头指针开始进行，因而头指针具有标识一个单链表的作用。最后一个元素所在结点的指针域为空。\n\n### 单链表的实现\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType> *next;\n};\n\ntemplate<typename DataType>\nclass LinkList {\npublic:\n    LinkList();\n    LinkList(DataType a[],int n);\n    ~LinkList();\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    Node<DataType> *first;\n};\n\ntemplate<typename DataType>\nLinkList<DataType>::LinkList() {\n    first=new Node<DataType>;\n    first->next=nullptr;\n    /* nullptr是一个字面常量，表示空指针\n       它用于初始化指针变量或将其赋值给指针变量，\n       以确保指针不指向任何有效的内存地址 */\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Empty() {\n    return first->next==nullptr;\n}\n\ntemplate<typename DataType>\nvoid LinkList<DataType>::PrintList() {//时间复杂度为O(n)\n    //设置工作指针p依次指向各节点\n    //p后移不能写作p++\n    Node<DataType> *p=first->next;\n    while (p!=nullptr) {\n        cout<<p->data<<\" \";\n        p=p->next;//工作指针后移\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Length() {\n    Node<DataType> *p=first->next;\n    int count=0;\n    while (p!=nullptr) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    return count;\n}\n\ntemplate<typename DataType>\nDataType LinkList<DataType>::Get(int i) {\n    Node<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr && count<i) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    if(p==nullptr)throw \"查找位置错误\" ;\n    else {\n        return p->data;\n    }\n    //平均时间性能为O(n),单链表是顺序存取结构\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Locate(DataType x) {\n    Node<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr) {\n        if(p->data==x) {\n            return count;\n        }\n        p=p->next;\n        count++;\n    }\n    return 0;\n    //平均时间性能为O(n)\n}\n\ntemplate<typename DataType>\nvoid LinkList<DataType>::Insert(int i, DataType x) {//时间复杂度为O(n)\n    Node<DataType> *p=first,*s=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr)throw\"插入位置错误\";\n    else {\n        s=new Node<DataType>;\n        s->data=x;\n        s->next=p->next;\n        p->next=s;\n    }\n}\n\ntemplate<typename DataType>\nLinkList<DataType>::LinkList(DataType a[], int n) {\n    //头插法\n    first=new Node<DataType>;\n    first->next=nullptr;\n    for(int i=0;i<n;i++) {\n        Node<DataType> *s=nullptr;\n        s=new Node<DataType>;\n        s->data=a[i];\n        s->next=first->next;\n        first->next=s;\n    }\n    //尾插法\n    // first=new Node<DataType>;\n    // Node<DataType> *r=first,*s=nullptr;\n    // for(int i=0;i<n;i++) {\n    //     s=new Node<DataType>;\n    //     s->data=a[i];\n    //     r->next=s;\n    //     r=s;\n    // }\n    // r->next=nullptr;\n}\n\ntemplate<typename DataType>\nDataType LinkList<DataType>::Delete(int i) {\n    DataType x;\n    Node<DataType> *p=first,*q=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr || p->next==nullptr)throw \"删除位置错误\" ;\n    else {\n        q=p->next;\n        x=q->data;\n        p->next=q->next;\n        delete q;\n        return x;\n    }\n}\n\ntemplate<typename DataType>\nLinkList<DataType>::~LinkList() {\n    Node<DataType> *p=first;\n    while (first!=nullptr) {\n        first=first->next;\n        delete p;\n        p=first;\n    }\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    LinkList<int> L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 双链表\n\n在单链表的每个结点中再设置一个指向其前驱结点的指针域，这样就形成了双链表\n\n### 双链表的结点结构定义：\n\n```c++\ntemplate<typename Datatype>\nstruct DulNode {\n    Datatype data;\n    DulNode<Datatype> *prior,*next;\n};\n```\n\n在双链表中求表长等操作与单链表基本相同，下面讨论插入和删除操作\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate<typename Datatype>\nstruct DulNode {\n    Datatype data;\n    DulNode<Datatype> *prior,*next;\n};\n\ntemplate<typename DataType>\nclass DulLinkList {\npublic:\n    DulLinkList();\n    DulLinkList(DataType a[],int n);\n    ~DulLinkList();\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DulNode<DataType> *first;\n};\n\ntemplate<typename DataType>\nDulLinkList<DataType>::DulLinkList() {\n    first=new DulNode<DataType>;\n    first->next=nullptr;\n    first->prior=nullptr;\n    /* nullptr是一个字面常量，表示空指针\n       它用于初始化指针变量或将其赋值给指针变量，\n       以确保指针不指向任何有效的内存地址 */\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Empty() {\n    return first->next==nullptr;\n}\n\ntemplate<typename DataType>\nvoid DulLinkList<DataType>::PrintList() {//时间复杂度为O(n)\n    //设置工作指针p依次指向各节点\n    //p后移不能写作p++\n    DulNode<DataType> *p=first->next;\n    while (p!=nullptr) {\n        cout<<p->data<<\" \";\n        p=p->next;//工作指针后移\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Length() {\n    DulNode<DataType> *p=first->next;\n    int count=0;\n    while (p!=nullptr) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    return count;\n}\n\ntemplate<typename DataType>\nDataType DulLinkList<DataType>::Get(int i) {\n    DulNode<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr && count<i) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    if(p==nullptr)throw \"查找位置错误\" ;\n    else {\n        return p->data;\n    }\n    //平均时间性能为O(n),单链表是顺序存取结构\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Locate(DataType x) {\n    DulNode<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr) {\n        if(p->data==x) {\n            return count;\n        }\n        p=p->next;\n        count++;\n    }\n    return 0;\n    //平均时间性能为O(n)\n}\n\ntemplate<typename DataType>\nvoid DulLinkList<DataType>::Insert(int i, DataType x) {//时间复杂度为O(n)\n    DulNode<DataType> *p=first,*s=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr)throw\"插入位置错误\";\n    else {\n        s=new DulNode<DataType>;\n        s->data=x;\n        //与单链表不同之处//这里\n        s->prior=p;\n        s->next=p->next;\n        p->next->prior=s;\n        p->next=s;\n    }\n}\n\ntemplate<typename DataType>\nDulLinkList<DataType>::DulLinkList(DataType a[], int n) {\n    //头插法\n    first=new DulNode<DataType>;\n    first->next=nullptr;\n    for(int i=0;i<n;i++) {\n        DulNode<DataType> *s=nullptr;\n        s=new DulNode<DataType>;\n        s->data=a[i];\n        s->next=first->next;\n        first->next=s;\n    }\n    //尾插法\n    // first=new DulNode<DataType>;\n    // DulNode<DataType> *r=first,*s=nullptr;\n    // for(int i=0;i<n;i++) {\n    //     s=new DulNode<DataType>;\n    //     s->data=a[i];\n    //     r->next=s;\n    //     r=s;\n    // }\n    // r->next=nullptr;\n}\n\ntemplate<typename DataType>\nDataType DulLinkList<DataType>::Delete(int i) {//这里\n    DulNode<DataType> *p = first;\n    DulNode<DataType> *q;\n    int count = 0;\n    while (p != nullptr && count < i - 1) {\n        p = p->next;\n        count++;\n    }\n\n    if (p == nullptr || p->next == nullptr) {\n        throw std::runtime_error(\"删除位置错误\");\n    } else {\n        q = p->next; // Save the node to be deleted\n        p->next = q->next; // Update next of the previous node\n        q->next->prior = p; // Update prior of the next node\n        DataType x = q->data; // Save data to return\n        delete q; \n        return x; \n    }\n}\n\ntemplate<typename DataType>\nDulLinkList<DataType>::~DulLinkList() {\n    DulNode<DataType> *p=first;\n    while (first!=nullptr) {\n        first=first->next;\n        delete p;\n        p=first;\n    }\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    DulLinkList<int> L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 循环链表\n\n在单链表中，如果将终端结点的指针由空指针改为指向头结点，就使得整个单链表形成一个环，这种头尾相接的单链表称为循环单链表。实际应用中多采用尾指针指示的循环单链表\n\n在双链表中，如果将终端结点的后继指针由空指针改为指向头结点，将头结点的前驱指针由空指针改为指向终端结点，就使得整个双链表形成一个环，这种头尾相接的单链表称为循环双链表\n\n循环链表中没有明显的尾端，可能会使循环链表的处理操作进入死循环，通常判断用作循环变量的工作指针是否等于某一特定指针（如头指针或尾指针），以判定工作指针是否扫描了整个链表，例如可以用循环条件  `p!=first`  判断工作指针是否扫描了整个链表\n\n## 顺序表和链表的比较\n\n### 1.时间性能比较\n\n所谓时间性能是指基某种存储结构的基本操作（即算法）的时间复杂度。\n\n**随机访问**\n- **顺序表**：能够直接定位到任意位置，实现快速访问，时间复杂度为 O(1)。\n- **链表**：必须从头部开始遍历至目标位置，平均时间复杂度为 O(n)。\n\n**插入与删除**\n- **链表**：一旦拥有指向目标位置的指针，插入或删除操作无需移动其他元素，时间复杂度为 O(1)。\n- **顺序表**：插入或删除元素需要调整后续所有元素的位置，平均时间复杂度为 O(n)，尤其是当元素数量大或每个元素占用较大存储空间时，移动元素的成本显著增加。\n\n**一般来说**\n\n- 当线性表的主要操作是**频繁查找**且**插入和删除较少**，或操作依赖于**数据元素的绝对位置**时，**顺序表**是更优的选择。\n- 若线性表中**频繁执行插入和删除操作**，**链表**则提供更好的性能。\n\n### 2.空间性能比较\n\n所谓空间性能是指某种存储结构所占用的存储空间的大小。\n\n- **存储特性**\n  - **顺序表**: 每个结点仅包含数据元素，存储密度高，空间利用率好。\n  - **链表**: 结点包含数据元素和指针，指针增加结构开销，降低存储密度。\n- **空间分配**\n  - **顺序表**: 需预分配固定大小空间，可能造成浪费（分配过多）或上溢（分配不足）。\n  - **链表**: 动态分配，元素数量不受限，只要系统有可用内存。\n- **适用场景**\n  - **顺序表**: 适合已知大致长度的线性表，以优化空间效率。\n  - **链表**: 更适用于元素数量变化大或未知的情况。\n\n## 扩展与提高\n\n### 线性表的静态链表存储\n\n静态链表用数组来表示链表。由于是利用数组定义的链表，属于静态存储分配，因此叫静态链表。最常用的是静态单链表。\n\navail是空闲链表（全部由空闲数组单元组成的单链表）头指针，first是静态链表头指针，为了运算方便通常静态链表也带头指针。\n\n**静态链表的数组元素定义：**\n\n```c++\ntemplate <typename DateType>\nstruct SNode {\n    DateType data;\n    int next;//指针域(也称游标),注意不是指针类型\n};\n```\n\n**静态链表的定义：**\n\n```c++\nconst int MaxSize=100;\ntemplate <typename DataType>\nclass StaList {\npublic:\n    StaList();\n    StaList(DataType a[],int n);\n    ~StaList();\n    //与单链表成员函数相同\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    SNode<DataType> SList[MaxSize];\n    int first,avail;\n};\n```\n\n静态链表采用静态存储分配，因此析构函数为空，求表长等操作的实现基本与单链表相同，下面讨论**插入和删除**操作\n\n在静态链表中进行插入操作，首先从空闲链的最前端摘下一个结点，将该结点插入静态链表中，假设新结点插在结点p的后面，则修改指针的操作为：\n\n```c++\ns=avail;\navail=SList[avail].next;\nSList[s].data=x;\nSList[s].next=SList[p].next;\nSList[p].next=s;\n```\n\n在静态链表中进行删除操作，首先将被删除结点从静态链表中摘下，再插入空闲链的最前端，假设要删除结点p的后继结点，则修改指针的操作为：\n\n```\nq=SList[p].next;\nSList[p].next=SList[q].next;\nSList[q].next=avail;\navail=q;\n```\n\n### 顺序表的动态分配方式\n\n顺序表的动态分配方式是在程序执行过程中通过动态存储分配，一旦数组空间占满，另外再分配一块更大的存储空间，用来替换原来的存储空间，从而达到扩充数组空间的目的\n\n```c++\nconst int InitSize=100;//顺序表的初始长度\nconst int IncreSize=10;//顺序表存储空间每次扩展的长度\ntemplate <typename DataType>\nclass SeqList {\npublic:\n    //与顺序表的静态分配相同\n    SeqList();\n    SeqList(DataType a[],int n);\n    ~SeqList();\n    //与单链表成员函数相同\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DataType *data;//动态申请数组空间的首地址\n    int maxSize;//当前数组空间的最大长度\n    int length;//线性表的长度\n};\n```\n\n在顺序表的动态分配方式下，求线性表的长度等操作与顺序表的静态分配方式相同，下面讨论其他基本操作的实现\n\n#### 无参构造函数——初始化顺序表：\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::SeqList() {\n    data=new DataType[InitSize];\n    maxSize=InitSize;\n    length=0;\n}\n```\n\n#### 有参构造函数——建立顺序表：\n\n建立一个长度为*n*的顺序表需要申请长度大于n的存储空间，一般是当前线性表长度两倍的存储空间：\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::SeqList(DataType a[], int n) {\n    data=new DataType[2*n];\n    maxSize=2*n;\n    for(int i=0;i<n;i++) {\n        data[i]=a[i];\n    }\n    length=n;\n}\n```\n\n#### 析构函数——销毁顺序表\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::~SeqList() {\n    delete[] data;\n}\n```\n\n#### 插入操作\n\n```c++\n// 在序列的第i个位置插入元素x\ntemplate<typename DataType>\nvoid SeqList<DataType>::Insert(int i, DataType x) {\n    // 检查插入位置是否合法\n    if(i<1||i>length+1)throw\"插入位置错误!\";\n    // 检查序列是否已满\n    if(length==maxSize) {\n        // 发生上溢,扩充存储空间\n        DataType *oldData=data;\n        maxSize+=IncreSize;\n        data=new DataType[maxSize];\n        // 将旧数据复制到新数组\n        for(int j=0;j<length;j++) {\n            data[j]=oldData[j];\n        }\n        // 释放旧数组的内存\n        delete[] oldData;\n    }\n    // 为新元素腾出空间\n    for(int j=length;j>=i;j--) {\n        data[j]=data[j-1];\n    }\n    // 插入新元素\n    data[i-1]=x;\n    // 更新序列长度\n    length++;\n}\n```\n\n## 应用示例\n\n### 约瑟夫环问题\n\n由于约瑟夫环问题本身具有循环性质，考虑采用循环单链表。求解约瑟夫环的问题的基本思路是：设置一个计数器count和工作指针p，当计数器累加到m时删除结点p。为了统一对链表中任意结点进行计数和删除操作，循环单链表不带头结点；为了便于删除操作设两个工作指针pre和p，指针pre指向p的前驱结点；为了使计数器从1开始奇数，采用尾指针指示的循环单链表，将指针pre初始化为指向终端结点，将指针p初始化为开始结点。\n\n```c++\n#include <iostream>\nusing namespace std;\nstruct Node {//约瑟夫环的结点定义\n    int data;\n    struct Node *next;\n};\nclass JosephRing {\npublic:\n    JosephRing(int n);//构造函数，初始化n个结点的循环单链表\n    ~JosephRing();//析构函数，类似单链表的析构函数\n    void Joseph(int m);//为m，打印出环的顺序\nprivate:\n    Node *rear;\n};\nJosephRing::~JosephRing() {\n    \n}\nJosephRing::JosephRing(int n) {\n    Node *s=nullptr;\n    rear=new Node;\n    rear->data=1;rear->next=rear;//建立长度为1的循环单链表\n    for(int i=2;i<=n;i++) {//依次插入数据域为2、3...n的结点\n        s=new Node;\n        s->data=i;\n        s->next=rear->next;//将结点s插入尾结点rear的后面\n        rear->next=s;\n        rear=s;\n    }\n}\nvoid JosephRing::Joseph(int m) {\n    Node *pre=rear,*p=rear->next;\n    int count=1;\n    cout<<\"出环的顺序是:\";\n    while (p->next!=p) {\n        if(count<m) {\n            pre=p;p=p->next;\n            count++;\n        }\n        else {\n            cout<<p->data<<\"\\t\";\n            pre->next=p->next;//将p摘链\n            delete p;\n            p=pre->next;//工作指针p后移，但pre不动\n            count=1;\n        }\n    }\n    cout<<p->data<<\"\\t\";\n    delete p;\n}\nint main() {\n    int n,m;\n    cout<<\"请输入约瑟夫环的长度：\";\n    cin>>n;\n    cout<<\"请输入密码：\";\n    cin>>m;\n    JosephRing R{n};\n    R.Joseph(m);\n    return 0;\n}\n```\n\n### 一元多项式求和\n\n若相加的某两项的指数不等，则两项应分别加在结果中，将引起线性表的插入；若某两项的指数相等，则系数相加，若相加结果为零，将引起线性表的删除。由于在线性表的合并过程中需要频繁地执行插入和删除操作，因此考虑采取单链表存储。\n\n在表示一元多项式的单链表中，每一个非零项对应单链表中的一个结点，且单链表应按指数递增有序排列。\n\n其中，coef 为系数域，存放非零项的系数；exp为指数域，存放非零项的指数；next 为指针域，存放指向下一结点的指针。\n\n下面分析一元多项式求和的执行过程。\n\n设单链表A和B分别存储两个多项式，求和结果存储在单链表 A 中，设两个工作指针p和q分别指向两个单链表的开始结点。\n\n两个多项式求和实质上是对结点p的指数域和结点q的指数域进行比较，有下列三种情况：\n\n① 若p一>exp 小于q一>exp，则结点p应为结果链表中的一个结点，将指针p后移\n\n② 若p->exp大于q一＞exp，则结点q应为结果中的一个结点，将q插入到第一个单链表中结点P之前，并将指针q指向单链表B中的下一个结点。为此，在单链表A 中应该设置两个工作指针 pre 和p，使得pre 指向p的前驱结点。\n\n③ 若p->exp等于q->exp，则p与q所指为同类项，将q的系数加到p的系数上。若相加结果不为0，则将指针P后移，并删除结点q，为此，在单链表B中应该设置两个工作指针 qre 和q，使得gre 指向q的前驱结点；若相加结果为0，则表明结果中无此项，删除结点p和结点 q，并将指针p 和指针q分别后移。\n\n```c++\n#include <iostream>\nusing namespace std;\nstruct Node {\n    int coef,exp;\n    Node *next;\n};\nclass Polynomial {\npublic:\n    Polynomial();\n    Polynomial(const Polynomial &B);//拷贝构造函数\n    /*拷贝构造函数是C++中一种特殊的构造函数，用于创建一个对象作为已存在对象的副本\n    这种构造函数的名称与类名相同，形式参数只有一个，即该类的引用类型的对象.\n    通常，这个形参会被声明为const，以确保在构造过程中不会修改原对象.\n    拷贝构造函数的主要应用场景包括，当一个对象作为值传递的参数传递给函数，\n    或者函数返回一个对象时，都需要调用到拷贝构造函数*/\n    ~Polynomial();\n    Polynomial operator+(Polynomial &B);//重载运算符,多项式相加\n    void Print();\nprivate:\n    Node *first;//一元多项式单链表的头指针\n};\n\nPolynomial::Polynomial() {\n    Node *r=nullptr,*s=nullptr;\n    int coef,exp;\n    first=new Node;//申请头结点\n    r=first;//尾插法建立单链表\n    cout<<\"请输入系数和指数\";\n    cin>>coef>>exp;\n    while (coef!=0) {//循环结束的条件是输入系数为0\n        s=new Node;\n        s->coef=coef;s->exp=exp;\n        r->next=s;r=s;//将结点s插入单链表的尾部\n        cout<<\"请输入系数和指数\";\n        cin>>coef>>exp;\n    }\n    r->next=nullptr;\n    cout<<\"\\n\\n\";\n}\nPolynomial::Polynomial(const Polynomial &B) {\n    first=B.first;\n}\nPolynomial::~Polynomial() {\n\n}\nPolynomial Polynomial::operator+(Polynomial &B) {\n    Node *pre=first,*p=pre->next;//工作指针pre和p初始化\n    Node *qre=B.first,*q=qre->next;//工作指针qre和q初始化\n    Node *qtemp=nullptr;\n    while (p!=nullptr && q!=nullptr) {\n        if(p->exp < q->exp) {//第1种情况\n            pre=p;p=p->next;\n        }\n        else if(p->exp > q->exp) {//第2种情况\n            qtemp=q->next;\n            pre->next=q;//将结点q插入到结点p之前\n            q->next=p;\n            pre=q;\n            q=qtemp;\n            qre->next=q;\n        }\n        else {//第3种情况\n            p->coef=p->coef+q->coef;\n            if(p->coef==0) {//系数相加为0,则删除结点p\n                pre->next=p->next;\n                delete p;\n                p=pre->next;\n            }\n            else {\n                pre=p;\n                p=p->next;\n            }\n            qre->next=q->next;//第3种情况都要删除结点q\n            delete q;\n            q=qre->next;\n        }\n    }\n    if(q!=nullptr) {\n        pre->next=q;//将结点q链接到第一个单链表的后面\n    }\n    return *this;\n}\n\nvoid Polynomial::Print() {\n    Node *p=first->next;\n    if(p!=nullptr) {//输出第一项\n        cout<<p->coef<<\"x^\"<<p->exp;\n    }\n    p=p->next;\n    while (p!=nullptr) {\n        if(p->coef>0) {\n            cout<<\"+\"<<p->coef<<\"x^\"<<p->exp;\n        }\n        else {\n            cout<<p->coef<<\"x^\"<<p->exp;\n        }\n        p=p->next;\n    }\n    cout<<\"\\n\";\n}\n\nint main() {\n    Polynomial A{},B{};\n    A.Print();\n    B.Print();\n    A=A+B;//运算符重载，对象赋值调用拷贝构造函数\n    cout<<\"结果是：\";\n    A.Print();\n    return 0;\n}\n```\n\n\n\n```\n请输入系数和指数7 0\n请输入系数和指数12 3\n请输入系数和指数-2 8\n请输入系数和指数5 12\n请输入系数和指数0 0\n\n\n请输入系数和指数4 1\n请输入系数和指数6 3\n请输入系数和指数2 8\n请输入系数和指数5 20\n请输入系数和指数7 28\n请输入系数和指数0 0\n\n\n7x^0+12x^3-2x^8+5x^12\n4x^1+6x^3+2x^8+5x^20+7x^28\n结果是：7x^0+4x^1+18x^3+5x^12+5x^20+7x^28\n\n进程已结束，退出代码为 0\n```\n\n\n\n## 思想火花\n\n **实验问题：**\n\n  将一个具有n个元素的数组向左循环移动i个位置。\n\n> [!NOTE]\n>\n> 如图1 数组元素循环左移1位：\n>\n> ![数组元素循环左移1位](img\\1485495-20190604181312769-273893486.png)\n>\n> 将一个具有n个元素的数组向左循环移动i个位置，**意味着将数组的前i个元素移动到数组的末尾，而原数组中的其余元素则相应地向左移动**\n\n 有许多应用程序会调用这个问题的算法，例如在文本编辑器中移动行的操作，磁盘整理时交换两个不同大小的相邻内存块等。所以，这个问题的算法要求有较高的时间和空间性能。 \n\n**基本要求：**\n\n  ⑴在原数组中实现循环右移，不另外申请空间；\n\n  ⑵时间性能尽可能好；\n\n   ⑶分析算法的时间复杂度。\n\n 要在不另申请空间的情况下，保证算法的时间性能尽可能好，如果先设计一个函数将数组向左移动一位，然后再调用该算法i次，是一些人通常想到的方法，但显然这个算法的时间性能不是最好的。要在有限的资源中解决这个问题，似乎比较困难，是否存在这种既不另申请存储空间，又能够达到最好时间性能的完美算法呢。\n\n  **求解步骤：**\n\n1）可以通过下面的方法解决这个问题：先将数组中的前i个元素存放在一个临时数组中，再将余下的n-i个元素左移i个位置， 最后将前i个元素从临时数组复制回原数组中后面的位置。但是这个算法使用了i个额外的存储单元，使得空间性能降低。\n\n2）如上所述，先设计一个函数将数组向左循环移动一个位置，然后再调用该算法i次， 显然，这个算法的时间性能不好。 \n\n 3）现在我们换一个角度看这个问题： 将这个问题看作是把数组ab转换成数组ba（a代表数组的前i个元素，b代表数组中余下的n-i个元素）， 先将a逆置得到ar b，再将b逆置得到ar br，最后将整个ar br逆置得到(ar br)r=ba。\n> [!NOTE]\n>\n> **数组元素逆置是指将数组中的元素按照相反的顺序重新排列，即第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，以此类推，直到所有元素都逆序排列完毕**。\n\n设Reverse函数执行将数组元素逆置的操作， 对abcdefgh向左循环移动3个位置的过程如下：\n```\nReverse(0, i-1); //得到cbadefgh(逆置abc)\nReverse(i, n-1); //得到cbahgfed(逆置defgh)\nReverse(0, n-1); //得到defghabc(逆置cbahgfed)\n```\n\n其原理可以用一个简单的游戏来理解：将两手的掌心对着自己，左手在右手上面， 可以实现将一个具有10 个元素的数组向左循环移动5位，如图所示。\n\n![](img\\1358339139_6806.jpg)\n\n```c++\n#include <iostream>\nusing namespace std;\nvoid reverseArr(int A[],int start,int rear){\n    for(int i=start,j=rear;i<j;i++,j--) {\n        int t=A[i];\n        A[i]=A[j];\n        A[j]=t;\n    }\n}\nvoid leftCir(int A[],int n,int k){\n    if(k<=0 || k>=n)\n        cout<<\"ERROR\"<<endl;\n    else{\n        reverseArr(A,0,k-1);\n        reverseArr(A,k,n-1);\n        reverseArr(A,0,n-1);\n    }\n}\nvoid show(int A[],int n){\n    for(int i=0;i<n;++i)\n        cout<<A[i]<<\" \";\n    cout<<endl;\n}\nint main()\n{\n    int n,p;\n    cin>>n>>p;\n    int a[n];\n    for(int i=0;i<n;++i)\n        cin>>a[i];\n    leftCir(a,n,p);\n    show(a,n);\n    return 0;\n}\n```\n\n该算法在时间和空间上都很有效，并且是这么简短和简单，想出错都很难。 Brian Kernighan在Software Tools in Pascal中使用了这个算法在文本编辑器中移动各行。\n\n[Software tools in Pascal by Brian W. Kernighan | 开放图书馆 (openlibrary.org)](https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal)\n\n> Brian Kernighan 在他的著作 *Software Tools in Pascal* 中，讨论了一个将 n 个元素的数组向左循环移动 i 个位置的算法。原文如下：\n>\n> \"To rotate an array left by i positions, reverse the first i elements, then reverse the remaining n-i elements, and finally reverse the entire array.\"\n>\n> 翻译过来大致是：\n>\n> “要将一个数组向左循环移动 i 个位置，首先反转数组的前 i 个元素，然后反转剩下的 n-i 个元素，最后反转整个数组。”\n>\n> 这种方法基于三个步骤的反转操作，可以高效地完成数组的左循环移动。\n\n作为一个规律，一个好的算法是反复努力和重新修正的结果，即使足够幸运地得到了一个貌似完美的算法思想， 我们也应该尝试着改进它。 \n\n## 习题\n\n\n\n# 第三章\n\n## 栈\n\n栈是限定仅在表的一段进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈\n\n> [!NOTE]\n>\n> 插入元素——入栈、进栈、压栈\n>\n> 删除元素——出栈、弹栈\n\n栈中元素除了具有线性关系外，还具有***==后进先出==***的特性\n\n栈的顺序存储结构称为顺序栈，本质上是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底\n\n通常把数组中下标为0的一段作为栈底，同时附设变量top指示栈顶元素在数组中的位置\n\n设存储栈的数组长度为StackSize，则栈空时栈顶位置top=-1；栈满时栈顶位置top=StackSize-1\n\n> [!TIP]\n>\n> 在有些教程中，将top指向栈中第一个空闲位置，如果这样的话，空栈应该表示为top=0\n\n入栈时，栈顶位置top加1；出栈时，栈顶位置top减1\n\n### 顺序栈的实现\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int StackSize=10;//\ntemplate<typename DataType>\nclass SeqStack {\npublic:\n    SeqStack();//初始化一个空栈\n    ~SeqStack();//析构函数\n    void Push(DataType x);//入栈操作，将元素x入栈\n    DataType Pop();//出栈操作，将栈顶元素弹出\n    DataType GetTop();//取栈顶元素(并不删除)\n    int Empty();//判断栈是否为空\nprivate:\n    DataType data[StackSize];\n    int top;//栈顶元素在数组中的下标\n};\ntemplate<typename DataType>\nSeqStack<DataType>::SeqStack() {\n    top=-1;\n}\ntemplate<typename DataType>\nSeqStack<DataType>::~SeqStack() {\n\n}\ntemplate<typename DataType>\nvoid SeqStack<DataType>::Push(DataType x) {\n    if(top==StackSize-1)throw\"上溢\";\n    data[++top]=x;\n    /*即:\n    top++;\n    s[top] = x;\n    */\n}\ntemplate<typename DataType>\nDataType SeqStack<DataType>::Pop() {\n    DataType x;\n    if(top==-1)throw\"下溢\";\n    x=data[top--];\n    /*即:\n    x=data[top];\n    top--;\n    */\n    return x;\n}\ntemplate<typename DataType>\nDataType SeqStack<DataType>::GetTop() {\n    return data[top];\n}\ntemplate<typename DataType>\nint SeqStack<DataType>::Empty() {\n    if(top==-1)return 1;\n    else return 0;\n}\n```\n\n```c++\nint main() {\n    int x;\n    SeqStack<int> S{};\n    cout<<\"对15和10入栈\";\n    S.Push(15);S.Push(10);\n    cout<<\"当前栈顶元素为:\"<<S.GetTop()<<endl;\n    try {\n        x=S.Pop();\n        cout<<x<<\"出栈\"<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入待入栈元素\";\n        cin>>x;\n        S.Push(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(S.Empty()==1) {\n        cout<<\"栈为空\"<<endl;\n    }\n    else {\n        cout<<\"栈非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 栈的链接存储结构及实现\n\n栈的链接存储结构称为链栈，通常用单链表表示，其节点结构与单链表的结点结构相同\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n因为只能在栈顶执行入栈(插入)和出栈(删除)操作，所以以单链表的头部做栈顶是最方便的，而且没有必要像单链表那样为了运算方便附加头结点\n\n> [!TIP]\n>\n> 在单链表中，如果我们将头部用作栈顶（top），那么入栈和出栈操作都会非常高效，这是因为单链表的特性允许我们在头部进行 O(1) 时间复杂度的操作。\n>\n> 具体来说，有以下几点原因：\n>\n> 1. **插入操作**：当我们需要向栈中添加一个元素时（即入栈操作），我们只需要创建一个新的节点，并让它指向当前的头部（即当前栈顶），然后更新头部指针指向这个新节点。这样的操作不需要遍历整个链表来找到插入位置，因此时间复杂度为 O(1)。\n> 2. **删除操作**：当我们需要从栈中移除一个元素时（即出栈操作），我们只需改变头部指针，让它指向原来的头部所指向的下一个节点，并释放原来的头部节点即可。这也同样是一个 O(1) 的操作。\n> 3. **访问栈顶元素**：由于头部就是栈顶，访问栈顶元素也仅需要返回头部指针指向的节点的数据，这也是 O(1) 的操作。\n>\n> 关于是否需要附加头结点（dummy head）的问题，通常情况下，如果单链表只用于实现栈的功能，并且不需要支持其他额外操作（比如查找特定元素等），那么就没有必要设置一个额外的头结点。因为所有的操作都在头部进行，直接将头部视为栈顶已经足够高效了。\n\n时间复杂度 —— O(1)\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\ntemplate<typename DataType>\nclass LinkStack {\npublic:\n    LinkStack();\n    ~LinkStack();\n    void Push(DataType x);//入栈操作，将元素x入栈\n    DataType Pop();//出栈操作，将栈顶元素弹出\n    DataType GetTop();//取栈顶元素(并不删除)\n    int Empty();//判断栈是否为空\nprivate:\n    Node<DataType> *top;//栈顶指针即链栈的头指针\n};\ntemplate<typename DataType>\nLinkStack<DataType>::LinkStack() {\n    top=nullptr;\n}\ntemplate<typename DataType>\nLinkStack<DataType>::~LinkStack() {\n\n}\ntemplate<typename DataType>\nvoid LinkStack<DataType>::Push(DataType x) {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->data=x;\n    s->next=top;\n    top=s;\n}\ntemplate<typename DataType>\nDataType LinkStack<DataType>::Pop() {\n    Node<DataType> *p=nullptr;\n    DataType x;\n    if(top==nullptr)throw\"下溢\";\n    x=top->data;\n    p=top;\n    top=top->next;\n    delete p;\n    return x;\n}\ntemplate<typename DataType>\nDataType LinkStack<DataType>::GetTop() {\n    return top->data;\n}\ntemplate<typename DataType>\nint LinkStack<DataType>::Empty() {\n    if(top==nullptr)return 1;\n    else return 0;\n}\n```\n\n```c++\nint main() {\n    int x;\n    LinkStack<int> S{};\n    cout<<\"对15和10入栈\";\n    S.Push(15);S.Push(10);\n    cout<<\"当前栈顶元素为:\"<<S.GetTop()<<endl;\n    try {\n        x=S.Pop();\n        cout<<x<<\"出栈\"<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入待入栈元素\";\n        cin>>x;\n        S.Push(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(S.Empty()==1) {\n        cout<<\"栈为空\"<<endl;\n    }\n    else {\n        cout<<\"栈非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 顺序栈和链栈的比较\n\n作为一般规律，当栈的使用过程中元素变化较大时，应该采用链栈，反之，应使用顺序栈\n\n### STL中的栈\n\nC++ Stack(堆栈) 是一个容器类的改编，为程序员提供了堆栈的全部功能，--也就是说实现了一个先进后出(FILO)的数据结构。\n\n栈stack的头文件为:\n\n#include <stack>\n\n#### c++ stl栈stack的成员函数介绍\n\n操作   比较和分配堆栈\n\nempty()堆栈为空则返回真\n\npop()移除栈顶元素(删除)\n\npush()在栈顶增加元素(增加)\n\nsize() 返回栈中元素数目\n\ntop() 返回栈顶元素，不删除(获取)\n\n##### 1.什么是[stack](https://so.csdn.net/so/search?q=stack&spm=1001.2101.3001.7020)\n\n**1. stack**是一种**容器适配器**，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。**(后进先出)**\n\n**2. stack**是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。\n\n**3. stack**的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下\n\n**操作：**\n\n> **empty：判空操作**\n>\n> **back：获取尾部元素操作**\n>\n> **push_back：尾部插入元素操作**\n>\n> **pop_back：尾部删除元素操作**\n\n**4.** 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/667251d46c039b39d506132e9fa06b51.png)\n\n##### 2.容器适配器\n\n**容器适配器（Container Adapters）是 C++ 标准库提供的一种数据结构，它们基于现有的容器类型，提供了特定的接口和功能，以便更方便地实现某些特定的数据结构和算法**。容器适配器本质上是对底层容器的封装，提供了不同的数据访问方式，使它们适用于特定的用途。 \n\n**标准库中提供了三种常用的容器适配器：**\n\n> ***\\*stack：栈适配器\\**，基于底层容器提供了栈数据结构的操作，如压入（push）、弹出（pop）、查看栈顶元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。**\n>\n>\n> ***\\*queue：队列适配器\\**，基于底层容器提供了队列数据结构的操作，如入队（push）、出队（pop）、查看队首元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。**\n>\n>\n> ***\\*priority_queue：优先队列适配器\\**，基于底层容器提供了优先队列数据结构的操作，支持在插入元素时根据优先级进行排序。默认底层容器是 vector，但也可以使用其他支持随机访问和插入操作的容器。**\n\n##### 3.stack的使用\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/8591236db69c7870d8bd8f1c680badcb.png)\n\n这些是C++[标准库](https://so.csdn.net/so/search?q=标准库&spm=1001.2101.3001.7020)中stack类的构造函数声明。stack是一个适配器容器，它可以使用不同的底层容器来实现栈的功能。这些构造函数声明提供了不同的方式来创建和初始化stack对象，可以根据需求选择合适的构造函数。 \n\n> **stack的Construct中除了构造函数，其他什么都没有，它连拷贝构造、析构都没有。这个也跟它是容器适配器有关系，因为它的成员都是自定义类型，编译器默认生成的就够用。**\n>\n> \n>\n> **stack是容器适配器以后，就开始不支持迭代器了。容器支持迭代器，容器适配器不支持迭代器。**\n>\n> \n>\n> **栈随便去遍历反而是不好的，因为要保证后进先出的性质。**\n>\n> \n>\n> **所以取数据得用top，想取下一个数据就得先pop。**\n\n##### [top](https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020)\n\nreference top(); 和 const_reference top() const; 是 C++ 标准库中 std::stack 类的成员函数之一。它们用于获取栈顶元素的引用。\n\nreference top();：返回栈顶元素的引用。如果需要修改栈顶元素，可以使用这个版本。\n\n```cpp\n#include <iostream>\n#include <stack>\n \n\t\tstack<int> m;\n \n\t\tm.push(42);\n\t\tm.push(15);\n \n\t\t// 使用 top() 获取栈顶元素\n\t\tint topElement = m.top();\n\t\tcout << \"Top element: \" << topElement << endl;\n \n\t\t// 修改栈顶元素\n\t\tm.top() = 99;\n\t\tcout << \"New top element: \" << m.top() << endl;\n \n\t\treturn 0;\n\t\n \n}\n```\n\n ![img](https://i-blog.csdnimg.cn/blog_migrate/af9dbb720d78efb612f5c4bb64dbb6ec.png)\n\n后进先出，15先出，然后修改为99，最后出99\n\n##### push\n\n**是 C++ 标准库中 `std::stack` 类的成员函数之一。它们用于将一个新的元素压入栈中。**\n\n**这两个版本的 push 函数允许你在栈顶添加新的元素。如果需要保持传入值的不变性，可以使用第一个版本；如果你想利用移动语义来避免不必要的复制，可以使用第二个版本。**\n\n```cpp\n#include<iostream>\n#include<stack>\nusing namespace std;\n \n \n\tint main() \n\t{\n\t\tstack<int> m;\n \n\t\tm.push(10); // 使用右值，将 10 压入栈中\n\t\tm.push(19);\n \n\t\tint newElement = 99;\n\t\tm.push(newElement); // 使用常量引用，将 newElement 压入栈中\n \n\t\tcout << \"Stack size: \" << m.size() << endl;\n \n\t\twhile (!m.empty())  // 遍历不能用迭代器，容器适配器不支持迭代器\n\t\t{\n\t\t\tcout << m.top() << \" \"; // 输出栈顶元素\n\t\t\tm.pop(); // 弹出栈顶元素\n\t\t}\n \n\t\treturn 0;\n\t}\n```\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/fe6f4bb4063818fce45d827a5bc7661c.png)\n\n#####  pop\n\n**`void pop();` 是 C++ 标准库中 `stack` 类的成员函数之一。它用于将栈顶元素弹出（删除）。**\n\n**这个函数没有返回值，它只是从栈中移除栈顶元素。在调用 `pop()` 函数之前，需要确保栈不为空，否则会导致未定义行为。**\n\n```cpp\n\tint main() \n\t{\n\t\tstack<int> m;\n \n\t\tm.push(10); // 使用右值，将 10 压入栈中\n\t\tm.push(19);\n\t\tm.push(29);\n \n\t\tcout << \"Stack size: \" << m.size() << endl;\n \n\t\tm.pop();\n \n\t\tcout << \"Stack new size: \" << m.size() << endl;\n \n\t\treturn 0;\n\t}\n```\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/84b16ae75feec2ff17399e8a5edab7b8.png)\n\n##### **公共成员函数**：\n\n> push(const T& x)：将传入的元素值 x 添加到底层容器的末尾，实现了入栈操作。\n>\n>\n> pop()：从底层容器的末尾删除一个元素，实现了出栈操作。\n>\n>\n> T& top() 和 const T& top() const：分别返回底层容器的末尾元素的引用（允许修改）和常量引用（只读），实现了查看栈顶元素操作。\n>\n>\n> bool empty() const：返回底层容器是否为空。\n>\n>\n> size_t size() const：返回底层容器中元素的数量。\n>\n>\n> 私有成员变量 _con：这是一个模板类的私有成员变量，用于存储实际的栈元素。其类型是根据模板参数 Container 确定的，在实例化时会被替换为具体的容器类型。\n\n### 实例(o2r函数，用于将整数n转换为基数r的字符串表示)\n\n```c++\n#include <iostream>\n#include <stack>\nusing namespace std;\n\n// 定义o2r函数，用于将整数n转换为基数r的字符串表示\nvoid o2r(int n, int r) {\n    // 使用栈来存储转换过程中的每一位数字\n    stack<char> s;\n    // base数组用于将十进制数转换为r进制的字符表示\n    char base[] = \"0123456789ABCDEF\";\n    \n    // 当n不为0时，继续转换过程\n    while (n) {\n        // 取n除以r的余数，得到当前位的值，并将其加入栈中\n        s.push(base[n % r]);\n        // 更新n为n除以r的商，继续下一位的计算\n        n = n / r;\n    }\n    \n    // 当栈不为空时，依次取出栈中的元素并输出，完成r进制数的构建\n    while (!s.empty()) {\n        cout << s.top();\n        // 取出栈顶元素后，将其从栈中移除\n        s.pop();\n    }\n    \n    // 在输出后换行，以便于阅读\n    cout << endl;\n}\n\nint main() {\n    // 示例：将10进制的255转换为16进制\n    cout << \"10进制的255转换为16进制：\" << endl;\n    o2r(255, 16); // 输出: FF\n\n    // 示例：将10进制的100转换为2进制\n    cout << \"10进制的100转换为2进制：\" << endl;\n    o2r(100, 2); // 输出: 1100100\n\n    // 示例：将10进制的1234转换为8进制\n    cout << \"10进制的1234转换为8进制：\" << endl;\n    o2r(1234, 8); // 输出: 2322\n\n    return 0;\n}\n```\n\n## 队列\n\n队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入(入队、进队)的一端称为队尾，允许删除(出队)的一端称为队头。\n\n队列中的元素除了具有线性关系外，还具有==***先进先出***==的特性\n\n### 队列的顺序存储结构及实现\n\n队列的顺序存储结构称为顺序队列。假设队列有n个元素，顺序队列把队列的所有元素存储在数组的前n个单元。如果把队头元素放在数组中下标为0的一端，则入队操作相当于追加，不需要移动元素，其时间性能为O(1)，但是出队操作的时间性能为O(n)，因为要保证剩下的n-1个元素仍然存储在数组的前n-1个单元，所有元素都要向前移动一个位置。\n\n如果放宽队列的所有元素必须存储在数组的前n个单元这一条件，就可以得到一种更为有效的存储方式。此时入队和出队操作的时间性能都是O(1)，因为没有移动任何元素。需要设置队头、队尾两个位置变量front和rear，入队时rear加1，出队时front加1，并且约定：front指向队头元素的前一个位置，rear指向队尾元素的位置。\n\n> [!NOTE]\n>\n> 这样约定的目的是方便运算，例如rear-front等于队列的长度。\n\n### 循环队列\n\n在顺序队列中，随着队列的插入和删除操作，整个队列向数组的高端移过去，从而产生了队列的“单向移动性”。当元素被插入到数组中下标最大的位置之后，数组空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫做“假溢出”\n\n解决假溢出的方法是将存储队列的数组看成是头尾相接的循环结构，这可以通过取模操作来实现，设存储队列的数组长度为QueueSize，操作语句为rear=(rear+1)%QueueSize\n\n队列的这种头尾相接的顺序存储结构称为循环队列。\n\n队空的条件是front=rear\n\n队满的条件是(rear+1)%QueueSize=front\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int QueueSize=100;\ntemplate <typename DataType>\nclass CirQueue {\npublic:\n    CirQueue();//构造函数，初始化空队列\n    ~CirQueue();//析构函数\n    void EnQueue(DataType x);//入队\n    DataType DeQueue();//出队\n    DataType GetHead();//取队头元素\n    int Empty();//判断队列是否为空\nprivate:\n    DataType data[QueueSize];//存放队列元素的数组\n    int front,rear;//游标，队头和队尾指针\n};\ntemplate<typename DataType>\nCirQueue<DataType>::CirQueue() {\n    rear=front=QueueSize-1;\n}\ntemplate<typename DataType>\nCirQueue<DataType>::~CirQueue() {\n\n}\ntemplate<typename DataType>\nvoid CirQueue<DataType>::EnQueue(DataType x) {\n    if((rear+1)%QueueSize==front)throw\"上溢\";\n    rear=(rear+1)%QueueSize;//队尾指针在循环意义下加1\n    data[rear]=x;//在队尾处插入元素\n}\ntemplate<typename DataType>\nDataType CirQueue<DataType>::DeQueue() {\n    if(rear==front)throw\"下溢\";\n    front=(front+1)%QueueSize;//队头在循环意义下加1\n    return data[front];//返回出队前的队头元素\n}\ntemplate<typename DataType>\nDataType CirQueue<DataType>::GetHead() {\n    if(rear==front)throw\"下溢\";\n    return data[(front+1)%QueueSize];\n}\ntemplate<typename DataType>\nint CirQueue<DataType>::Empty() {\n    if (rear==front) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n```\n\n\n\n```c++\nint main() {\n    int x;\n    CirQueue<int> Q{};\n    Q.EnQueue(5);Q.EnQueue(8);\n    cout<<\"当前队头元素为：\"<<Q.GetHead()<<endl;\n    try {\n        x=Q.DeQueue();\n        cout<<\"执行一次出队操作，出队元素是：\"<<x<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入入队元素:\";\n        cin>>x;\n        Q.EnQueue(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(Q.Empty()==1) {\n        cout<<\"队列为空\"<<endl;\n    }\n    else {\n        cout<<\"队列非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 队列的链存储结构及实现\n\n队列的链接存储结构称为链队列，通常用单链表表示，其结点结构与单链表的结点结构相同\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n为了使空队列和非空队列的操作一致，链队列也加上头结点；为了操作上的方便，设置队头指针指向链队列的头结点，队尾指针指向终端结点\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\ntemplate <typename DataType>\nclass LinkQueue {\npublic:\n    LinkQueue();//构造函数，初始化空队列\n    ~LinkQueue();//析构函数\n    void EnQueue(DataType x);//入队\n    DataType DeQueue();//出队\n    DataType GetHead();//取队头元素\n    int Empty();//判断队列是否为空\nprivate:\n    Node<DataType> *front,*rear;//队头和队尾指针\n};\n\ntemplate<typename DataType>\nLinkQueue<DataType>::LinkQueue() {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->next=nullptr;\n    front=rear=s;//将队头指针和队尾指针都指向头结点s\n}\ntemplate<typename DataType>\nLinkQueue<DataType>::~LinkQueue() {\n\n}\ntemplate<typename DataType>\nvoid LinkQueue<DataType>::EnQueue(DataType x) {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->data=x;s->next=nullptr;\n    rear->next=s;\n    rear=s;\n}\ntemplate<typename DataType>\nDataType LinkQueue<DataType>::DeQueue() {\n    DataType x;\n    Node<DataType> *p=nullptr;\n    if(rear==front)throw\"下溢\";\n    p=front->next;x=p->data;\n    front->next=p->next;\n    if(p->next==nullptr){//出队前队列长度为1\n        rear=front;\n    }\n    delete p;\n    return x;\n}\ntemplate<typename DataType>\nDataType LinkQueue<DataType>::GetHead() {\n    return front->next->data;\n}\ntemplate<typename DataType>\nint LinkQueue<DataType>::Empty() {\n    if(front==rear) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n```\n\n```c++\nint main() {\n    int x;\n    LinkQueue<int> Q{};\n    Q.EnQueue(5);Q.EnQueue(8);\n    cout<<\"当前队头元素为：\"<<Q.GetHead()<<endl;\n    try {\n        x=Q.DeQueue();\n        cout<<\"执行一次出队操作，出队元素是：\"<<x<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入入队元素:\";\n        cin>>x;\n        Q.EnQueue(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(Q.Empty()==1) {\n        cout<<\"队列为空\"<<endl;\n    }\n    else {\n        cout<<\"队列非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 循环队列和链队列的比较\n\n循环队列和链队列基本操作的时间复杂度均为O(1)，因此可以比较的只有空间性能。作为一般规律，当队列中元素个数变化较大时，应采用链队列，反之，应该采用循环队列，如果确定不会发生假溢出，也可以采用顺序队列\n\n## 扩展与提高\n\n### 两栈共享空间\n\n在一个程序中，如果同时使用具有相同数据类型的两个顺序栈，最直接的方法是为每个栈开辟一个数组空间，这样做的结果可能出现一个栈的空间已被占满而无法再进行插入操作，同时另一个栈的空间仍有大量剩余而没有得到利用的情况，从而造成存储空间的浪费。\n\n可以充分利用顺序栈单向延伸的特性，使用一个数组来存储两个栈，让一个栈的栈底位于该数组的始端，另一个栈的栈底位于该数组的末端，每个栈从各自的端点向中间延伸。\n\n其中，topl 和 top2分别为栈1 和栈2 的栈顶位置，StackSize 为整个数组空间的大小，栈1的底位于下标为。的一端；栈2的底位于下标为 StackSize一1 的一端。\n\n在两栈共享空间中，由于两个栈相向增长，浪费的数组空间就会减少，同时发生上溢的概率也会减少。**但是，只有当两个栈的空间需求有相反的关系时，这种方法才会奏效，也就是说，最好一个栈增长时另一个栈缩短。**下面给出两栈共享空间的类定义：\n\n```c++\nconst int StackSize=100;\ntemplate <typename DataType>\nclass BothStack {\npublic:\n    BothStack();//构造函数，将两个栈分别初始化\n    ~BothStack();\n    void Push(int i,DataType x);//入栈操作，将元素x压入栈i\n    DataType Pop(int i);//出栈操作，对栈i执行出栈操作\n    DataType GetTop(int i);//取栈i的栈顶元素\n    int Empty(int i);//判断栈i是否为空栈\nprivate:\n    DataType data[StackSize];//存放两个栈的数组\n    int top1,top2;//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标\n};\n```\n\n设整型变量i只取1和2两个值。当i=1时，表示对栈1操作；当i=2时，表示对栈2操作\n\n下面讨论两栈共享空间的入栈和出栈操作：\n\n#### 入栈\n\n当存储栈的数组中没用空闲单元时为栈满，此时栈1的栈顶元素和栈2的栈顶元素位于数组中的相邻位置，即top1=top2-1。另外，当新元素插入栈2时，栈顶位置top2不是加一而是减一\n\n```c++\ntemplate<typename DataType>\nvoid BothStack<DataType>::Push(int i, DataType x) {\n    if(top1==top2-1)throw\"上溢\";\n    if(i==1)data[++top1]=x;\n    /*即:\n    top1++;\n    data[top1] = x;\n    */\n    if(i==2)data[--top2]=x;\n    /*即:\n    top2--;\n    data[top2] = x;\n    */\n}\n```\n\n#### 出栈\n\n当top1=-1时栈1为空，当top2=StackSize时栈2为空。另外，当从栈2删除元素时，top2不是减一而是加一\n\n```c++\ntemplate<typename DataType>\nDataType BothStack<DataType>::Pop(int i) {\n    if(i==1) {\n        if(top1==-1)throw\"下溢\";\n        return data[top1--];\n    }\n    if(i==2) {\n        if(top2==StackSize)throw\"下溢\";\n        return data[top2++];\n    }\n}\n```\n\n#### 完整代码\n\n```c++\n#include<iostream>\nusing namespace std;\nconst int StackSize=100;\ntemplate <typename DataType>\nclass BothStack {\npublic:\n    BothStack();//构造函数，将两个栈分别初始化\n    ~BothStack();\n    void Push(int i,DataType x);//入栈操作，将元素x压入栈i\n    DataType Pop(int i);//出栈操作，对栈i执行出栈操作\n    DataType GetTop(int i);//取栈i的栈顶元素\n    int Empty(int i);//判断栈i是否为空栈\nprivate:\n    DataType data[StackSize];//存放两个栈的数组\n    int top1,top2;//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标\n};\ntemplate<typename DataType>\nvoid BothStack<DataType>::Push(int i, DataType x) {\n    if(top1==top2-1)throw\"上溢\";\n    if(i==1)data[++top1]=x;\n    /*即:\n    top1++;\n    data[top1] = x;\n    */\n    if(i==2)data[--top2]=x;\n    /*即:\n    top2--;\n    data[top2] = x;\n    */\n}\ntemplate<typename DataType>\nDataType BothStack<DataType>::Pop(int i) {\n    if(i==1) {\n        if(top1==-1)throw\"下溢\";\n        return data[top1--];\n    }\n    if(i==2) {\n        if(top2==StackSize)throw\"下溢\";\n        return data[top2++];\n    }\n}\n```\n\n### 双端队列\n\n#### 定义\n\n双端队列是队列的扩展，\n\n如果允许在队列的两端进行插人和删除操作，则称为双端队列；\n\n如果允许在两端插入但只允许在一端删除，则称为二进一出队列；\n\n如果只允许在一端插入但允许在两端删除，则称为一进二出队列。\n\n双端队列和普通队列一样，具有人队、出队、取队头元素等基本操作，不同的是必须指明操作的位置，其抽象数据类型定义如下：\n\n```ADT\nADT DoubleQueue\nDataModel\n\t相邻元素具有前驱和后继关系，允许在队列的两端进行插入和删除操作\nOperation\n\tInitQueue\n\t\t输入：无\n\t\t功能：初始化双端队列\n\t\t输出：一个空的双端队列\n\tDestroyQueue\n\t\t输人：无\n\t\t功能：队列的销毁\n\t\t输出：释放双端队列占用的存储空间\n\tEnQueueHead\n\t\t输入：元素值x\n\t\t功能：入队操作，将元素x插人到双端队列的队头输出：如果插入成功，双端队列的队头增加了一个元素\n\tEnQueueTail\n\t\t输人：元素值x\n\t\t功能：入队操作，将元素×插入到双端队列的队尾输出：如果插入成功，双端队列的队尾增加了一个元系\n\tDeQueueHead\n\t\t输入：无\n\t\t功能：出队操作，删除双端队列的队头元素\n\t\t输出：如果删除成功，将队头元素出队\n\tDeQueueTail\n\t\t输人：无\n\t\t功能：出队操作，删除双端队列的队尾元素输出：如果删除成功，将队尾元素出队\n\tGetHead\n\t\t输人：无\n\t\t功能：读取双端队列的队头元素\n\t\t输出：若双端队列不空，返回队头元素\n\tGetTail\n\t\t输人：无\n\t\t功能：读取双端队列的队尾元素\n\t\t输出：若双端队列不空，返回队尾元素\n\tEmpty\n\t\t输人：无\n\t\t功能：判空操作，判断双端队列是否为空输出：如果双端队列为空，返回1，否则返回0。\nendADT\n```\n\n双端队列可以采用循环队列的存储方式，基本算法可以在循环队列的基础上修改而成。不同的是，在队头入队时，先将新元素插人到 front处，再把队头位置 front 在循环意义下减1；在队尾出队时，先将 rear 处的队尾元素暂存，再把队尾位置 rear 在循环意义下减1。\n\n#### 完整代码\n\n```C++\n#include <iostream>\n#include <stdexcept>\n\n// 定义链表节点\nstruct Node {\n\tint data;\n\tNode* prev;\n\tNode* next;\n\t\n\tNode(int val) : data(val), prev(nullptr), next(nullptr) {}\n};\n\n// 双端队列类\nclass DoubleQueue {\nprivate:\n\tNode* head;\n\tNode* tail;\n\t\npublic:\n\t// 构造函数\n\tDoubleQueue() : head(nullptr), tail(nullptr) {}\n\t\n\t// 析构函数\n\t~DoubleQueue() {\n\t\tDestroyQueue();\n\t}\n\t\n\t// 初始化双端队列\n\tvoid InitQueue() {\n\t\thead = nullptr;\n\t\ttail = nullptr;\n\t}\n\t\n\t// 销毁双端队列\n\tvoid DestroyQueue() {\n\t\twhile (head != nullptr) {\n\t\t\tNode* temp = head;\n\t\t\thead = head->next;\n\t\t\tdelete temp;\n\t\t}\n\t\ttail = nullptr;\n\t}\n\t\n\t// 在队头插入元素\n\tvoid EnQueueHead(int x) {\n\t\tNode* newNode = new Node(x);\n\t\tif (head == nullptr) {\n\t\t\thead = tail = newNode;\n\t\t} else {\n\t\t\tnewNode->next = head;\n\t\t\thead->prev = newNode;\n\t\t\thead = newNode;\n\t\t}\n\t}\n\t\n\t// 在队尾插入元素\n\tvoid EnQueueTail(int x) {\n\t\tNode* newNode = new Node(x);\n\t\tif (tail == nullptr) {\n\t\t\thead = tail = newNode;\n\t\t} else {\n\t\t\tnewNode->prev = tail;\n\t\t\ttail->next = newNode;\n\t\t\ttail = newNode;\n\t\t}\n\t}\n\t\n\t// 从队头删除元素\n\tbool DeQueueHead() {\n\t\tif (head == nullptr) return false;\n\t\tNode* temp = head;\n\t\thead = head->next;\n\t\tif (head != nullptr) {\n\t\t\thead->prev = nullptr;\n\t\t} else {\n\t\t\ttail = nullptr;\n\t\t}\n\t\tdelete temp;\n\t\treturn true;\n\t}\n\t\n\t// 从队尾删除元素\n\tbool DeQueueTail() {\n\t\tif (tail == nullptr) return false;\n\t\tNode* temp = tail;\n\t\ttail = tail->prev;\n\t\tif (tail != nullptr) {\n\t\t\ttail->next = nullptr;\n\t\t} else {\n\t\t\thead = nullptr;\n\t\t}\n\t\tdelete temp;\n\t\treturn true;\n\t}\n\t\n\t// 获取队头元素\n\tint GetHead() const {\n\t\tif (head == nullptr) throw std::out_of_range(\"Queue is empty\");\n\t\treturn head->data;\n\t}\n\t\n\t// 获取队尾元素\n\tint GetTail() const {\n\t\tif (tail == nullptr) throw std::out_of_range(\"Queue is empty\");\n\t\treturn tail->data;\n\t}\n\t\n\t// 判断双端队列是否为空\n\tbool Empty() const {\n\t\treturn head == nullptr;\n\t}\n};\n\nint main() {\n\tDoubleQueue dq;\n\t\n\t// 测试操作\n\tdq.EnQueueHead(1);\n\tdq.EnQueueTail(2);\n\tdq.EnQueueHead(3);\n\t\n\tstd::cout << \"Head: \" << dq.GetHead() << \", Tail: \" << dq.GetTail() << std::endl; // 应该输出 Head: 3, Tail: 2\n\t\n\tdq.DeQueueHead();\n\tstd::cout << \"After DeQueueHead, Head: \" << dq.GetHead() << std::endl; // 应该输出 Head: 1\n\t\n\tdq.DeQueueTail();\n\tstd::cout << \"After DeQueueTail, Tail: \" << dq.GetHead() << std::endl; // 应该输出 Tail: 1\n\t\n\tstd::cout << \"Is the queue empty? \" << (dq.Empty() ? \"Yes\" : \"No\") << std::endl; // 应该输出 No\n\t\n\tdq.DeQueueHead();\n\tstd::cout << \"Is the queue empty after all elements removed? \" << (dq.Empty() ? \"Yes\" : \"No\") << std::endl; // 应该输出 Yes\n\t\n\treturn 0;\n}\n```\n\n## 应用举例\n\n### 括号匹配问题\n\n```c++\n#include<iostream>\n#include <string>\nusing namespace std;\n\nclass Matcher {\npublic:\n    Matcher(string str);\n    ~Matcher();\n    int Match();\nprivate:\n    string str;\n};\nMatcher::Matcher(string str) {\n    this->str=str;\n}\nint Matcher::Match() {\n    char S[100];\n    int i,top=-1;\n    for(i=0;str[i]!='\\0';i++) {\n        if(str[i]==')') {\n            if(top>-1)top--;\n            else return -1;\n        }\n        else if(str[i]=='(') {\n            S[++top]=str[i];\n        }\n    }\n    if(top==-1) return 0;\n    else return 1;\n}\nMatcher::~Matcher() {\n\n}\n\n\nint main() {\n    string str;\n    cout<<\"请输入一个算数表达式\";\n    cin>>str;\n    Matcher M{str};\n    int k=M.Match();\n    if(k==0) {\n        cout<<\"正确匹配\\n\";\n    }\n    else if(k==1) {\n        cout<<\"多左括号\\n\";\n    }\n    else {\n        cout<<\"多右括号\\n\";\n    }\n    return 0;\n}\n```\n\n### 表达式求值\n\n表达式求值需要根据运算符的优先级来确定计算顺序。因此，在求值过程中需要保存优先级较低的运算符以及没有参与计算的运算对象，并将当前运算符与已经扫描过的、尚未计算的运算符进行比较，以确定哪个运算符以及哪两个运算对象参与计算。这需要两个栈来辅助完成：运算对象栈 OPND 和运算符栈 OPTR。\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Expression {\npublic:\n    Expression(string str);\n    ~Expression();\n    int Compute();\nprivate:\n    int Comp(char str1,char str2);\n    string str;\n};\nExpression::Expression(string str) {\n    this->str=str+\"#\";\n}\nExpression::~Expression() {\n\n}\nint Expression::Compute() {\n    char OPND[100],OPTR[100];\n    OPTR[0]='#';\n    int top1=-1,top2=0;\n    int i,k,x,y,z,op;\n    for(i=0;str[i]!='\\0';) {\n        if(str[i]>=48 && str[i]<=57) {\n            OPND[++top1]=str[i++]-48;\n        }\n        else {\n            k=Comp(str[i],OPTR[top2]);\n            if(k==1) {\n                OPTR[++top2]=str[i++];\n            }\n            else if(k==-1) {\n                y=OPND[top1--];\n                x=OPND[top1--];\n                op=OPTR[top2--];\n                switch (op) {\n                    case '+':z=x+y;break;\n                    case '-':z=x-y;break;\n                    case '*':z=x*y;break;\n                    case '/':z=x/y;break;\n                    default: break;\n                }\n                OPND[++top1]=z;\n            }\n            else {\n                top2--;\n                i++;\n            }\n        }\n    }\n    return OPND[top1];\n}\nint Expression::Comp(char str1, char str2) {\n    switch (str1) {\n        case '+':case '-':\n            if(str2=='(' || str2=='#') return 1;\n            else return -1;\n            break;\n        case '*':case '/':\n            if(str2=='*' || str2=='/') return -1;\n            else return 1;\n            break;\n        case '(':return -1;break;\n        case ')':\n            if(str2=='(') return 0;else return -1;\n            break;\n        case '#':\n            if(str2=='#') return 0;else return -1;\n            break;\n        default:\n            break;\n    }\n}\nint main() {\n    string str;\n    cout<<\"请输入一个表达式\"<<endl;\n    cin>>str;\n    Expression E{str};\n    int result=E.Compute();\n    cout<<\"表达式的值是\"<<result<<endl;\n    return 0;\n}\n```\n\n## 习题\n\n# 第四章\n\n## 字符串\n\n给定两个字符串S，T，在主串S中寻找子串T的过程称为模式匹配，T称为模式。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。\n\n### BF算法\n\nBF算法的基本思想是蛮力匹配，即从主串S的第一个字符开始和模式T的第一个字符进行比较。若相等，则继续比较两者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本趟匹配的开始位置；否则匹配失败，返回0.\n\n```c++\nint BF(char S[],char T[]){\n\tint start=0;\n\tint i=0,j=0;\n\twhile((S[i]!='\\0') && (T[i]!='\\0')){\n\t\tif(S[i]==T[i]){\n\t\t\ti++;j++;\n\t\t}\n\t\telse{\n\t\t\tstart++;\n\t\t\ti=start;j=0;\n\t\t}\n\t}\n\tif(T[j]=='\\0'){\n\t\treturn start+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n```\n\n最坏情况下的时间复杂度是O(n*m)（设主串S长度为n，模式T长度为m）\n\n### KMP算法\n\n【最浅显易懂的 KMP 算法讲解】 https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n【【天勤考研】KMP算法易懂版】 https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n【KMP算法之求next数组代码讲解】 https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n\n## 多维数组\n\n\n\n## 矩阵压缩存储\n","source":"_posts/DataStructures-FromConceptToCppImplementation.md","raw":"---\ntitle: 数据结构（cpp实现）\ndate: 2024-10-30 20:56:55\ntags: 数据结构\n---\n\n\n# 第一章\n\n## 七桥问题\n\n七桥问题是一个经典的图论问题，它是由数学家欧拉在18世纪提出的。问题的背景是哥尼斯堡（今俄罗斯的加里宁格勒）的一个地区，该地区被普雷格尔河分成四个区域，并由七座桥连接。问题是：是否有可能从某个区域出发，不重复地走过所有七座桥，并且回到起点。\n我们可以这样求解七桥问题：\n\n1. 首先，我们需要确定每个顶点（即每个城区）相关联的边数（即桥的数量）。\n2. 然后，我们根据以下规则进行判定：\n   - 如果所有顶点相关联的边数都是偶数，则存在欧拉回路。\n   - 如果有超过两个顶点相关联的边数是奇数，则不存在欧拉回路。\n   - 如果恰好有两个顶点相关联的边数是奇数，则不存在欧拉回路，但存在一条从这两个顶点之一出发的欧拉路径（不会回到起点）。\n   对于七桥问题，我们可以将四个区域视为四个顶点，七座桥视为连接这些顶点的边。通过计算每个顶点相关联的边数，我们可以得到以下结果：\n- 两个区域（顶点）各有三座桥相连，因此这两个区域相关联的边数是奇数。\n- 另外两个区域（顶点）各有两座桥相连，因此这两个区域相关联的边数是偶数。\n根据判定规则，因为有超过两个顶点相关联的边数是奇数（具体来说，有两个顶点），所以七桥问题中不存在欧拉回路。同时，也不存在从这两个顶点之一出发的欧拉路径，因为路径要求不重复地走过所有边，而这是不可能的。\n因此，结论是：在七桥问题中，不可能找到一条不重复地走过所有七座桥的路径，并且返回起点。\n\n```c++\n#include<iostream>\nusing namespace std;\nconst int MaxSize=4;\nclass EulerCircuit {\npublic:\n    EulerCircuit(int a[][MaxSize],int n);\n    int oddVertexNum();\nprivate:\n    int mat[MaxSize][MaxSize];\n    int vertexNum;\n};\nEulerCircuit::EulerCircuit(int a[][MaxSize],int n){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            mat[i][j]=a[i][j];\n        }\n    }\n    vertexNum=n;\n}\nint EulerCircuit::oddVertexNum(){\n    int count=0,i,j,degree;\n    for(i=0;i<vertexNum;i++){\n        degree=0;\n        for(j=0;j<vertexNum;j++){ // 这里应该是 j++ 而不是 i++\n            degree=degree+mat[i][j];\n        }\n        if(degree%2!=0){\n            count++;\n        }\n    }\n    return count;\n}\nint main(){\n    int a[4][MaxSize]={\n        {0,1,2,2},\n        {1,0,1,1},\n        {2,1,0,0},\n        {2,1,0,0}\n    };\n    EulerCircuit G{a,4};\n    int num=G.oddVertexNum();\n    if(num>=2){\n        cout<<num<<\"个地方通奇数桥，不存在欧拉回路\";\n    }\n    else{\n        cout<<\"存在欧拉回路\";\n    }\n    return 0;\n}\n```\n\n## 欧几里得算法\n\n欧几里得算法用自然语言描述如下：\n\n步骤1：将m除以n得到余数r\n\n步骤2：若r等于0，则n为最大公约数，算法结束；否则执行步骤3\n\n步骤3：将n的值放在m中，将r的值放在n中，重新执行步骤1\n\n```c++\n#include <iostream>\nusing namespace std;\nint ComFactor(int m,int n) {\n    int r=m%n;\n    while (r!=0) {\n        m=n;\n        n=r;\n        r=m%n;\n    }\n    return n;\n}\nint main() {\n    cout<<\"最大公约数是\"<<ComFactor(35,25)<<endl;\n    return 0;\n}\n```\n\n# 第二章\n\n## 线性表的定义\n\n线性表简称表，是n个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度，长度等于零的线性表称为空表，一个非空表通常记为：\n$$\nL=(a1,a2,...,an)\n$$\n其中，ai称为数据元素，下角标i表示该元素在线性表中的位置或序号，称元素ai位于表的第i个位置，或称是ai是表中的第i的元素。a1称为表头元素，an称为表尾元素，任意一对相邻的数据元素a（i-1）和ai（1<i<=n）之间存在序偶关系<a(i-1),ai>，且a(i-1)称为ai的前驱，ai称为a(i-1)的后继。在这个序列中，元素a1无前驱，元素an无后继，其他每个元素有且仅有一个前驱和一个后继\n\n线性表的基本操作包括：\n\n1. **初始化**：创建一个空的线性表。\n2. **销毁**：销毁线性表，释放其占用的内存空间。\n3. **插入**：在指定位置插入一个元素。\n4. **删除**：删除指定位置的元素。\n5. **查找**：查找并返回指定元素的位置。\n6. **取值**：获取指定位置的元素。\n7. **修改**：修改指定位置的元素。\n8. **长度**：返回线性表的长度（元素个数）。\n9. **判空**：判断线性表是否为空。\n\n## 线性表的顺序存储结构及实现\n\n线性表的顺序存储结构称为顺序表，其基本思想是用一段地址连续的存储单元依次存储线性表的数据元素\n\n设顺序表的每个元素占用c个存储单元，则第i个元素的存储地址为：\n$$\nLoc(ai)=Loc(a1)+(i-1)*c\n$$\n顺序表中数据元素的存储地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任何一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存取结构\n\n通常用一维数组来实现顺序表\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int MaxSize=100;//根据实际问题具体定义\ntemplate <typename DataType>//由于线性表的数据元素类型不确定，所以采用模板机制\nclass SeqList {\npublic:\n    SeqList();//创建一个空的线性表\n    SeqList(DataType a[],int n);//建立长度为n的顺序表\n    ~SeqList();//析构函数，销毁线性表，释放其占用的内存空间\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DataType data[MaxSize];//存放数据元素的数组\n    int length;//线性表的长度\n};\ntemplate<typename DataType>\nSeqList<DataType>::SeqList() {\n    length=0;\n}\n\ntemplate<typename DataType>\nSeqList<DataType>::SeqList(DataType a[], int n) {\n    if(n>MaxSize)throw\"参数非法\";\n    for(int i=0;i<n;i++) {\n        data[i]=a[i];\n    }\n    length=n;\n}\n\ntemplate<typename DataType>\nSeqList<DataType>::~SeqList() {}//\n\ntemplate<typename DataType>\nint SeqList<DataType>::Empty() {\n    return length==0;\n}\n\ntemplate<typename DataType>\nint SeqList<DataType>::Length() {\n    return length;\n}\n\ntemplate<typename DataType>\nvoid SeqList<DataType>::PrintList() {\n    for(int i=0;i<length;i++) {\n        cout<<data[i]<<'\\t';\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nDataType SeqList<DataType>::Get(int i) {//时间复杂度为O(1)\n    if(i<1||i>length)throw\"查找位置非法\";\n    else {\n        return data[i-1];\n    }\n}\n\ntemplate<typename DataType>\nint SeqList<DataType>::Locate(DataType x) {//平均时间性能是O(n)\n    for(int i=0;i<length;i++) {\n        if(data[i]==x)return i+1;\n    }\n    return 0;\n}\n\ntemplate<typename DataType>\nvoid SeqList<DataType>::Insert(int i, DataType x) {//平均时间性能是O(n)\n    if(length==MaxSize)throw\"表满，上溢\";\n    if(i<1||i>length+1)throw\"插入位置错误\";\n    for(int j=length;j>=i;j--) {\n        data[j]==data[j-1];\n    }\n    data[i-1]=x;\n    length++;\n}\n\ntemplate<typename DataType>\nDataType SeqList<DataType>::Delete(int i) {//平均时间性能是O(n)\n    DataType x;\n    if(length==0)throw\"空表 下溢\";\n    if(i<1||i>length)throw\"删除位置错误\";\n    x=data[i-1];\n    for(int j=i;j<length;j++) {\n        data[j-1]=data[j];\n    }\n    length--;\n    return x;\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    SeqList<int>L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 线性表的链接存储结构及其实现\n\n单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。为了能正确表示元素之间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成了数据元素的存储映像，称为结点。\n\n### 单链表的结点定义\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n在使用单链表时，关心的只是数据元素以及数据元素之间的逻辑关系\n\n单链表中每个结点的存储地址存放在其前驱结点的next域中，而第一个结点无前驱，所以设头指针指向第一个元素所在结点，整个单链表的存取必须从头指针开始进行，因而头指针具有标识一个单链表的作用。最后一个元素所在结点的指针域为空。\n\n### 单链表的实现\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType> *next;\n};\n\ntemplate<typename DataType>\nclass LinkList {\npublic:\n    LinkList();\n    LinkList(DataType a[],int n);\n    ~LinkList();\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    Node<DataType> *first;\n};\n\ntemplate<typename DataType>\nLinkList<DataType>::LinkList() {\n    first=new Node<DataType>;\n    first->next=nullptr;\n    /* nullptr是一个字面常量，表示空指针\n       它用于初始化指针变量或将其赋值给指针变量，\n       以确保指针不指向任何有效的内存地址 */\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Empty() {\n    return first->next==nullptr;\n}\n\ntemplate<typename DataType>\nvoid LinkList<DataType>::PrintList() {//时间复杂度为O(n)\n    //设置工作指针p依次指向各节点\n    //p后移不能写作p++\n    Node<DataType> *p=first->next;\n    while (p!=nullptr) {\n        cout<<p->data<<\" \";\n        p=p->next;//工作指针后移\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Length() {\n    Node<DataType> *p=first->next;\n    int count=0;\n    while (p!=nullptr) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    return count;\n}\n\ntemplate<typename DataType>\nDataType LinkList<DataType>::Get(int i) {\n    Node<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr && count<i) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    if(p==nullptr)throw \"查找位置错误\" ;\n    else {\n        return p->data;\n    }\n    //平均时间性能为O(n),单链表是顺序存取结构\n}\n\ntemplate<typename DataType>\nint LinkList<DataType>::Locate(DataType x) {\n    Node<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr) {\n        if(p->data==x) {\n            return count;\n        }\n        p=p->next;\n        count++;\n    }\n    return 0;\n    //平均时间性能为O(n)\n}\n\ntemplate<typename DataType>\nvoid LinkList<DataType>::Insert(int i, DataType x) {//时间复杂度为O(n)\n    Node<DataType> *p=first,*s=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr)throw\"插入位置错误\";\n    else {\n        s=new Node<DataType>;\n        s->data=x;\n        s->next=p->next;\n        p->next=s;\n    }\n}\n\ntemplate<typename DataType>\nLinkList<DataType>::LinkList(DataType a[], int n) {\n    //头插法\n    first=new Node<DataType>;\n    first->next=nullptr;\n    for(int i=0;i<n;i++) {\n        Node<DataType> *s=nullptr;\n        s=new Node<DataType>;\n        s->data=a[i];\n        s->next=first->next;\n        first->next=s;\n    }\n    //尾插法\n    // first=new Node<DataType>;\n    // Node<DataType> *r=first,*s=nullptr;\n    // for(int i=0;i<n;i++) {\n    //     s=new Node<DataType>;\n    //     s->data=a[i];\n    //     r->next=s;\n    //     r=s;\n    // }\n    // r->next=nullptr;\n}\n\ntemplate<typename DataType>\nDataType LinkList<DataType>::Delete(int i) {\n    DataType x;\n    Node<DataType> *p=first,*q=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr || p->next==nullptr)throw \"删除位置错误\" ;\n    else {\n        q=p->next;\n        x=q->data;\n        p->next=q->next;\n        delete q;\n        return x;\n    }\n}\n\ntemplate<typename DataType>\nLinkList<DataType>::~LinkList() {\n    Node<DataType> *p=first;\n    while (first!=nullptr) {\n        first=first->next;\n        delete p;\n        p=first;\n    }\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    LinkList<int> L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 双链表\n\n在单链表的每个结点中再设置一个指向其前驱结点的指针域，这样就形成了双链表\n\n### 双链表的结点结构定义：\n\n```c++\ntemplate<typename Datatype>\nstruct DulNode {\n    Datatype data;\n    DulNode<Datatype> *prior,*next;\n};\n```\n\n在双链表中求表长等操作与单链表基本相同，下面讨论插入和删除操作\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate<typename Datatype>\nstruct DulNode {\n    Datatype data;\n    DulNode<Datatype> *prior,*next;\n};\n\ntemplate<typename DataType>\nclass DulLinkList {\npublic:\n    DulLinkList();\n    DulLinkList(DataType a[],int n);\n    ~DulLinkList();\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DulNode<DataType> *first;\n};\n\ntemplate<typename DataType>\nDulLinkList<DataType>::DulLinkList() {\n    first=new DulNode<DataType>;\n    first->next=nullptr;\n    first->prior=nullptr;\n    /* nullptr是一个字面常量，表示空指针\n       它用于初始化指针变量或将其赋值给指针变量，\n       以确保指针不指向任何有效的内存地址 */\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Empty() {\n    return first->next==nullptr;\n}\n\ntemplate<typename DataType>\nvoid DulLinkList<DataType>::PrintList() {//时间复杂度为O(n)\n    //设置工作指针p依次指向各节点\n    //p后移不能写作p++\n    DulNode<DataType> *p=first->next;\n    while (p!=nullptr) {\n        cout<<p->data<<\" \";\n        p=p->next;//工作指针后移\n    }\n    cout<<endl;\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Length() {\n    DulNode<DataType> *p=first->next;\n    int count=0;\n    while (p!=nullptr) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    return count;\n}\n\ntemplate<typename DataType>\nDataType DulLinkList<DataType>::Get(int i) {\n    DulNode<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr && count<i) {\n        p=p->next;//工作指针后移\n        count++;\n    }\n    if(p==nullptr)throw \"查找位置错误\" ;\n    else {\n        return p->data;\n    }\n    //平均时间性能为O(n),单链表是顺序存取结构\n}\n\ntemplate<typename DataType>\nint DulLinkList<DataType>::Locate(DataType x) {\n    DulNode<DataType> *p=first->next;\n    int count=1;\n    while (p!=nullptr) {\n        if(p->data==x) {\n            return count;\n        }\n        p=p->next;\n        count++;\n    }\n    return 0;\n    //平均时间性能为O(n)\n}\n\ntemplate<typename DataType>\nvoid DulLinkList<DataType>::Insert(int i, DataType x) {//时间复杂度为O(n)\n    DulNode<DataType> *p=first,*s=nullptr;\n    int count=0;\n    while (p!=nullptr && count<i-1) {\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr)throw\"插入位置错误\";\n    else {\n        s=new DulNode<DataType>;\n        s->data=x;\n        //与单链表不同之处//这里\n        s->prior=p;\n        s->next=p->next;\n        p->next->prior=s;\n        p->next=s;\n    }\n}\n\ntemplate<typename DataType>\nDulLinkList<DataType>::DulLinkList(DataType a[], int n) {\n    //头插法\n    first=new DulNode<DataType>;\n    first->next=nullptr;\n    for(int i=0;i<n;i++) {\n        DulNode<DataType> *s=nullptr;\n        s=new DulNode<DataType>;\n        s->data=a[i];\n        s->next=first->next;\n        first->next=s;\n    }\n    //尾插法\n    // first=new DulNode<DataType>;\n    // DulNode<DataType> *r=first,*s=nullptr;\n    // for(int i=0;i<n;i++) {\n    //     s=new DulNode<DataType>;\n    //     s->data=a[i];\n    //     r->next=s;\n    //     r=s;\n    // }\n    // r->next=nullptr;\n}\n\ntemplate<typename DataType>\nDataType DulLinkList<DataType>::Delete(int i) {//这里\n    DulNode<DataType> *p = first;\n    DulNode<DataType> *q;\n    int count = 0;\n    while (p != nullptr && count < i - 1) {\n        p = p->next;\n        count++;\n    }\n\n    if (p == nullptr || p->next == nullptr) {\n        throw std::runtime_error(\"删除位置错误\");\n    } else {\n        q = p->next; // Save the node to be deleted\n        p->next = q->next; // Update next of the previous node\n        q->next->prior = p; // Update prior of the next node\n        DataType x = q->data; // Save data to return\n        delete q; \n        return x; \n    }\n}\n\ntemplate<typename DataType>\nDulLinkList<DataType>::~DulLinkList() {\n    DulNode<DataType> *p=first;\n    while (first!=nullptr) {\n        first=first->next;\n        delete p;\n        p=first;\n    }\n}\n```\n\n```c++\nint main() {\n    int r[5]={1,2,3,4,5},i,x;\n    DulLinkList<int> L{r,5};\n    cout<<\"当前线性表的数据为：\";\n    L.PrintList();\n    try {\n        L.Insert(2,8);\n        cout<<\"执行插入操作后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    cout<<\"当前线性表的长度为：\"<<L.Length()<<endl;\n    cout<<\"请输入查找的元素值：\";\n    cin>>x;\n    i=L.Locate(x);\n    if (0==i)cout<<\"查找失败\"<<endl;\n    else {\n        cout<<\"元素\"<<x<<\"的位置为：\"<<i<<endl;\n    }\n    try {\n        cout<<\"请输入查找第几个元素值：\";\n        cin>>i;\n        cout<<\"第\"<<i<<\"个元素值是\"<<L.Get(i)<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入要删除的第几个元素\";\n        cin>>i;\n        x=L.Delete(i);\n        cout<<\"删除的元素是\"<<x<<\",删除后数据为：\";\n        L.PrintList();\n    }catch (char *str){cout<<str<<endl;}\n    return 0;\n}\n```\n\n## 循环链表\n\n在单链表中，如果将终端结点的指针由空指针改为指向头结点，就使得整个单链表形成一个环，这种头尾相接的单链表称为循环单链表。实际应用中多采用尾指针指示的循环单链表\n\n在双链表中，如果将终端结点的后继指针由空指针改为指向头结点，将头结点的前驱指针由空指针改为指向终端结点，就使得整个双链表形成一个环，这种头尾相接的单链表称为循环双链表\n\n循环链表中没有明显的尾端，可能会使循环链表的处理操作进入死循环，通常判断用作循环变量的工作指针是否等于某一特定指针（如头指针或尾指针），以判定工作指针是否扫描了整个链表，例如可以用循环条件  `p!=first`  判断工作指针是否扫描了整个链表\n\n## 顺序表和链表的比较\n\n### 1.时间性能比较\n\n所谓时间性能是指基某种存储结构的基本操作（即算法）的时间复杂度。\n\n**随机访问**\n- **顺序表**：能够直接定位到任意位置，实现快速访问，时间复杂度为 O(1)。\n- **链表**：必须从头部开始遍历至目标位置，平均时间复杂度为 O(n)。\n\n**插入与删除**\n- **链表**：一旦拥有指向目标位置的指针，插入或删除操作无需移动其他元素，时间复杂度为 O(1)。\n- **顺序表**：插入或删除元素需要调整后续所有元素的位置，平均时间复杂度为 O(n)，尤其是当元素数量大或每个元素占用较大存储空间时，移动元素的成本显著增加。\n\n**一般来说**\n\n- 当线性表的主要操作是**频繁查找**且**插入和删除较少**，或操作依赖于**数据元素的绝对位置**时，**顺序表**是更优的选择。\n- 若线性表中**频繁执行插入和删除操作**，**链表**则提供更好的性能。\n\n### 2.空间性能比较\n\n所谓空间性能是指某种存储结构所占用的存储空间的大小。\n\n- **存储特性**\n  - **顺序表**: 每个结点仅包含数据元素，存储密度高，空间利用率好。\n  - **链表**: 结点包含数据元素和指针，指针增加结构开销，降低存储密度。\n- **空间分配**\n  - **顺序表**: 需预分配固定大小空间，可能造成浪费（分配过多）或上溢（分配不足）。\n  - **链表**: 动态分配，元素数量不受限，只要系统有可用内存。\n- **适用场景**\n  - **顺序表**: 适合已知大致长度的线性表，以优化空间效率。\n  - **链表**: 更适用于元素数量变化大或未知的情况。\n\n## 扩展与提高\n\n### 线性表的静态链表存储\n\n静态链表用数组来表示链表。由于是利用数组定义的链表，属于静态存储分配，因此叫静态链表。最常用的是静态单链表。\n\navail是空闲链表（全部由空闲数组单元组成的单链表）头指针，first是静态链表头指针，为了运算方便通常静态链表也带头指针。\n\n**静态链表的数组元素定义：**\n\n```c++\ntemplate <typename DateType>\nstruct SNode {\n    DateType data;\n    int next;//指针域(也称游标),注意不是指针类型\n};\n```\n\n**静态链表的定义：**\n\n```c++\nconst int MaxSize=100;\ntemplate <typename DataType>\nclass StaList {\npublic:\n    StaList();\n    StaList(DataType a[],int n);\n    ~StaList();\n    //与单链表成员函数相同\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    SNode<DataType> SList[MaxSize];\n    int first,avail;\n};\n```\n\n静态链表采用静态存储分配，因此析构函数为空，求表长等操作的实现基本与单链表相同，下面讨论**插入和删除**操作\n\n在静态链表中进行插入操作，首先从空闲链的最前端摘下一个结点，将该结点插入静态链表中，假设新结点插在结点p的后面，则修改指针的操作为：\n\n```c++\ns=avail;\navail=SList[avail].next;\nSList[s].data=x;\nSList[s].next=SList[p].next;\nSList[p].next=s;\n```\n\n在静态链表中进行删除操作，首先将被删除结点从静态链表中摘下，再插入空闲链的最前端，假设要删除结点p的后继结点，则修改指针的操作为：\n\n```\nq=SList[p].next;\nSList[p].next=SList[q].next;\nSList[q].next=avail;\navail=q;\n```\n\n### 顺序表的动态分配方式\n\n顺序表的动态分配方式是在程序执行过程中通过动态存储分配，一旦数组空间占满，另外再分配一块更大的存储空间，用来替换原来的存储空间，从而达到扩充数组空间的目的\n\n```c++\nconst int InitSize=100;//顺序表的初始长度\nconst int IncreSize=10;//顺序表存储空间每次扩展的长度\ntemplate <typename DataType>\nclass SeqList {\npublic:\n    //与顺序表的静态分配相同\n    SeqList();\n    SeqList(DataType a[],int n);\n    ~SeqList();\n    //与单链表成员函数相同\n    int Length();//求线性表的长度\n    DataType Get(int i);//按位查找，查找第i个元素的值\n    int Locate(DataType x);//按值查找，查找值为x的元素序号；\n    void Insert(int i,DataType x);//插入操作，在第i个位置插入值为x的元素\n    DataType Delete(int i);//删除操作，删除第i个元素\n    int Empty();//判断线性表是否为空\n    void PrintList();//按序号输出各元素\nprivate:\n    DataType *data;//动态申请数组空间的首地址\n    int maxSize;//当前数组空间的最大长度\n    int length;//线性表的长度\n};\n```\n\n在顺序表的动态分配方式下，求线性表的长度等操作与顺序表的静态分配方式相同，下面讨论其他基本操作的实现\n\n#### 无参构造函数——初始化顺序表：\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::SeqList() {\n    data=new DataType[InitSize];\n    maxSize=InitSize;\n    length=0;\n}\n```\n\n#### 有参构造函数——建立顺序表：\n\n建立一个长度为*n*的顺序表需要申请长度大于n的存储空间，一般是当前线性表长度两倍的存储空间：\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::SeqList(DataType a[], int n) {\n    data=new DataType[2*n];\n    maxSize=2*n;\n    for(int i=0;i<n;i++) {\n        data[i]=a[i];\n    }\n    length=n;\n}\n```\n\n#### 析构函数——销毁顺序表\n\n```c++\ntemplate<typename DataType>\nSeqList<DataType>::~SeqList() {\n    delete[] data;\n}\n```\n\n#### 插入操作\n\n```c++\n// 在序列的第i个位置插入元素x\ntemplate<typename DataType>\nvoid SeqList<DataType>::Insert(int i, DataType x) {\n    // 检查插入位置是否合法\n    if(i<1||i>length+1)throw\"插入位置错误!\";\n    // 检查序列是否已满\n    if(length==maxSize) {\n        // 发生上溢,扩充存储空间\n        DataType *oldData=data;\n        maxSize+=IncreSize;\n        data=new DataType[maxSize];\n        // 将旧数据复制到新数组\n        for(int j=0;j<length;j++) {\n            data[j]=oldData[j];\n        }\n        // 释放旧数组的内存\n        delete[] oldData;\n    }\n    // 为新元素腾出空间\n    for(int j=length;j>=i;j--) {\n        data[j]=data[j-1];\n    }\n    // 插入新元素\n    data[i-1]=x;\n    // 更新序列长度\n    length++;\n}\n```\n\n## 应用示例\n\n### 约瑟夫环问题\n\n由于约瑟夫环问题本身具有循环性质，考虑采用循环单链表。求解约瑟夫环的问题的基本思路是：设置一个计数器count和工作指针p，当计数器累加到m时删除结点p。为了统一对链表中任意结点进行计数和删除操作，循环单链表不带头结点；为了便于删除操作设两个工作指针pre和p，指针pre指向p的前驱结点；为了使计数器从1开始奇数，采用尾指针指示的循环单链表，将指针pre初始化为指向终端结点，将指针p初始化为开始结点。\n\n```c++\n#include <iostream>\nusing namespace std;\nstruct Node {//约瑟夫环的结点定义\n    int data;\n    struct Node *next;\n};\nclass JosephRing {\npublic:\n    JosephRing(int n);//构造函数，初始化n个结点的循环单链表\n    ~JosephRing();//析构函数，类似单链表的析构函数\n    void Joseph(int m);//为m，打印出环的顺序\nprivate:\n    Node *rear;\n};\nJosephRing::~JosephRing() {\n    \n}\nJosephRing::JosephRing(int n) {\n    Node *s=nullptr;\n    rear=new Node;\n    rear->data=1;rear->next=rear;//建立长度为1的循环单链表\n    for(int i=2;i<=n;i++) {//依次插入数据域为2、3...n的结点\n        s=new Node;\n        s->data=i;\n        s->next=rear->next;//将结点s插入尾结点rear的后面\n        rear->next=s;\n        rear=s;\n    }\n}\nvoid JosephRing::Joseph(int m) {\n    Node *pre=rear,*p=rear->next;\n    int count=1;\n    cout<<\"出环的顺序是:\";\n    while (p->next!=p) {\n        if(count<m) {\n            pre=p;p=p->next;\n            count++;\n        }\n        else {\n            cout<<p->data<<\"\\t\";\n            pre->next=p->next;//将p摘链\n            delete p;\n            p=pre->next;//工作指针p后移，但pre不动\n            count=1;\n        }\n    }\n    cout<<p->data<<\"\\t\";\n    delete p;\n}\nint main() {\n    int n,m;\n    cout<<\"请输入约瑟夫环的长度：\";\n    cin>>n;\n    cout<<\"请输入密码：\";\n    cin>>m;\n    JosephRing R{n};\n    R.Joseph(m);\n    return 0;\n}\n```\n\n### 一元多项式求和\n\n若相加的某两项的指数不等，则两项应分别加在结果中，将引起线性表的插入；若某两项的指数相等，则系数相加，若相加结果为零，将引起线性表的删除。由于在线性表的合并过程中需要频繁地执行插入和删除操作，因此考虑采取单链表存储。\n\n在表示一元多项式的单链表中，每一个非零项对应单链表中的一个结点，且单链表应按指数递增有序排列。\n\n其中，coef 为系数域，存放非零项的系数；exp为指数域，存放非零项的指数；next 为指针域，存放指向下一结点的指针。\n\n下面分析一元多项式求和的执行过程。\n\n设单链表A和B分别存储两个多项式，求和结果存储在单链表 A 中，设两个工作指针p和q分别指向两个单链表的开始结点。\n\n两个多项式求和实质上是对结点p的指数域和结点q的指数域进行比较，有下列三种情况：\n\n① 若p一>exp 小于q一>exp，则结点p应为结果链表中的一个结点，将指针p后移\n\n② 若p->exp大于q一＞exp，则结点q应为结果中的一个结点，将q插入到第一个单链表中结点P之前，并将指针q指向单链表B中的下一个结点。为此，在单链表A 中应该设置两个工作指针 pre 和p，使得pre 指向p的前驱结点。\n\n③ 若p->exp等于q->exp，则p与q所指为同类项，将q的系数加到p的系数上。若相加结果不为0，则将指针P后移，并删除结点q，为此，在单链表B中应该设置两个工作指针 qre 和q，使得gre 指向q的前驱结点；若相加结果为0，则表明结果中无此项，删除结点p和结点 q，并将指针p 和指针q分别后移。\n\n```c++\n#include <iostream>\nusing namespace std;\nstruct Node {\n    int coef,exp;\n    Node *next;\n};\nclass Polynomial {\npublic:\n    Polynomial();\n    Polynomial(const Polynomial &B);//拷贝构造函数\n    /*拷贝构造函数是C++中一种特殊的构造函数，用于创建一个对象作为已存在对象的副本\n    这种构造函数的名称与类名相同，形式参数只有一个，即该类的引用类型的对象.\n    通常，这个形参会被声明为const，以确保在构造过程中不会修改原对象.\n    拷贝构造函数的主要应用场景包括，当一个对象作为值传递的参数传递给函数，\n    或者函数返回一个对象时，都需要调用到拷贝构造函数*/\n    ~Polynomial();\n    Polynomial operator+(Polynomial &B);//重载运算符,多项式相加\n    void Print();\nprivate:\n    Node *first;//一元多项式单链表的头指针\n};\n\nPolynomial::Polynomial() {\n    Node *r=nullptr,*s=nullptr;\n    int coef,exp;\n    first=new Node;//申请头结点\n    r=first;//尾插法建立单链表\n    cout<<\"请输入系数和指数\";\n    cin>>coef>>exp;\n    while (coef!=0) {//循环结束的条件是输入系数为0\n        s=new Node;\n        s->coef=coef;s->exp=exp;\n        r->next=s;r=s;//将结点s插入单链表的尾部\n        cout<<\"请输入系数和指数\";\n        cin>>coef>>exp;\n    }\n    r->next=nullptr;\n    cout<<\"\\n\\n\";\n}\nPolynomial::Polynomial(const Polynomial &B) {\n    first=B.first;\n}\nPolynomial::~Polynomial() {\n\n}\nPolynomial Polynomial::operator+(Polynomial &B) {\n    Node *pre=first,*p=pre->next;//工作指针pre和p初始化\n    Node *qre=B.first,*q=qre->next;//工作指针qre和q初始化\n    Node *qtemp=nullptr;\n    while (p!=nullptr && q!=nullptr) {\n        if(p->exp < q->exp) {//第1种情况\n            pre=p;p=p->next;\n        }\n        else if(p->exp > q->exp) {//第2种情况\n            qtemp=q->next;\n            pre->next=q;//将结点q插入到结点p之前\n            q->next=p;\n            pre=q;\n            q=qtemp;\n            qre->next=q;\n        }\n        else {//第3种情况\n            p->coef=p->coef+q->coef;\n            if(p->coef==0) {//系数相加为0,则删除结点p\n                pre->next=p->next;\n                delete p;\n                p=pre->next;\n            }\n            else {\n                pre=p;\n                p=p->next;\n            }\n            qre->next=q->next;//第3种情况都要删除结点q\n            delete q;\n            q=qre->next;\n        }\n    }\n    if(q!=nullptr) {\n        pre->next=q;//将结点q链接到第一个单链表的后面\n    }\n    return *this;\n}\n\nvoid Polynomial::Print() {\n    Node *p=first->next;\n    if(p!=nullptr) {//输出第一项\n        cout<<p->coef<<\"x^\"<<p->exp;\n    }\n    p=p->next;\n    while (p!=nullptr) {\n        if(p->coef>0) {\n            cout<<\"+\"<<p->coef<<\"x^\"<<p->exp;\n        }\n        else {\n            cout<<p->coef<<\"x^\"<<p->exp;\n        }\n        p=p->next;\n    }\n    cout<<\"\\n\";\n}\n\nint main() {\n    Polynomial A{},B{};\n    A.Print();\n    B.Print();\n    A=A+B;//运算符重载，对象赋值调用拷贝构造函数\n    cout<<\"结果是：\";\n    A.Print();\n    return 0;\n}\n```\n\n\n\n```\n请输入系数和指数7 0\n请输入系数和指数12 3\n请输入系数和指数-2 8\n请输入系数和指数5 12\n请输入系数和指数0 0\n\n\n请输入系数和指数4 1\n请输入系数和指数6 3\n请输入系数和指数2 8\n请输入系数和指数5 20\n请输入系数和指数7 28\n请输入系数和指数0 0\n\n\n7x^0+12x^3-2x^8+5x^12\n4x^1+6x^3+2x^8+5x^20+7x^28\n结果是：7x^0+4x^1+18x^3+5x^12+5x^20+7x^28\n\n进程已结束，退出代码为 0\n```\n\n\n\n## 思想火花\n\n **实验问题：**\n\n  将一个具有n个元素的数组向左循环移动i个位置。\n\n> [!NOTE]\n>\n> 如图1 数组元素循环左移1位：\n>\n> ![数组元素循环左移1位](img\\1485495-20190604181312769-273893486.png)\n>\n> 将一个具有n个元素的数组向左循环移动i个位置，**意味着将数组的前i个元素移动到数组的末尾，而原数组中的其余元素则相应地向左移动**\n\n 有许多应用程序会调用这个问题的算法，例如在文本编辑器中移动行的操作，磁盘整理时交换两个不同大小的相邻内存块等。所以，这个问题的算法要求有较高的时间和空间性能。 \n\n**基本要求：**\n\n  ⑴在原数组中实现循环右移，不另外申请空间；\n\n  ⑵时间性能尽可能好；\n\n   ⑶分析算法的时间复杂度。\n\n 要在不另申请空间的情况下，保证算法的时间性能尽可能好，如果先设计一个函数将数组向左移动一位，然后再调用该算法i次，是一些人通常想到的方法，但显然这个算法的时间性能不是最好的。要在有限的资源中解决这个问题，似乎比较困难，是否存在这种既不另申请存储空间，又能够达到最好时间性能的完美算法呢。\n\n  **求解步骤：**\n\n1）可以通过下面的方法解决这个问题：先将数组中的前i个元素存放在一个临时数组中，再将余下的n-i个元素左移i个位置， 最后将前i个元素从临时数组复制回原数组中后面的位置。但是这个算法使用了i个额外的存储单元，使得空间性能降低。\n\n2）如上所述，先设计一个函数将数组向左循环移动一个位置，然后再调用该算法i次， 显然，这个算法的时间性能不好。 \n\n 3）现在我们换一个角度看这个问题： 将这个问题看作是把数组ab转换成数组ba（a代表数组的前i个元素，b代表数组中余下的n-i个元素）， 先将a逆置得到ar b，再将b逆置得到ar br，最后将整个ar br逆置得到(ar br)r=ba。\n> [!NOTE]\n>\n> **数组元素逆置是指将数组中的元素按照相反的顺序重新排列，即第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，以此类推，直到所有元素都逆序排列完毕**。\n\n设Reverse函数执行将数组元素逆置的操作， 对abcdefgh向左循环移动3个位置的过程如下：\n```\nReverse(0, i-1); //得到cbadefgh(逆置abc)\nReverse(i, n-1); //得到cbahgfed(逆置defgh)\nReverse(0, n-1); //得到defghabc(逆置cbahgfed)\n```\n\n其原理可以用一个简单的游戏来理解：将两手的掌心对着自己，左手在右手上面， 可以实现将一个具有10 个元素的数组向左循环移动5位，如图所示。\n\n![](img\\1358339139_6806.jpg)\n\n```c++\n#include <iostream>\nusing namespace std;\nvoid reverseArr(int A[],int start,int rear){\n    for(int i=start,j=rear;i<j;i++,j--) {\n        int t=A[i];\n        A[i]=A[j];\n        A[j]=t;\n    }\n}\nvoid leftCir(int A[],int n,int k){\n    if(k<=0 || k>=n)\n        cout<<\"ERROR\"<<endl;\n    else{\n        reverseArr(A,0,k-1);\n        reverseArr(A,k,n-1);\n        reverseArr(A,0,n-1);\n    }\n}\nvoid show(int A[],int n){\n    for(int i=0;i<n;++i)\n        cout<<A[i]<<\" \";\n    cout<<endl;\n}\nint main()\n{\n    int n,p;\n    cin>>n>>p;\n    int a[n];\n    for(int i=0;i<n;++i)\n        cin>>a[i];\n    leftCir(a,n,p);\n    show(a,n);\n    return 0;\n}\n```\n\n该算法在时间和空间上都很有效，并且是这么简短和简单，想出错都很难。 Brian Kernighan在Software Tools in Pascal中使用了这个算法在文本编辑器中移动各行。\n\n[Software tools in Pascal by Brian W. Kernighan | 开放图书馆 (openlibrary.org)](https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal)\n\n> Brian Kernighan 在他的著作 *Software Tools in Pascal* 中，讨论了一个将 n 个元素的数组向左循环移动 i 个位置的算法。原文如下：\n>\n> \"To rotate an array left by i positions, reverse the first i elements, then reverse the remaining n-i elements, and finally reverse the entire array.\"\n>\n> 翻译过来大致是：\n>\n> “要将一个数组向左循环移动 i 个位置，首先反转数组的前 i 个元素，然后反转剩下的 n-i 个元素，最后反转整个数组。”\n>\n> 这种方法基于三个步骤的反转操作，可以高效地完成数组的左循环移动。\n\n作为一个规律，一个好的算法是反复努力和重新修正的结果，即使足够幸运地得到了一个貌似完美的算法思想， 我们也应该尝试着改进它。 \n\n## 习题\n\n\n\n# 第三章\n\n## 栈\n\n栈是限定仅在表的一段进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈\n\n> [!NOTE]\n>\n> 插入元素——入栈、进栈、压栈\n>\n> 删除元素——出栈、弹栈\n\n栈中元素除了具有线性关系外，还具有***==后进先出==***的特性\n\n栈的顺序存储结构称为顺序栈，本质上是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底\n\n通常把数组中下标为0的一段作为栈底，同时附设变量top指示栈顶元素在数组中的位置\n\n设存储栈的数组长度为StackSize，则栈空时栈顶位置top=-1；栈满时栈顶位置top=StackSize-1\n\n> [!TIP]\n>\n> 在有些教程中，将top指向栈中第一个空闲位置，如果这样的话，空栈应该表示为top=0\n\n入栈时，栈顶位置top加1；出栈时，栈顶位置top减1\n\n### 顺序栈的实现\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int StackSize=10;//\ntemplate<typename DataType>\nclass SeqStack {\npublic:\n    SeqStack();//初始化一个空栈\n    ~SeqStack();//析构函数\n    void Push(DataType x);//入栈操作，将元素x入栈\n    DataType Pop();//出栈操作，将栈顶元素弹出\n    DataType GetTop();//取栈顶元素(并不删除)\n    int Empty();//判断栈是否为空\nprivate:\n    DataType data[StackSize];\n    int top;//栈顶元素在数组中的下标\n};\ntemplate<typename DataType>\nSeqStack<DataType>::SeqStack() {\n    top=-1;\n}\ntemplate<typename DataType>\nSeqStack<DataType>::~SeqStack() {\n\n}\ntemplate<typename DataType>\nvoid SeqStack<DataType>::Push(DataType x) {\n    if(top==StackSize-1)throw\"上溢\";\n    data[++top]=x;\n    /*即:\n    top++;\n    s[top] = x;\n    */\n}\ntemplate<typename DataType>\nDataType SeqStack<DataType>::Pop() {\n    DataType x;\n    if(top==-1)throw\"下溢\";\n    x=data[top--];\n    /*即:\n    x=data[top];\n    top--;\n    */\n    return x;\n}\ntemplate<typename DataType>\nDataType SeqStack<DataType>::GetTop() {\n    return data[top];\n}\ntemplate<typename DataType>\nint SeqStack<DataType>::Empty() {\n    if(top==-1)return 1;\n    else return 0;\n}\n```\n\n```c++\nint main() {\n    int x;\n    SeqStack<int> S{};\n    cout<<\"对15和10入栈\";\n    S.Push(15);S.Push(10);\n    cout<<\"当前栈顶元素为:\"<<S.GetTop()<<endl;\n    try {\n        x=S.Pop();\n        cout<<x<<\"出栈\"<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入待入栈元素\";\n        cin>>x;\n        S.Push(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(S.Empty()==1) {\n        cout<<\"栈为空\"<<endl;\n    }\n    else {\n        cout<<\"栈非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 栈的链接存储结构及实现\n\n栈的链接存储结构称为链栈，通常用单链表表示，其节点结构与单链表的结点结构相同\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n因为只能在栈顶执行入栈(插入)和出栈(删除)操作，所以以单链表的头部做栈顶是最方便的，而且没有必要像单链表那样为了运算方便附加头结点\n\n> [!TIP]\n>\n> 在单链表中，如果我们将头部用作栈顶（top），那么入栈和出栈操作都会非常高效，这是因为单链表的特性允许我们在头部进行 O(1) 时间复杂度的操作。\n>\n> 具体来说，有以下几点原因：\n>\n> 1. **插入操作**：当我们需要向栈中添加一个元素时（即入栈操作），我们只需要创建一个新的节点，并让它指向当前的头部（即当前栈顶），然后更新头部指针指向这个新节点。这样的操作不需要遍历整个链表来找到插入位置，因此时间复杂度为 O(1)。\n> 2. **删除操作**：当我们需要从栈中移除一个元素时（即出栈操作），我们只需改变头部指针，让它指向原来的头部所指向的下一个节点，并释放原来的头部节点即可。这也同样是一个 O(1) 的操作。\n> 3. **访问栈顶元素**：由于头部就是栈顶，访问栈顶元素也仅需要返回头部指针指向的节点的数据，这也是 O(1) 的操作。\n>\n> 关于是否需要附加头结点（dummy head）的问题，通常情况下，如果单链表只用于实现栈的功能，并且不需要支持其他额外操作（比如查找特定元素等），那么就没有必要设置一个额外的头结点。因为所有的操作都在头部进行，直接将头部视为栈顶已经足够高效了。\n\n时间复杂度 —— O(1)\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\ntemplate<typename DataType>\nclass LinkStack {\npublic:\n    LinkStack();\n    ~LinkStack();\n    void Push(DataType x);//入栈操作，将元素x入栈\n    DataType Pop();//出栈操作，将栈顶元素弹出\n    DataType GetTop();//取栈顶元素(并不删除)\n    int Empty();//判断栈是否为空\nprivate:\n    Node<DataType> *top;//栈顶指针即链栈的头指针\n};\ntemplate<typename DataType>\nLinkStack<DataType>::LinkStack() {\n    top=nullptr;\n}\ntemplate<typename DataType>\nLinkStack<DataType>::~LinkStack() {\n\n}\ntemplate<typename DataType>\nvoid LinkStack<DataType>::Push(DataType x) {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->data=x;\n    s->next=top;\n    top=s;\n}\ntemplate<typename DataType>\nDataType LinkStack<DataType>::Pop() {\n    Node<DataType> *p=nullptr;\n    DataType x;\n    if(top==nullptr)throw\"下溢\";\n    x=top->data;\n    p=top;\n    top=top->next;\n    delete p;\n    return x;\n}\ntemplate<typename DataType>\nDataType LinkStack<DataType>::GetTop() {\n    return top->data;\n}\ntemplate<typename DataType>\nint LinkStack<DataType>::Empty() {\n    if(top==nullptr)return 1;\n    else return 0;\n}\n```\n\n```c++\nint main() {\n    int x;\n    LinkStack<int> S{};\n    cout<<\"对15和10入栈\";\n    S.Push(15);S.Push(10);\n    cout<<\"当前栈顶元素为:\"<<S.GetTop()<<endl;\n    try {\n        x=S.Pop();\n        cout<<x<<\"出栈\"<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入待入栈元素\";\n        cin>>x;\n        S.Push(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(S.Empty()==1) {\n        cout<<\"栈为空\"<<endl;\n    }\n    else {\n        cout<<\"栈非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 顺序栈和链栈的比较\n\n作为一般规律，当栈的使用过程中元素变化较大时，应该采用链栈，反之，应使用顺序栈\n\n### STL中的栈\n\nC++ Stack(堆栈) 是一个容器类的改编，为程序员提供了堆栈的全部功能，--也就是说实现了一个先进后出(FILO)的数据结构。\n\n栈stack的头文件为:\n\n#include <stack>\n\n#### c++ stl栈stack的成员函数介绍\n\n操作   比较和分配堆栈\n\nempty()堆栈为空则返回真\n\npop()移除栈顶元素(删除)\n\npush()在栈顶增加元素(增加)\n\nsize() 返回栈中元素数目\n\ntop() 返回栈顶元素，不删除(获取)\n\n##### 1.什么是[stack](https://so.csdn.net/so/search?q=stack&spm=1001.2101.3001.7020)\n\n**1. stack**是一种**容器适配器**，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。**(后进先出)**\n\n**2. stack**是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。\n\n**3. stack**的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下\n\n**操作：**\n\n> **empty：判空操作**\n>\n> **back：获取尾部元素操作**\n>\n> **push_back：尾部插入元素操作**\n>\n> **pop_back：尾部删除元素操作**\n\n**4.** 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/667251d46c039b39d506132e9fa06b51.png)\n\n##### 2.容器适配器\n\n**容器适配器（Container Adapters）是 C++ 标准库提供的一种数据结构，它们基于现有的容器类型，提供了特定的接口和功能，以便更方便地实现某些特定的数据结构和算法**。容器适配器本质上是对底层容器的封装，提供了不同的数据访问方式，使它们适用于特定的用途。 \n\n**标准库中提供了三种常用的容器适配器：**\n\n> ***\\*stack：栈适配器\\**，基于底层容器提供了栈数据结构的操作，如压入（push）、弹出（pop）、查看栈顶元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。**\n>\n>\n> ***\\*queue：队列适配器\\**，基于底层容器提供了队列数据结构的操作，如入队（push）、出队（pop）、查看队首元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。**\n>\n>\n> ***\\*priority_queue：优先队列适配器\\**，基于底层容器提供了优先队列数据结构的操作，支持在插入元素时根据优先级进行排序。默认底层容器是 vector，但也可以使用其他支持随机访问和插入操作的容器。**\n\n##### 3.stack的使用\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/8591236db69c7870d8bd8f1c680badcb.png)\n\n这些是C++[标准库](https://so.csdn.net/so/search?q=标准库&spm=1001.2101.3001.7020)中stack类的构造函数声明。stack是一个适配器容器，它可以使用不同的底层容器来实现栈的功能。这些构造函数声明提供了不同的方式来创建和初始化stack对象，可以根据需求选择合适的构造函数。 \n\n> **stack的Construct中除了构造函数，其他什么都没有，它连拷贝构造、析构都没有。这个也跟它是容器适配器有关系，因为它的成员都是自定义类型，编译器默认生成的就够用。**\n>\n> \n>\n> **stack是容器适配器以后，就开始不支持迭代器了。容器支持迭代器，容器适配器不支持迭代器。**\n>\n> \n>\n> **栈随便去遍历反而是不好的，因为要保证后进先出的性质。**\n>\n> \n>\n> **所以取数据得用top，想取下一个数据就得先pop。**\n\n##### [top](https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020)\n\nreference top(); 和 const_reference top() const; 是 C++ 标准库中 std::stack 类的成员函数之一。它们用于获取栈顶元素的引用。\n\nreference top();：返回栈顶元素的引用。如果需要修改栈顶元素，可以使用这个版本。\n\n```cpp\n#include <iostream>\n#include <stack>\n \n\t\tstack<int> m;\n \n\t\tm.push(42);\n\t\tm.push(15);\n \n\t\t// 使用 top() 获取栈顶元素\n\t\tint topElement = m.top();\n\t\tcout << \"Top element: \" << topElement << endl;\n \n\t\t// 修改栈顶元素\n\t\tm.top() = 99;\n\t\tcout << \"New top element: \" << m.top() << endl;\n \n\t\treturn 0;\n\t\n \n}\n```\n\n ![img](https://i-blog.csdnimg.cn/blog_migrate/af9dbb720d78efb612f5c4bb64dbb6ec.png)\n\n后进先出，15先出，然后修改为99，最后出99\n\n##### push\n\n**是 C++ 标准库中 `std::stack` 类的成员函数之一。它们用于将一个新的元素压入栈中。**\n\n**这两个版本的 push 函数允许你在栈顶添加新的元素。如果需要保持传入值的不变性，可以使用第一个版本；如果你想利用移动语义来避免不必要的复制，可以使用第二个版本。**\n\n```cpp\n#include<iostream>\n#include<stack>\nusing namespace std;\n \n \n\tint main() \n\t{\n\t\tstack<int> m;\n \n\t\tm.push(10); // 使用右值，将 10 压入栈中\n\t\tm.push(19);\n \n\t\tint newElement = 99;\n\t\tm.push(newElement); // 使用常量引用，将 newElement 压入栈中\n \n\t\tcout << \"Stack size: \" << m.size() << endl;\n \n\t\twhile (!m.empty())  // 遍历不能用迭代器，容器适配器不支持迭代器\n\t\t{\n\t\t\tcout << m.top() << \" \"; // 输出栈顶元素\n\t\t\tm.pop(); // 弹出栈顶元素\n\t\t}\n \n\t\treturn 0;\n\t}\n```\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/fe6f4bb4063818fce45d827a5bc7661c.png)\n\n#####  pop\n\n**`void pop();` 是 C++ 标准库中 `stack` 类的成员函数之一。它用于将栈顶元素弹出（删除）。**\n\n**这个函数没有返回值，它只是从栈中移除栈顶元素。在调用 `pop()` 函数之前，需要确保栈不为空，否则会导致未定义行为。**\n\n```cpp\n\tint main() \n\t{\n\t\tstack<int> m;\n \n\t\tm.push(10); // 使用右值，将 10 压入栈中\n\t\tm.push(19);\n\t\tm.push(29);\n \n\t\tcout << \"Stack size: \" << m.size() << endl;\n \n\t\tm.pop();\n \n\t\tcout << \"Stack new size: \" << m.size() << endl;\n \n\t\treturn 0;\n\t}\n```\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/84b16ae75feec2ff17399e8a5edab7b8.png)\n\n##### **公共成员函数**：\n\n> push(const T& x)：将传入的元素值 x 添加到底层容器的末尾，实现了入栈操作。\n>\n>\n> pop()：从底层容器的末尾删除一个元素，实现了出栈操作。\n>\n>\n> T& top() 和 const T& top() const：分别返回底层容器的末尾元素的引用（允许修改）和常量引用（只读），实现了查看栈顶元素操作。\n>\n>\n> bool empty() const：返回底层容器是否为空。\n>\n>\n> size_t size() const：返回底层容器中元素的数量。\n>\n>\n> 私有成员变量 _con：这是一个模板类的私有成员变量，用于存储实际的栈元素。其类型是根据模板参数 Container 确定的，在实例化时会被替换为具体的容器类型。\n\n### 实例(o2r函数，用于将整数n转换为基数r的字符串表示)\n\n```c++\n#include <iostream>\n#include <stack>\nusing namespace std;\n\n// 定义o2r函数，用于将整数n转换为基数r的字符串表示\nvoid o2r(int n, int r) {\n    // 使用栈来存储转换过程中的每一位数字\n    stack<char> s;\n    // base数组用于将十进制数转换为r进制的字符表示\n    char base[] = \"0123456789ABCDEF\";\n    \n    // 当n不为0时，继续转换过程\n    while (n) {\n        // 取n除以r的余数，得到当前位的值，并将其加入栈中\n        s.push(base[n % r]);\n        // 更新n为n除以r的商，继续下一位的计算\n        n = n / r;\n    }\n    \n    // 当栈不为空时，依次取出栈中的元素并输出，完成r进制数的构建\n    while (!s.empty()) {\n        cout << s.top();\n        // 取出栈顶元素后，将其从栈中移除\n        s.pop();\n    }\n    \n    // 在输出后换行，以便于阅读\n    cout << endl;\n}\n\nint main() {\n    // 示例：将10进制的255转换为16进制\n    cout << \"10进制的255转换为16进制：\" << endl;\n    o2r(255, 16); // 输出: FF\n\n    // 示例：将10进制的100转换为2进制\n    cout << \"10进制的100转换为2进制：\" << endl;\n    o2r(100, 2); // 输出: 1100100\n\n    // 示例：将10进制的1234转换为8进制\n    cout << \"10进制的1234转换为8进制：\" << endl;\n    o2r(1234, 8); // 输出: 2322\n\n    return 0;\n}\n```\n\n## 队列\n\n队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入(入队、进队)的一端称为队尾，允许删除(出队)的一端称为队头。\n\n队列中的元素除了具有线性关系外，还具有==***先进先出***==的特性\n\n### 队列的顺序存储结构及实现\n\n队列的顺序存储结构称为顺序队列。假设队列有n个元素，顺序队列把队列的所有元素存储在数组的前n个单元。如果把队头元素放在数组中下标为0的一端，则入队操作相当于追加，不需要移动元素，其时间性能为O(1)，但是出队操作的时间性能为O(n)，因为要保证剩下的n-1个元素仍然存储在数组的前n-1个单元，所有元素都要向前移动一个位置。\n\n如果放宽队列的所有元素必须存储在数组的前n个单元这一条件，就可以得到一种更为有效的存储方式。此时入队和出队操作的时间性能都是O(1)，因为没有移动任何元素。需要设置队头、队尾两个位置变量front和rear，入队时rear加1，出队时front加1，并且约定：front指向队头元素的前一个位置，rear指向队尾元素的位置。\n\n> [!NOTE]\n>\n> 这样约定的目的是方便运算，例如rear-front等于队列的长度。\n\n### 循环队列\n\n在顺序队列中，随着队列的插入和删除操作，整个队列向数组的高端移过去，从而产生了队列的“单向移动性”。当元素被插入到数组中下标最大的位置之后，数组空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫做“假溢出”\n\n解决假溢出的方法是将存储队列的数组看成是头尾相接的循环结构，这可以通过取模操作来实现，设存储队列的数组长度为QueueSize，操作语句为rear=(rear+1)%QueueSize\n\n队列的这种头尾相接的顺序存储结构称为循环队列。\n\n队空的条件是front=rear\n\n队满的条件是(rear+1)%QueueSize=front\n\n```c++\n#include <iostream>\nusing namespace std;\nconst int QueueSize=100;\ntemplate <typename DataType>\nclass CirQueue {\npublic:\n    CirQueue();//构造函数，初始化空队列\n    ~CirQueue();//析构函数\n    void EnQueue(DataType x);//入队\n    DataType DeQueue();//出队\n    DataType GetHead();//取队头元素\n    int Empty();//判断队列是否为空\nprivate:\n    DataType data[QueueSize];//存放队列元素的数组\n    int front,rear;//游标，队头和队尾指针\n};\ntemplate<typename DataType>\nCirQueue<DataType>::CirQueue() {\n    rear=front=QueueSize-1;\n}\ntemplate<typename DataType>\nCirQueue<DataType>::~CirQueue() {\n\n}\ntemplate<typename DataType>\nvoid CirQueue<DataType>::EnQueue(DataType x) {\n    if((rear+1)%QueueSize==front)throw\"上溢\";\n    rear=(rear+1)%QueueSize;//队尾指针在循环意义下加1\n    data[rear]=x;//在队尾处插入元素\n}\ntemplate<typename DataType>\nDataType CirQueue<DataType>::DeQueue() {\n    if(rear==front)throw\"下溢\";\n    front=(front+1)%QueueSize;//队头在循环意义下加1\n    return data[front];//返回出队前的队头元素\n}\ntemplate<typename DataType>\nDataType CirQueue<DataType>::GetHead() {\n    if(rear==front)throw\"下溢\";\n    return data[(front+1)%QueueSize];\n}\ntemplate<typename DataType>\nint CirQueue<DataType>::Empty() {\n    if (rear==front) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n```\n\n\n\n```c++\nint main() {\n    int x;\n    CirQueue<int> Q{};\n    Q.EnQueue(5);Q.EnQueue(8);\n    cout<<\"当前队头元素为：\"<<Q.GetHead()<<endl;\n    try {\n        x=Q.DeQueue();\n        cout<<\"执行一次出队操作，出队元素是：\"<<x<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入入队元素:\";\n        cin>>x;\n        Q.EnQueue(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(Q.Empty()==1) {\n        cout<<\"队列为空\"<<endl;\n    }\n    else {\n        cout<<\"队列非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 队列的链存储结构及实现\n\n队列的链接存储结构称为链队列，通常用单链表表示，其结点结构与单链表的结点结构相同\n\n```c++\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\n```\n\n为了使空队列和非空队列的操作一致，链队列也加上头结点；为了操作上的方便，设置队头指针指向链队列的头结点，队尾指针指向终端结点\n\n```c++\n#include <iostream>\nusing namespace std;\ntemplate<typename DataType>\nstruct Node {\n    DataType data;\n    Node<DataType>* next;\n};\ntemplate <typename DataType>\nclass LinkQueue {\npublic:\n    LinkQueue();//构造函数，初始化空队列\n    ~LinkQueue();//析构函数\n    void EnQueue(DataType x);//入队\n    DataType DeQueue();//出队\n    DataType GetHead();//取队头元素\n    int Empty();//判断队列是否为空\nprivate:\n    Node<DataType> *front,*rear;//队头和队尾指针\n};\n\ntemplate<typename DataType>\nLinkQueue<DataType>::LinkQueue() {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->next=nullptr;\n    front=rear=s;//将队头指针和队尾指针都指向头结点s\n}\ntemplate<typename DataType>\nLinkQueue<DataType>::~LinkQueue() {\n\n}\ntemplate<typename DataType>\nvoid LinkQueue<DataType>::EnQueue(DataType x) {\n    Node<DataType> *s=nullptr;\n    s=new Node<DataType>;\n    s->data=x;s->next=nullptr;\n    rear->next=s;\n    rear=s;\n}\ntemplate<typename DataType>\nDataType LinkQueue<DataType>::DeQueue() {\n    DataType x;\n    Node<DataType> *p=nullptr;\n    if(rear==front)throw\"下溢\";\n    p=front->next;x=p->data;\n    front->next=p->next;\n    if(p->next==nullptr){//出队前队列长度为1\n        rear=front;\n    }\n    delete p;\n    return x;\n}\ntemplate<typename DataType>\nDataType LinkQueue<DataType>::GetHead() {\n    return front->next->data;\n}\ntemplate<typename DataType>\nint LinkQueue<DataType>::Empty() {\n    if(front==rear) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n```\n\n```c++\nint main() {\n    int x;\n    LinkQueue<int> Q{};\n    Q.EnQueue(5);Q.EnQueue(8);\n    cout<<\"当前队头元素为：\"<<Q.GetHead()<<endl;\n    try {\n        x=Q.DeQueue();\n        cout<<\"执行一次出队操作，出队元素是：\"<<x<<endl;\n    }catch (char *str){cout<<str<<endl;}\n    try {\n        cout<<\"请输入入队元素:\";\n        cin>>x;\n        Q.EnQueue(x);\n    }catch (char *str){cout<<str<<endl;}\n    if(Q.Empty()==1) {\n        cout<<\"队列为空\"<<endl;\n    }\n    else {\n        cout<<\"队列非空\"<<endl;\n    }\n    return 0;\n}\n```\n\n### 循环队列和链队列的比较\n\n循环队列和链队列基本操作的时间复杂度均为O(1)，因此可以比较的只有空间性能。作为一般规律，当队列中元素个数变化较大时，应采用链队列，反之，应该采用循环队列，如果确定不会发生假溢出，也可以采用顺序队列\n\n## 扩展与提高\n\n### 两栈共享空间\n\n在一个程序中，如果同时使用具有相同数据类型的两个顺序栈，最直接的方法是为每个栈开辟一个数组空间，这样做的结果可能出现一个栈的空间已被占满而无法再进行插入操作，同时另一个栈的空间仍有大量剩余而没有得到利用的情况，从而造成存储空间的浪费。\n\n可以充分利用顺序栈单向延伸的特性，使用一个数组来存储两个栈，让一个栈的栈底位于该数组的始端，另一个栈的栈底位于该数组的末端，每个栈从各自的端点向中间延伸。\n\n其中，topl 和 top2分别为栈1 和栈2 的栈顶位置，StackSize 为整个数组空间的大小，栈1的底位于下标为。的一端；栈2的底位于下标为 StackSize一1 的一端。\n\n在两栈共享空间中，由于两个栈相向增长，浪费的数组空间就会减少，同时发生上溢的概率也会减少。**但是，只有当两个栈的空间需求有相反的关系时，这种方法才会奏效，也就是说，最好一个栈增长时另一个栈缩短。**下面给出两栈共享空间的类定义：\n\n```c++\nconst int StackSize=100;\ntemplate <typename DataType>\nclass BothStack {\npublic:\n    BothStack();//构造函数，将两个栈分别初始化\n    ~BothStack();\n    void Push(int i,DataType x);//入栈操作，将元素x压入栈i\n    DataType Pop(int i);//出栈操作，对栈i执行出栈操作\n    DataType GetTop(int i);//取栈i的栈顶元素\n    int Empty(int i);//判断栈i是否为空栈\nprivate:\n    DataType data[StackSize];//存放两个栈的数组\n    int top1,top2;//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标\n};\n```\n\n设整型变量i只取1和2两个值。当i=1时，表示对栈1操作；当i=2时，表示对栈2操作\n\n下面讨论两栈共享空间的入栈和出栈操作：\n\n#### 入栈\n\n当存储栈的数组中没用空闲单元时为栈满，此时栈1的栈顶元素和栈2的栈顶元素位于数组中的相邻位置，即top1=top2-1。另外，当新元素插入栈2时，栈顶位置top2不是加一而是减一\n\n```c++\ntemplate<typename DataType>\nvoid BothStack<DataType>::Push(int i, DataType x) {\n    if(top1==top2-1)throw\"上溢\";\n    if(i==1)data[++top1]=x;\n    /*即:\n    top1++;\n    data[top1] = x;\n    */\n    if(i==2)data[--top2]=x;\n    /*即:\n    top2--;\n    data[top2] = x;\n    */\n}\n```\n\n#### 出栈\n\n当top1=-1时栈1为空，当top2=StackSize时栈2为空。另外，当从栈2删除元素时，top2不是减一而是加一\n\n```c++\ntemplate<typename DataType>\nDataType BothStack<DataType>::Pop(int i) {\n    if(i==1) {\n        if(top1==-1)throw\"下溢\";\n        return data[top1--];\n    }\n    if(i==2) {\n        if(top2==StackSize)throw\"下溢\";\n        return data[top2++];\n    }\n}\n```\n\n#### 完整代码\n\n```c++\n#include<iostream>\nusing namespace std;\nconst int StackSize=100;\ntemplate <typename DataType>\nclass BothStack {\npublic:\n    BothStack();//构造函数，将两个栈分别初始化\n    ~BothStack();\n    void Push(int i,DataType x);//入栈操作，将元素x压入栈i\n    DataType Pop(int i);//出栈操作，对栈i执行出栈操作\n    DataType GetTop(int i);//取栈i的栈顶元素\n    int Empty(int i);//判断栈i是否为空栈\nprivate:\n    DataType data[StackSize];//存放两个栈的数组\n    int top1,top2;//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标\n};\ntemplate<typename DataType>\nvoid BothStack<DataType>::Push(int i, DataType x) {\n    if(top1==top2-1)throw\"上溢\";\n    if(i==1)data[++top1]=x;\n    /*即:\n    top1++;\n    data[top1] = x;\n    */\n    if(i==2)data[--top2]=x;\n    /*即:\n    top2--;\n    data[top2] = x;\n    */\n}\ntemplate<typename DataType>\nDataType BothStack<DataType>::Pop(int i) {\n    if(i==1) {\n        if(top1==-1)throw\"下溢\";\n        return data[top1--];\n    }\n    if(i==2) {\n        if(top2==StackSize)throw\"下溢\";\n        return data[top2++];\n    }\n}\n```\n\n### 双端队列\n\n#### 定义\n\n双端队列是队列的扩展，\n\n如果允许在队列的两端进行插人和删除操作，则称为双端队列；\n\n如果允许在两端插入但只允许在一端删除，则称为二进一出队列；\n\n如果只允许在一端插入但允许在两端删除，则称为一进二出队列。\n\n双端队列和普通队列一样，具有人队、出队、取队头元素等基本操作，不同的是必须指明操作的位置，其抽象数据类型定义如下：\n\n```ADT\nADT DoubleQueue\nDataModel\n\t相邻元素具有前驱和后继关系，允许在队列的两端进行插入和删除操作\nOperation\n\tInitQueue\n\t\t输入：无\n\t\t功能：初始化双端队列\n\t\t输出：一个空的双端队列\n\tDestroyQueue\n\t\t输人：无\n\t\t功能：队列的销毁\n\t\t输出：释放双端队列占用的存储空间\n\tEnQueueHead\n\t\t输入：元素值x\n\t\t功能：入队操作，将元素x插人到双端队列的队头输出：如果插入成功，双端队列的队头增加了一个元素\n\tEnQueueTail\n\t\t输人：元素值x\n\t\t功能：入队操作，将元素×插入到双端队列的队尾输出：如果插入成功，双端队列的队尾增加了一个元系\n\tDeQueueHead\n\t\t输入：无\n\t\t功能：出队操作，删除双端队列的队头元素\n\t\t输出：如果删除成功，将队头元素出队\n\tDeQueueTail\n\t\t输人：无\n\t\t功能：出队操作，删除双端队列的队尾元素输出：如果删除成功，将队尾元素出队\n\tGetHead\n\t\t输人：无\n\t\t功能：读取双端队列的队头元素\n\t\t输出：若双端队列不空，返回队头元素\n\tGetTail\n\t\t输人：无\n\t\t功能：读取双端队列的队尾元素\n\t\t输出：若双端队列不空，返回队尾元素\n\tEmpty\n\t\t输人：无\n\t\t功能：判空操作，判断双端队列是否为空输出：如果双端队列为空，返回1，否则返回0。\nendADT\n```\n\n双端队列可以采用循环队列的存储方式，基本算法可以在循环队列的基础上修改而成。不同的是，在队头入队时，先将新元素插人到 front处，再把队头位置 front 在循环意义下减1；在队尾出队时，先将 rear 处的队尾元素暂存，再把队尾位置 rear 在循环意义下减1。\n\n#### 完整代码\n\n```C++\n#include <iostream>\n#include <stdexcept>\n\n// 定义链表节点\nstruct Node {\n\tint data;\n\tNode* prev;\n\tNode* next;\n\t\n\tNode(int val) : data(val), prev(nullptr), next(nullptr) {}\n};\n\n// 双端队列类\nclass DoubleQueue {\nprivate:\n\tNode* head;\n\tNode* tail;\n\t\npublic:\n\t// 构造函数\n\tDoubleQueue() : head(nullptr), tail(nullptr) {}\n\t\n\t// 析构函数\n\t~DoubleQueue() {\n\t\tDestroyQueue();\n\t}\n\t\n\t// 初始化双端队列\n\tvoid InitQueue() {\n\t\thead = nullptr;\n\t\ttail = nullptr;\n\t}\n\t\n\t// 销毁双端队列\n\tvoid DestroyQueue() {\n\t\twhile (head != nullptr) {\n\t\t\tNode* temp = head;\n\t\t\thead = head->next;\n\t\t\tdelete temp;\n\t\t}\n\t\ttail = nullptr;\n\t}\n\t\n\t// 在队头插入元素\n\tvoid EnQueueHead(int x) {\n\t\tNode* newNode = new Node(x);\n\t\tif (head == nullptr) {\n\t\t\thead = tail = newNode;\n\t\t} else {\n\t\t\tnewNode->next = head;\n\t\t\thead->prev = newNode;\n\t\t\thead = newNode;\n\t\t}\n\t}\n\t\n\t// 在队尾插入元素\n\tvoid EnQueueTail(int x) {\n\t\tNode* newNode = new Node(x);\n\t\tif (tail == nullptr) {\n\t\t\thead = tail = newNode;\n\t\t} else {\n\t\t\tnewNode->prev = tail;\n\t\t\ttail->next = newNode;\n\t\t\ttail = newNode;\n\t\t}\n\t}\n\t\n\t// 从队头删除元素\n\tbool DeQueueHead() {\n\t\tif (head == nullptr) return false;\n\t\tNode* temp = head;\n\t\thead = head->next;\n\t\tif (head != nullptr) {\n\t\t\thead->prev = nullptr;\n\t\t} else {\n\t\t\ttail = nullptr;\n\t\t}\n\t\tdelete temp;\n\t\treturn true;\n\t}\n\t\n\t// 从队尾删除元素\n\tbool DeQueueTail() {\n\t\tif (tail == nullptr) return false;\n\t\tNode* temp = tail;\n\t\ttail = tail->prev;\n\t\tif (tail != nullptr) {\n\t\t\ttail->next = nullptr;\n\t\t} else {\n\t\t\thead = nullptr;\n\t\t}\n\t\tdelete temp;\n\t\treturn true;\n\t}\n\t\n\t// 获取队头元素\n\tint GetHead() const {\n\t\tif (head == nullptr) throw std::out_of_range(\"Queue is empty\");\n\t\treturn head->data;\n\t}\n\t\n\t// 获取队尾元素\n\tint GetTail() const {\n\t\tif (tail == nullptr) throw std::out_of_range(\"Queue is empty\");\n\t\treturn tail->data;\n\t}\n\t\n\t// 判断双端队列是否为空\n\tbool Empty() const {\n\t\treturn head == nullptr;\n\t}\n};\n\nint main() {\n\tDoubleQueue dq;\n\t\n\t// 测试操作\n\tdq.EnQueueHead(1);\n\tdq.EnQueueTail(2);\n\tdq.EnQueueHead(3);\n\t\n\tstd::cout << \"Head: \" << dq.GetHead() << \", Tail: \" << dq.GetTail() << std::endl; // 应该输出 Head: 3, Tail: 2\n\t\n\tdq.DeQueueHead();\n\tstd::cout << \"After DeQueueHead, Head: \" << dq.GetHead() << std::endl; // 应该输出 Head: 1\n\t\n\tdq.DeQueueTail();\n\tstd::cout << \"After DeQueueTail, Tail: \" << dq.GetHead() << std::endl; // 应该输出 Tail: 1\n\t\n\tstd::cout << \"Is the queue empty? \" << (dq.Empty() ? \"Yes\" : \"No\") << std::endl; // 应该输出 No\n\t\n\tdq.DeQueueHead();\n\tstd::cout << \"Is the queue empty after all elements removed? \" << (dq.Empty() ? \"Yes\" : \"No\") << std::endl; // 应该输出 Yes\n\t\n\treturn 0;\n}\n```\n\n## 应用举例\n\n### 括号匹配问题\n\n```c++\n#include<iostream>\n#include <string>\nusing namespace std;\n\nclass Matcher {\npublic:\n    Matcher(string str);\n    ~Matcher();\n    int Match();\nprivate:\n    string str;\n};\nMatcher::Matcher(string str) {\n    this->str=str;\n}\nint Matcher::Match() {\n    char S[100];\n    int i,top=-1;\n    for(i=0;str[i]!='\\0';i++) {\n        if(str[i]==')') {\n            if(top>-1)top--;\n            else return -1;\n        }\n        else if(str[i]=='(') {\n            S[++top]=str[i];\n        }\n    }\n    if(top==-1) return 0;\n    else return 1;\n}\nMatcher::~Matcher() {\n\n}\n\n\nint main() {\n    string str;\n    cout<<\"请输入一个算数表达式\";\n    cin>>str;\n    Matcher M{str};\n    int k=M.Match();\n    if(k==0) {\n        cout<<\"正确匹配\\n\";\n    }\n    else if(k==1) {\n        cout<<\"多左括号\\n\";\n    }\n    else {\n        cout<<\"多右括号\\n\";\n    }\n    return 0;\n}\n```\n\n### 表达式求值\n\n表达式求值需要根据运算符的优先级来确定计算顺序。因此，在求值过程中需要保存优先级较低的运算符以及没有参与计算的运算对象，并将当前运算符与已经扫描过的、尚未计算的运算符进行比较，以确定哪个运算符以及哪两个运算对象参与计算。这需要两个栈来辅助完成：运算对象栈 OPND 和运算符栈 OPTR。\n\n```c++\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Expression {\npublic:\n    Expression(string str);\n    ~Expression();\n    int Compute();\nprivate:\n    int Comp(char str1,char str2);\n    string str;\n};\nExpression::Expression(string str) {\n    this->str=str+\"#\";\n}\nExpression::~Expression() {\n\n}\nint Expression::Compute() {\n    char OPND[100],OPTR[100];\n    OPTR[0]='#';\n    int top1=-1,top2=0;\n    int i,k,x,y,z,op;\n    for(i=0;str[i]!='\\0';) {\n        if(str[i]>=48 && str[i]<=57) {\n            OPND[++top1]=str[i++]-48;\n        }\n        else {\n            k=Comp(str[i],OPTR[top2]);\n            if(k==1) {\n                OPTR[++top2]=str[i++];\n            }\n            else if(k==-1) {\n                y=OPND[top1--];\n                x=OPND[top1--];\n                op=OPTR[top2--];\n                switch (op) {\n                    case '+':z=x+y;break;\n                    case '-':z=x-y;break;\n                    case '*':z=x*y;break;\n                    case '/':z=x/y;break;\n                    default: break;\n                }\n                OPND[++top1]=z;\n            }\n            else {\n                top2--;\n                i++;\n            }\n        }\n    }\n    return OPND[top1];\n}\nint Expression::Comp(char str1, char str2) {\n    switch (str1) {\n        case '+':case '-':\n            if(str2=='(' || str2=='#') return 1;\n            else return -1;\n            break;\n        case '*':case '/':\n            if(str2=='*' || str2=='/') return -1;\n            else return 1;\n            break;\n        case '(':return -1;break;\n        case ')':\n            if(str2=='(') return 0;else return -1;\n            break;\n        case '#':\n            if(str2=='#') return 0;else return -1;\n            break;\n        default:\n            break;\n    }\n}\nint main() {\n    string str;\n    cout<<\"请输入一个表达式\"<<endl;\n    cin>>str;\n    Expression E{str};\n    int result=E.Compute();\n    cout<<\"表达式的值是\"<<result<<endl;\n    return 0;\n}\n```\n\n## 习题\n\n# 第四章\n\n## 字符串\n\n给定两个字符串S，T，在主串S中寻找子串T的过程称为模式匹配，T称为模式。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。\n\n### BF算法\n\nBF算法的基本思想是蛮力匹配，即从主串S的第一个字符开始和模式T的第一个字符进行比较。若相等，则继续比较两者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本趟匹配的开始位置；否则匹配失败，返回0.\n\n```c++\nint BF(char S[],char T[]){\n\tint start=0;\n\tint i=0,j=0;\n\twhile((S[i]!='\\0') && (T[i]!='\\0')){\n\t\tif(S[i]==T[i]){\n\t\t\ti++;j++;\n\t\t}\n\t\telse{\n\t\t\tstart++;\n\t\t\ti=start;j=0;\n\t\t}\n\t}\n\tif(T[j]=='\\0'){\n\t\treturn start+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n```\n\n最坏情况下的时间复杂度是O(n*m)（设主串S长度为n，模式T长度为m）\n\n### KMP算法\n\n【最浅显易懂的 KMP 算法讲解】 https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n【【天勤考研】KMP算法易懂版】 https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n【KMP算法之求next数组代码讲解】 https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\n\n## 多维数组\n\n\n\n## 矩阵压缩存储\n","slug":"DataStructures-FromConceptToCppImplementation","published":1,"updated":"2024-10-30T13:01:07.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3eo0002c0wc7tat3s3d","content":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"七桥问题\"><a href=\"#七桥问题\" class=\"headerlink\" title=\"七桥问题\"></a>七桥问题</h2><p>七桥问题是一个经典的图论问题，它是由数学家欧拉在18世纪提出的。问题的背景是哥尼斯堡（今俄罗斯的加里宁格勒）的一个地区，该地区被普雷格尔河分成四个区域，并由七座桥连接。问题是：是否有可能从某个区域出发，不重复地走过所有七座桥，并且回到起点。<br>我们可以这样求解七桥问题：</p>\n<ol>\n<li>首先，我们需要确定每个顶点（即每个城区）相关联的边数（即桥的数量）。</li>\n<li>然后，我们根据以下规则进行判定：<ul>\n<li>如果所有顶点相关联的边数都是偶数，则存在欧拉回路。</li>\n<li>如果有超过两个顶点相关联的边数是奇数，则不存在欧拉回路。</li>\n<li>如果恰好有两个顶点相关联的边数是奇数，则不存在欧拉回路，但存在一条从这两个顶点之一出发的欧拉路径（不会回到起点）。<br>对于七桥问题，我们可以将四个区域视为四个顶点，七座桥视为连接这些顶点的边。通过计算每个顶点相关联的边数，我们可以得到以下结果：</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>两个区域（顶点）各有三座桥相连，因此这两个区域相关联的边数是奇数。</li>\n<li>另外两个区域（顶点）各有两座桥相连，因此这两个区域相关联的边数是偶数。<br>根据判定规则，因为有超过两个顶点相关联的边数是奇数（具体来说，有两个顶点），所以七桥问题中不存在欧拉回路。同时，也不存在从这两个顶点之一出发的欧拉路径，因为路径要求不重复地走过所有边，而这是不可能的。<br>因此，结论是：在七桥问题中，不可能找到一条不重复地走过所有七座桥的路径，并且返回起点。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">4</span>;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EulerCircuit</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">EulerCircuit</span>(<span class=\"hljs-type\">int</span> a[][MaxSize],<span class=\"hljs-type\">int</span> n);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">oddVertexNum</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mat[MaxSize][MaxSize];<br>    <span class=\"hljs-type\">int</span> vertexNum;<br>&#125;;<br>EulerCircuit::<span class=\"hljs-built_in\">EulerCircuit</span>(<span class=\"hljs-type\">int</span> a[][MaxSize],<span class=\"hljs-type\">int</span> n)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>            mat[i][j]=a[i][j];<br>        &#125;<br>    &#125;<br>    vertexNum=n;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">EulerCircuit::oddVertexNum</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>,i,j,degree;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;vertexNum;i++)&#123;<br>        degree=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;vertexNum;j++)&#123; <span class=\"hljs-comment\">// 这里应该是 j++ 而不是 i++</span><br>            degree=degree+mat[i][j];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(degree%<span class=\"hljs-number\">2</span>!=<span class=\"hljs-number\">0</span>)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">4</span>][MaxSize]=&#123;<br>        &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>&#125;,<br>        &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>&#125;,<br>        &#123;<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;,<br>        &#123;<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;<br>    &#125;;<br>    EulerCircuit G&#123;a,<span class=\"hljs-number\">4</span>&#125;;<br>    <span class=\"hljs-type\">int</span> num=G.<span class=\"hljs-built_in\">oddVertexNum</span>();<br>    <span class=\"hljs-keyword\">if</span>(num&gt;=<span class=\"hljs-number\">2</span>)&#123;<br>        cout&lt;&lt;num&lt;&lt;<span class=\"hljs-string\">&quot;个地方通奇数桥，不存在欧拉回路&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;存在欧拉回路&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h2><p>欧几里得算法用自然语言描述如下：</p>\n<p>步骤1：将m除以n得到余数r</p>\n<p>步骤2：若r等于0，则n为最大公约数，算法结束；否则执行步骤3</p>\n<p>步骤3：将n的值放在m中，将r的值放在n中，重新执行步骤1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">ComFactor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m,<span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r=m%n;<br>    <span class=\"hljs-keyword\">while</span> (r!=<span class=\"hljs-number\">0</span>) &#123;<br>        m=n;<br>        n=r;<br>        r=m%n;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> n;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;最大公约数是&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">ComFactor</span>(<span class=\"hljs-number\">35</span>,<span class=\"hljs-number\">25</span>)&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h1><h2 id=\"线性表的定义\"><a href=\"#线性表的定义\" class=\"headerlink\" title=\"线性表的定义\"></a>线性表的定义</h2><p>线性表简称表，是n个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度，长度等于零的线性表称为空表，一个非空表通常记为：<br>$$<br>L&#x3D;(a1,a2,…,an)<br>$$<br>其中，ai称为数据元素，下角标i表示该元素在线性表中的位置或序号，称元素ai位于表的第i个位置，或称是ai是表中的第i的元素。a1称为表头元素，an称为表尾元素，任意一对相邻的数据元素a（i-1）和ai（1&lt;i&lt;&#x3D;n）之间存在序偶关系&lt;a(i-1),ai&gt;，且a(i-1)称为ai的前驱，ai称为a(i-1)的后继。在这个序列中，元素a1无前驱，元素an无后继，其他每个元素有且仅有一个前驱和一个后继</p>\n<p>线性表的基本操作包括：</p>\n<ol>\n<li><strong>初始化</strong>：创建一个空的线性表。</li>\n<li><strong>销毁</strong>：销毁线性表，释放其占用的内存空间。</li>\n<li><strong>插入</strong>：在指定位置插入一个元素。</li>\n<li><strong>删除</strong>：删除指定位置的元素。</li>\n<li><strong>查找</strong>：查找并返回指定元素的位置。</li>\n<li><strong>取值</strong>：获取指定位置的元素。</li>\n<li><strong>修改</strong>：修改指定位置的元素。</li>\n<li><strong>长度</strong>：返回线性表的长度（元素个数）。</li>\n<li><strong>判空</strong>：判断线性表是否为空。</li>\n</ol>\n<h2 id=\"线性表的顺序存储结构及实现\"><a href=\"#线性表的顺序存储结构及实现\" class=\"headerlink\" title=\"线性表的顺序存储结构及实现\"></a>线性表的顺序存储结构及实现</h2><p>线性表的顺序存储结构称为顺序表，其基本思想是用一段地址连续的存储单元依次存储线性表的数据元素</p>\n<p>设顺序表的每个元素占用c个存储单元，则第i个元素的存储地址为：<br>$$<br>Loc(ai)&#x3D;Loc(a1)+(i-1)*c<br>$$<br>顺序表中数据元素的存储地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任何一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存取结构</p>\n<p>通常用一维数组来实现顺序表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//根据实际问题具体定义</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<span class=\"hljs-comment\">//由于线性表的数据元素类型不确定，所以采用模板机制</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">SeqList</span>();<span class=\"hljs-comment\">//创建一个空的线性表</span><br>    <span class=\"hljs-built_in\">SeqList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<span class=\"hljs-comment\">//建立长度为n的顺序表</span><br>    ~<span class=\"hljs-built_in\">SeqList</span>();<span class=\"hljs-comment\">//析构函数，销毁线性表，释放其占用的内存空间</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[MaxSize];<span class=\"hljs-comment\">//存放数据元素的数组</span><br>    <span class=\"hljs-type\">int</span> length;<span class=\"hljs-comment\">//线性表的长度</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    length=<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-keyword\">if</span>(n&gt;MaxSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;参数非法&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        data[i]=a[i];<br>    &#125;<br>    length=n;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqList</span>() &#123;&#125;<span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> length==<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> length;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;length;i++) &#123;<br>        cout&lt;&lt;data[i]&lt;&lt;<span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//时间复杂度为O(1)</span><br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;查找位置非法&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> data[i<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;length;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(data[i]==x)<span class=\"hljs-keyword\">return</span> i<span class=\"hljs-number\">+1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    <span class=\"hljs-keyword\">if</span>(length==MaxSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;表满，上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length<span class=\"hljs-number\">+1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=length;j&gt;=i;j--) &#123;<br>        data[j]==data[j<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    data[i<span class=\"hljs-number\">-1</span>]=x;<br>    length++;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(length==<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;空表 下溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;删除位置错误&quot;</span>;<br>    x=data[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;length;j++) &#123;<br>        data[j<span class=\"hljs-number\">-1</span>]=data[j];<br>    &#125;<br>    length--;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    SeqList&lt;<span class=\"hljs-type\">int</span>&gt;L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线性表的链接存储结构及其实现\"><a href=\"#线性表的链接存储结构及其实现\" class=\"headerlink\" title=\"线性表的链接存储结构及其实现\"></a>线性表的链接存储结构及其实现</h2><p>单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。为了能正确表示元素之间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成了数据元素的存储映像，称为结点。</p>\n<h3 id=\"单链表的结点定义\"><a href=\"#单链表的结点定义\" class=\"headerlink\" title=\"单链表的结点定义\"></a>单链表的结点定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在使用单链表时，关心的只是数据元素以及数据元素之间的逻辑关系</p>\n<p>单链表中每个结点的存储地址存放在其前驱结点的next域中，而第一个结点无前驱，所以设头指针指向第一个元素所在结点，整个单链表的存取必须从头指针开始进行，因而头指针具有标识一个单链表的作用。最后一个元素所在结点的指针域为空。</p>\n<h3 id=\"单链表的实现\"><a href=\"#单链表的实现\" class=\"headerlink\" title=\"单链表的实现\"></a>单链表的实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt; *next;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkList</span>();<br>    <span class=\"hljs-built_in\">LinkList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">LinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *first;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkList</span>() &#123;<br>    first=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-comment\">/* nullptr是一个字面常量，表示空指针</span><br><span class=\"hljs-comment\">       它用于初始化指针变量或将其赋值给指针变量，</span><br><span class=\"hljs-comment\">       以确保指针不指向任何有效的内存地址 */</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> first-&gt;next==<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    <span class=\"hljs-comment\">//设置工作指针p依次指向各节点</span><br>    <span class=\"hljs-comment\">//p后移不能写作p++</span><br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;查找位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> p-&gt;data;<br>    &#125;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n),单链表是顺序存取结构</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;data==x) &#123;<br>            <span class=\"hljs-keyword\">return</span> count;<br>        &#125;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n)</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    Node&lt;DataType&gt; *p=first,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>        s-&gt;data=x;<br>        s-&gt;next=p-&gt;next;<br>        p-&gt;next=s;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-comment\">//头插法</span><br>    first=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>        s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>        s-&gt;data=a[i];<br>        s-&gt;next=first-&gt;next;<br>        first-&gt;next=s;<br>    &#125;<br>    <span class=\"hljs-comment\">//尾插法</span><br>    <span class=\"hljs-comment\">// first=new Node&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">// Node&lt;DataType&gt; *r=first,*s=nullptr;</span><br>    <span class=\"hljs-comment\">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class=\"hljs-comment\">//     s=new Node&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">//     s-&gt;data=a[i];</span><br>    <span class=\"hljs-comment\">//     r-&gt;next=s;</span><br>    <span class=\"hljs-comment\">//     r=s;</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// r-&gt;next=nullptr;</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    DataType x;<br>    Node&lt;DataType&gt; *p=first,*q=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span> || p-&gt;next==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;删除位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        q=p-&gt;next;<br>        x=q-&gt;data;<br>        p-&gt;next=q-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> q;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkList</span>() &#123;<br>    Node&lt;DataType&gt; *p=first;<br>    <span class=\"hljs-keyword\">while</span> (first!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        first=first-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>        p=first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    LinkList&lt;<span class=\"hljs-type\">int</span>&gt; L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><p>在单链表的每个结点中再设置一个指向其前驱结点的指针域，这样就形成了双链表</p>\n<h3 id=\"双链表的结点结构定义：\"><a href=\"#双链表的结点结构定义：\" class=\"headerlink\" title=\"双链表的结点结构定义：\"></a>双链表的结点结构定义：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Datatype&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DulNode</span> &#123;<br>    Datatype data;<br>    DulNode&lt;Datatype&gt; *prior,*next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在双链表中求表长等操作与单链表基本相同，下面讨论插入和删除操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Datatype&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DulNode</span> &#123;<br>    Datatype data;<br>    DulNode&lt;Datatype&gt; *prior,*next;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DulLinkList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">DulLinkList</span>();<br>    <span class=\"hljs-built_in\">DulLinkList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">DulLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DulNode&lt;DataType&gt; *first;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">DulLinkList</span>() &#123;<br>    first=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    first-&gt;prior=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-comment\">/* nullptr是一个字面常量，表示空指针</span><br><span class=\"hljs-comment\">       它用于初始化指针变量或将其赋值给指针变量，</span><br><span class=\"hljs-comment\">       以确保指针不指向任何有效的内存地址 */</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> first-&gt;next==<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    <span class=\"hljs-comment\">//设置工作指针p依次指向各节点</span><br>    <span class=\"hljs-comment\">//p后移不能写作p++</span><br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;查找位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> p-&gt;data;<br>    &#125;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n),单链表是顺序存取结构</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;data==x) &#123;<br>            <span class=\"hljs-keyword\">return</span> count;<br>        &#125;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n)</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    DulNode&lt;DataType&gt; *p=first,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        s=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>        s-&gt;data=x;<br>        <span class=\"hljs-comment\">//与单链表不同之处//这里</span><br>        s-&gt;prior=p;<br>        s-&gt;next=p-&gt;next;<br>        p-&gt;next-&gt;prior=s;<br>        p-&gt;next=s;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">DulLinkList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-comment\">//头插法</span><br>    first=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        DulNode&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>        s=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>        s-&gt;data=a[i];<br>        s-&gt;next=first-&gt;next;<br>        first-&gt;next=s;<br>    &#125;<br>    <span class=\"hljs-comment\">//尾插法</span><br>    <span class=\"hljs-comment\">// first=new DulNode&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">// DulNode&lt;DataType&gt; *r=first,*s=nullptr;</span><br>    <span class=\"hljs-comment\">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class=\"hljs-comment\">//     s=new DulNode&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">//     s-&gt;data=a[i];</span><br>    <span class=\"hljs-comment\">//     r-&gt;next=s;</span><br>    <span class=\"hljs-comment\">//     r=s;</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// r-&gt;next=nullptr;</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//这里</span><br>    DulNode&lt;DataType&gt; *p = first;<br>    DulNode&lt;DataType&gt; *q;<br>    <span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; count &lt; i - <span class=\"hljs-number\">1</span>) &#123;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span> || p-&gt;next == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">runtime_error</span>(<span class=\"hljs-string\">&quot;删除位置错误&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        q = p-&gt;next; <span class=\"hljs-comment\">// Save the node to be deleted</span><br>        p-&gt;next = q-&gt;next; <span class=\"hljs-comment\">// Update next of the previous node</span><br>        q-&gt;next-&gt;prior = p; <span class=\"hljs-comment\">// Update prior of the next node</span><br>        DataType x = q-&gt;data; <span class=\"hljs-comment\">// Save data to return</span><br>        <span class=\"hljs-keyword\">delete</span> q; <br>        <span class=\"hljs-keyword\">return</span> x; <br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::~<span class=\"hljs-built_in\">DulLinkList</span>() &#123;<br>    DulNode&lt;DataType&gt; *p=first;<br>    <span class=\"hljs-keyword\">while</span> (first!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        first=first-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>        p=first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    DulLinkList&lt;<span class=\"hljs-type\">int</span>&gt; L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><p>在单链表中，如果将终端结点的指针由空指针改为指向头结点，就使得整个单链表形成一个环，这种头尾相接的单链表称为循环单链表。实际应用中多采用尾指针指示的循环单链表</p>\n<p>在双链表中，如果将终端结点的后继指针由空指针改为指向头结点，将头结点的前驱指针由空指针改为指向终端结点，就使得整个双链表形成一个环，这种头尾相接的单链表称为循环双链表</p>\n<p>循环链表中没有明显的尾端，可能会使循环链表的处理操作进入死循环，通常判断用作循环变量的工作指针是否等于某一特定指针（如头指针或尾指针），以判定工作指针是否扫描了整个链表，例如可以用循环条件  <code>p!=first</code>  判断工作指针是否扫描了整个链表</p>\n<h2 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h2><h3 id=\"1-时间性能比较\"><a href=\"#1-时间性能比较\" class=\"headerlink\" title=\"1.时间性能比较\"></a>1.时间性能比较</h3><p>所谓时间性能是指基某种存储结构的基本操作（即算法）的时间复杂度。</p>\n<p><strong>随机访问</strong></p>\n<ul>\n<li><strong>顺序表</strong>：能够直接定位到任意位置，实现快速访问，时间复杂度为 O(1)。</li>\n<li><strong>链表</strong>：必须从头部开始遍历至目标位置，平均时间复杂度为 O(n)。</li>\n</ul>\n<p><strong>插入与删除</strong></p>\n<ul>\n<li><strong>链表</strong>：一旦拥有指向目标位置的指针，插入或删除操作无需移动其他元素，时间复杂度为 O(1)。</li>\n<li><strong>顺序表</strong>：插入或删除元素需要调整后续所有元素的位置，平均时间复杂度为 O(n)，尤其是当元素数量大或每个元素占用较大存储空间时，移动元素的成本显著增加。</li>\n</ul>\n<p><strong>一般来说</strong></p>\n<ul>\n<li>当线性表的主要操作是<strong>频繁查找</strong>且<strong>插入和删除较少</strong>，或操作依赖于<strong>数据元素的绝对位置</strong>时，<strong>顺序表</strong>是更优的选择。</li>\n<li>若线性表中<strong>频繁执行插入和删除操作</strong>，<strong>链表</strong>则提供更好的性能。</li>\n</ul>\n<h3 id=\"2-空间性能比较\"><a href=\"#2-空间性能比较\" class=\"headerlink\" title=\"2.空间性能比较\"></a>2.空间性能比较</h3><p>所谓空间性能是指某种存储结构所占用的存储空间的大小。</p>\n<ul>\n<li><strong>存储特性</strong><ul>\n<li><strong>顺序表</strong>: 每个结点仅包含数据元素，存储密度高，空间利用率好。</li>\n<li><strong>链表</strong>: 结点包含数据元素和指针，指针增加结构开销，降低存储密度。</li>\n</ul>\n</li>\n<li><strong>空间分配</strong><ul>\n<li><strong>顺序表</strong>: 需预分配固定大小空间，可能造成浪费（分配过多）或上溢（分配不足）。</li>\n<li><strong>链表</strong>: 动态分配，元素数量不受限，只要系统有可用内存。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong><ul>\n<li><strong>顺序表</strong>: 适合已知大致长度的线性表，以优化空间效率。</li>\n<li><strong>链表</strong>: 更适用于元素数量变化大或未知的情况。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"扩展与提高\"><a href=\"#扩展与提高\" class=\"headerlink\" title=\"扩展与提高\"></a>扩展与提高</h2><h3 id=\"线性表的静态链表存储\"><a href=\"#线性表的静态链表存储\" class=\"headerlink\" title=\"线性表的静态链表存储\"></a>线性表的静态链表存储</h3><p>静态链表用数组来表示链表。由于是利用数组定义的链表，属于静态存储分配，因此叫静态链表。最常用的是静态单链表。</p>\n<p>avail是空闲链表（全部由空闲数组单元组成的单链表）头指针，first是静态链表头指针，为了运算方便通常静态链表也带头指针。</p>\n<p><strong>静态链表的数组元素定义：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DateType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SNode</span> &#123;<br>    DateType data;<br>    <span class=\"hljs-type\">int</span> next;<span class=\"hljs-comment\">//指针域(也称游标),注意不是指针类型</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>静态链表的定义：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">StaList</span>();<br>    <span class=\"hljs-built_in\">StaList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">StaList</span>();<br>    <span class=\"hljs-comment\">//与单链表成员函数相同</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    SNode&lt;DataType&gt; SList[MaxSize];<br>    <span class=\"hljs-type\">int</span> first,avail;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>静态链表采用静态存储分配，因此析构函数为空，求表长等操作的实现基本与单链表相同，下面讨论<strong>插入和删除</strong>操作</p>\n<p>在静态链表中进行插入操作，首先从空闲链的最前端摘下一个结点，将该结点插入静态链表中，假设新结点插在结点p的后面，则修改指针的操作为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">s=avail;<br>avail=SList[avail].next;<br>SList[s].data=x;<br>SList[s].next=SList[p].next;<br>SList[p].next=s;<br></code></pre></td></tr></table></figure>\n\n<p>在静态链表中进行删除操作，首先将被删除结点从静态链表中摘下，再插入空闲链的最前端，假设要删除结点p的后继结点，则修改指针的操作为：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">q</span><span class=\"hljs-operator\">=</span>SList[p].next<span class=\"hljs-comment\">;</span><br>SList[p].next<span class=\"hljs-operator\">=</span>SList[q].next<span class=\"hljs-comment\">;</span><br>SList[q].next<span class=\"hljs-operator\">=</span>avail<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">avail</span><span class=\"hljs-operator\">=</span>q<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"顺序表的动态分配方式\"><a href=\"#顺序表的动态分配方式\" class=\"headerlink\" title=\"顺序表的动态分配方式\"></a>顺序表的动态分配方式</h3><p>顺序表的动态分配方式是在程序执行过程中通过动态存储分配，一旦数组空间占满，另外再分配一块更大的存储空间，用来替换原来的存储空间，从而达到扩充数组空间的目的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> InitSize=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//顺序表的初始长度</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> IncreSize=<span class=\"hljs-number\">10</span>;<span class=\"hljs-comment\">//顺序表存储空间每次扩展的长度</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//与顺序表的静态分配相同</span><br>    <span class=\"hljs-built_in\">SeqList</span>();<br>    <span class=\"hljs-built_in\">SeqList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">SeqList</span>();<br>    <span class=\"hljs-comment\">//与单链表成员函数相同</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType *data;<span class=\"hljs-comment\">//动态申请数组空间的首地址</span><br>    <span class=\"hljs-type\">int</span> maxSize;<span class=\"hljs-comment\">//当前数组空间的最大长度</span><br>    <span class=\"hljs-type\">int</span> length;<span class=\"hljs-comment\">//线性表的长度</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在顺序表的动态分配方式下，求线性表的长度等操作与顺序表的静态分配方式相同，下面讨论其他基本操作的实现</p>\n<h4 id=\"无参构造函数——初始化顺序表：\"><a href=\"#无参构造函数——初始化顺序表：\" class=\"headerlink\" title=\"无参构造函数——初始化顺序表：\"></a>无参构造函数——初始化顺序表：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    data=<span class=\"hljs-keyword\">new</span> DataType[InitSize];<br>    maxSize=InitSize;<br>    length=<span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"有参构造函数——建立顺序表：\"><a href=\"#有参构造函数——建立顺序表：\" class=\"headerlink\" title=\"有参构造函数——建立顺序表：\"></a>有参构造函数——建立顺序表：</h4><p>建立一个长度为<em>n</em>的顺序表需要申请长度大于n的存储空间，一般是当前线性表长度两倍的存储空间：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    data=<span class=\"hljs-keyword\">new</span> DataType[<span class=\"hljs-number\">2</span>*n];<br>    maxSize=<span class=\"hljs-number\">2</span>*n;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        data[i]=a[i];<br>    &#125;<br>    length=n;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"析构函数——销毁顺序表\"><a href=\"#析构函数——销毁顺序表\" class=\"headerlink\" title=\"析构函数——销毁顺序表\"></a>析构函数——销毁顺序表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    <span class=\"hljs-keyword\">delete</span>[] data;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 在序列的第i个位置插入元素x</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-comment\">// 检查插入位置是否合法</span><br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length<span class=\"hljs-number\">+1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误!&quot;</span>;<br>    <span class=\"hljs-comment\">// 检查序列是否已满</span><br>    <span class=\"hljs-keyword\">if</span>(length==maxSize) &#123;<br>        <span class=\"hljs-comment\">// 发生上溢,扩充存储空间</span><br>        DataType *oldData=data;<br>        maxSize+=IncreSize;<br>        data=<span class=\"hljs-keyword\">new</span> DataType[maxSize];<br>        <span class=\"hljs-comment\">// 将旧数据复制到新数组</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;length;j++) &#123;<br>            data[j]=oldData[j];<br>        &#125;<br>        <span class=\"hljs-comment\">// 释放旧数组的内存</span><br>        <span class=\"hljs-keyword\">delete</span>[] oldData;<br>    &#125;<br>    <span class=\"hljs-comment\">// 为新元素腾出空间</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=length;j&gt;=i;j--) &#123;<br>        data[j]=data[j<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    <span class=\"hljs-comment\">// 插入新元素</span><br>    data[i<span class=\"hljs-number\">-1</span>]=x;<br>    <span class=\"hljs-comment\">// 更新序列长度</span><br>    length++;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><h3 id=\"约瑟夫环问题\"><a href=\"#约瑟夫环问题\" class=\"headerlink\" title=\"约瑟夫环问题\"></a>约瑟夫环问题</h3><p>由于约瑟夫环问题本身具有循环性质，考虑采用循环单链表。求解约瑟夫环的问题的基本思路是：设置一个计数器count和工作指针p，当计数器累加到m时删除结点p。为了统一对链表中任意结点进行计数和删除操作，循环单链表不带头结点；为了便于删除操作设两个工作指针pre和p，指针pre指向p的前驱结点；为了使计数器从1开始奇数，采用尾指针指示的循环单链表，将指针pre初始化为指向终端结点，将指针p初始化为开始结点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<span class=\"hljs-comment\">//约瑟夫环的结点定义</span><br>    <span class=\"hljs-type\">int</span> data;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *next;<br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JosephRing</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">JosephRing</span>(<span class=\"hljs-type\">int</span> n);<span class=\"hljs-comment\">//构造函数，初始化n个结点的循环单链表</span><br>    ~<span class=\"hljs-built_in\">JosephRing</span>();<span class=\"hljs-comment\">//析构函数，类似单链表的析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span></span>;<span class=\"hljs-comment\">//为m，打印出环的顺序</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node *rear;<br>&#125;;<br>JosephRing::~<span class=\"hljs-built_in\">JosephRing</span>() &#123;<br>    <br>&#125;<br>JosephRing::<span class=\"hljs-built_in\">JosephRing</span>(<span class=\"hljs-type\">int</span> n) &#123;<br>    Node *s=<span class=\"hljs-literal\">nullptr</span>;<br>    rear=<span class=\"hljs-keyword\">new</span> Node;<br>    rear-&gt;data=<span class=\"hljs-number\">1</span>;rear-&gt;next=rear;<span class=\"hljs-comment\">//建立长度为1的循环单链表</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<span class=\"hljs-comment\">//依次插入数据域为2、3...n的结点</span><br>        s=<span class=\"hljs-keyword\">new</span> Node;<br>        s-&gt;data=i;<br>        s-&gt;next=rear-&gt;next;<span class=\"hljs-comment\">//将结点s插入尾结点rear的后面</span><br>        rear-&gt;next=s;<br>        rear=s;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">JosephRing::Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span> </span>&#123;<br>    Node *pre=rear,*p=rear-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;出环的顺序是:&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (p-&gt;next!=p) &#123;<br>        <span class=\"hljs-keyword\">if</span>(count&lt;m) &#123;<br>            pre=p;p=p-&gt;next;<br>            count++;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot;\\t&quot;</span>;<br>            pre-&gt;next=p-&gt;next;<span class=\"hljs-comment\">//将p摘链</span><br>            <span class=\"hljs-keyword\">delete</span> p;<br>            p=pre-&gt;next;<span class=\"hljs-comment\">//工作指针p后移，但pre不动</span><br>            count=<span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot;\\t&quot;</span>;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n,m;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入约瑟夫环的长度：&quot;</span>;<br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入密码：&quot;</span>;<br>    cin&gt;&gt;m;<br>    JosephRing R&#123;n&#125;;<br>    R.<span class=\"hljs-built_in\">Joseph</span>(m);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"一元多项式求和\"><a href=\"#一元多项式求和\" class=\"headerlink\" title=\"一元多项式求和\"></a>一元多项式求和</h3><p>若相加的某两项的指数不等，则两项应分别加在结果中，将引起线性表的插入；若某两项的指数相等，则系数相加，若相加结果为零，将引起线性表的删除。由于在线性表的合并过程中需要频繁地执行插入和删除操作，因此考虑采取单链表存储。</p>\n<p>在表示一元多项式的单链表中，每一个非零项对应单链表中的一个结点，且单链表应按指数递增有序排列。</p>\n<p>其中，coef 为系数域，存放非零项的系数；exp为指数域，存放非零项的指数；next 为指针域，存放指向下一结点的指针。</p>\n<p>下面分析一元多项式求和的执行过程。</p>\n<p>设单链表A和B分别存储两个多项式，求和结果存储在单链表 A 中，设两个工作指针p和q分别指向两个单链表的开始结点。</p>\n<p>两个多项式求和实质上是对结点p的指数域和结点q的指数域进行比较，有下列三种情况：</p>\n<p>① 若p一&gt;exp 小于q一&gt;exp，则结点p应为结果链表中的一个结点，将指针p后移</p>\n<p>② 若p-&gt;exp大于q一＞exp，则结点q应为结果中的一个结点，将q插入到第一个单链表中结点P之前，并将指针q指向单链表B中的下一个结点。为此，在单链表A 中应该设置两个工作指针 pre 和p，使得pre 指向p的前驱结点。</p>\n<p>③ 若p-&gt;exp等于q-&gt;exp，则p与q所指为同类项，将q的系数加到p的系数上。若相加结果不为0，则将指针P后移，并删除结点q，为此，在单链表B中应该设置两个工作指针 qre 和q，使得gre 指向q的前驱结点；若相加结果为0，则表明结果中无此项，删除结点p和结点 q，并将指针p 和指针q分别后移。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    <span class=\"hljs-type\">int</span> coef,exp;<br>    Node *next;<br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Polynomial</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Polynomial</span>();<br>    <span class=\"hljs-built_in\">Polynomial</span>(<span class=\"hljs-type\">const</span> Polynomial &amp;B);<span class=\"hljs-comment\">//拷贝构造函数</span><br>    <span class=\"hljs-comment\">/*拷贝构造函数是C++中一种特殊的构造函数，用于创建一个对象作为已存在对象的副本</span><br><span class=\"hljs-comment\">    这种构造函数的名称与类名相同，形式参数只有一个，即该类的引用类型的对象.</span><br><span class=\"hljs-comment\">    通常，这个形参会被声明为const，以确保在构造过程中不会修改原对象.</span><br><span class=\"hljs-comment\">    拷贝构造函数的主要应用场景包括，当一个对象作为值传递的参数传递给函数，</span><br><span class=\"hljs-comment\">    或者函数返回一个对象时，都需要调用到拷贝构造函数*/</span><br>    ~<span class=\"hljs-built_in\">Polynomial</span>();<br>    Polynomial <span class=\"hljs-keyword\">operator</span>+(Polynomial &amp;B);<span class=\"hljs-comment\">//重载运算符,多项式相加</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    Node *first;<span class=\"hljs-comment\">//一元多项式单链表的头指针</span><br>&#125;;<br><br>Polynomial::<span class=\"hljs-built_in\">Polynomial</span>() &#123;<br>    Node *r=<span class=\"hljs-literal\">nullptr</span>,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> coef,exp;<br>    first=<span class=\"hljs-keyword\">new</span> Node;<span class=\"hljs-comment\">//申请头结点</span><br>    r=first;<span class=\"hljs-comment\">//尾插法建立单链表</span><br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入系数和指数&quot;</span>;<br>    cin&gt;&gt;coef&gt;&gt;exp;<br>    <span class=\"hljs-keyword\">while</span> (coef!=<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//循环结束的条件是输入系数为0</span><br>        s=<span class=\"hljs-keyword\">new</span> Node;<br>        s-&gt;coef=coef;s-&gt;exp=exp;<br>        r-&gt;next=s;r=s;<span class=\"hljs-comment\">//将结点s插入单链表的尾部</span><br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入系数和指数&quot;</span>;<br>        cin&gt;&gt;coef&gt;&gt;exp;<br>    &#125;<br>    r-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>&#125;<br>Polynomial::<span class=\"hljs-built_in\">Polynomial</span>(<span class=\"hljs-type\">const</span> Polynomial &amp;B) &#123;<br>    first=B.first;<br>&#125;<br>Polynomial::~<span class=\"hljs-built_in\">Polynomial</span>() &#123;<br><br>&#125;<br>Polynomial Polynomial::<span class=\"hljs-keyword\">operator</span>+(Polynomial &amp;B) &#123;<br>    Node *pre=first,*p=pre-&gt;next;<span class=\"hljs-comment\">//工作指针pre和p初始化</span><br>    Node *qre=B.first,*q=qre-&gt;next;<span class=\"hljs-comment\">//工作指针qre和q初始化</span><br>    Node *qtemp=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; q!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;exp &lt; q-&gt;exp) &#123;<span class=\"hljs-comment\">//第1种情况</span><br>            pre=p;p=p-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(p-&gt;exp &gt; q-&gt;exp) &#123;<span class=\"hljs-comment\">//第2种情况</span><br>            qtemp=q-&gt;next;<br>            pre-&gt;next=q;<span class=\"hljs-comment\">//将结点q插入到结点p之前</span><br>            q-&gt;next=p;<br>            pre=q;<br>            q=qtemp;<br>            qre-&gt;next=q;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//第3种情况</span><br>            p-&gt;coef=p-&gt;coef+q-&gt;coef;<br>            <span class=\"hljs-keyword\">if</span>(p-&gt;coef==<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//系数相加为0,则删除结点p</span><br>                pre-&gt;next=p-&gt;next;<br>                <span class=\"hljs-keyword\">delete</span> p;<br>                p=pre-&gt;next;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                pre=p;<br>                p=p-&gt;next;<br>            &#125;<br>            qre-&gt;next=q-&gt;next;<span class=\"hljs-comment\">//第3种情况都要删除结点q</span><br>            <span class=\"hljs-keyword\">delete</span> q;<br>            q=qre-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(q!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        pre-&gt;next=q;<span class=\"hljs-comment\">//将结点q链接到第一个单链表的后面</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Polynomial::Print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Node *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">if</span>(p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<span class=\"hljs-comment\">//输出第一项</span><br>        cout&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>    &#125;<br>    p=p-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;coef&gt;<span class=\"hljs-number\">0</span>) &#123;<br>            cout&lt;&lt;<span class=\"hljs-string\">&quot;+&quot;</span>&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            cout&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>        &#125;<br>        p=p-&gt;next;<br>    &#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Polynomial A&#123;&#125;,B&#123;&#125;;<br>    A.<span class=\"hljs-built_in\">Print</span>();<br>    B.<span class=\"hljs-built_in\">Print</span>();<br>    A=A+B;<span class=\"hljs-comment\">//运算符重载，对象赋值调用拷贝构造函数</span><br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;结果是：&quot;</span>;<br>    A.<span class=\"hljs-built_in\">Print</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight parser3\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs parser3\"><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">7</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">12</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">3</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">-2</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">8</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">5</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">12</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">0</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">4</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">1</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">6</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">3</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">2</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">8</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">5</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">20</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">7</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">0</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^0</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">12</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3-2x</span><span class=\"hljs-keyword\">^8</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^12</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-number\">4</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^1</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">6</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">2</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^8</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^20</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">结果是：</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^0</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">4</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^1</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">18</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^12</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^20</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">进程已结束，退出代码为 </span><span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"思想火花\"><a href=\"#思想火花\" class=\"headerlink\" title=\"思想火花\"></a>思想火花</h2><p> <strong>实验问题：</strong></p>\n<p>  将一个具有n个元素的数组向左循环移动i个位置。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>如图1 数组元素循环左移1位：</p>\n<p><img src=\"/img%5C1485495-20190604181312769-273893486.png\" alt=\"数组元素循环左移1位\"></p>\n<p>将一个具有n个元素的数组向左循环移动i个位置，<strong>意味着将数组的前i个元素移动到数组的末尾，而原数组中的其余元素则相应地向左移动</strong></p>\n</blockquote>\n<p> 有许多应用程序会调用这个问题的算法，例如在文本编辑器中移动行的操作，磁盘整理时交换两个不同大小的相邻内存块等。所以，这个问题的算法要求有较高的时间和空间性能。 </p>\n<p><strong>基本要求：</strong></p>\n<p>  ⑴在原数组中实现循环右移，不另外申请空间；</p>\n<p>  ⑵时间性能尽可能好；</p>\n<p>   ⑶分析算法的时间复杂度。</p>\n<p> 要在不另申请空间的情况下，保证算法的时间性能尽可能好，如果先设计一个函数将数组向左移动一位，然后再调用该算法i次，是一些人通常想到的方法，但显然这个算法的时间性能不是最好的。要在有限的资源中解决这个问题，似乎比较困难，是否存在这种既不另申请存储空间，又能够达到最好时间性能的完美算法呢。</p>\n<p>  <strong>求解步骤：</strong></p>\n<p>1）可以通过下面的方法解决这个问题：先将数组中的前i个元素存放在一个临时数组中，再将余下的n-i个元素左移i个位置， 最后将前i个元素从临时数组复制回原数组中后面的位置。但是这个算法使用了i个额外的存储单元，使得空间性能降低。</p>\n<p>2）如上所述，先设计一个函数将数组向左循环移动一个位置，然后再调用该算法i次， 显然，这个算法的时间性能不好。 </p>\n<p> 3）现在我们换一个角度看这个问题： 将这个问题看作是把数组ab转换成数组ba（a代表数组的前i个元素，b代表数组中余下的n-i个元素）， 先将a逆置得到ar b，再将b逆置得到ar br，最后将整个ar br逆置得到(ar br)r&#x3D;ba。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>数组元素逆置是指将数组中的元素按照相反的顺序重新排列，即第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，以此类推，直到所有元素都逆序排列完毕</strong>。</p>\n</blockquote>\n<p>设Reverse函数执行将数组元素逆置的操作， 对abcdefgh向左循环移动3个位置的过程如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">Reverse</span>(<span class=\"hljs-number\">0</span>, i-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到cbadefgh(逆置abc)</span><br><span class=\"hljs-built_in\">Reverse</span>(i, n-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到cbahgfed(逆置defgh)</span><br><span class=\"hljs-built_in\">Reverse</span>(<span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到defghabc(逆置cbahgfed)</span><br></code></pre></td></tr></table></figure>\n\n<p>其原理可以用一个简单的游戏来理解：将两手的掌心对着自己，左手在右手上面， 可以实现将一个具有10 个元素的数组向左循环移动5位，如图所示。</p>\n<p><img src=\"/img%5C1358339139_6806.jpg\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">reverseArr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> start,<span class=\"hljs-type\">int</span> rear)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=start,j=rear;i&lt;j;i++,j--) &#123;<br>        <span class=\"hljs-type\">int</span> t=A[i];<br>        A[i]=A[j];<br>        A[j]=t;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">leftCir</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> k)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(k&lt;=<span class=\"hljs-number\">0</span> || k&gt;=n)<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;ERROR&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,<span class=\"hljs-number\">0</span>,k<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,k,n<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,<span class=\"hljs-number\">0</span>,n<span class=\"hljs-number\">-1</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> n)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;++i)<br>        cout&lt;&lt;A[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n,p;<br>    cin&gt;&gt;n&gt;&gt;p;<br>    <span class=\"hljs-type\">int</span> a[n];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;++i)<br>        cin&gt;&gt;a[i];<br>    <span class=\"hljs-built_in\">leftCir</span>(a,n,p);<br>    <span class=\"hljs-built_in\">show</span>(a,n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该算法在时间和空间上都很有效，并且是这么简短和简单，想出错都很难。 Brian Kernighan在Software Tools in Pascal中使用了这个算法在文本编辑器中移动各行。</p>\n<p><a href=\"https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal\">Software tools in Pascal by Brian W. Kernighan | 开放图书馆 (openlibrary.org)</a></p>\n<blockquote>\n<p>Brian Kernighan 在他的著作 <em>Software Tools in Pascal</em> 中，讨论了一个将 n 个元素的数组向左循环移动 i 个位置的算法。原文如下：</p>\n<p>“To rotate an array left by i positions, reverse the first i elements, then reverse the remaining n-i elements, and finally reverse the entire array.”</p>\n<p>翻译过来大致是：</p>\n<p>“要将一个数组向左循环移动 i 个位置，首先反转数组的前 i 个元素，然后反转剩下的 n-i 个元素，最后反转整个数组。”</p>\n<p>这种方法基于三个步骤的反转操作，可以高效地完成数组的左循环移动。</p>\n</blockquote>\n<p>作为一个规律，一个好的算法是反复努力和重新修正的结果，即使足够幸运地得到了一个貌似完美的算法思想， 我们也应该尝试着改进它。 </p>\n<h2 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h2><h1 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈是限定仅在表的一段进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>插入元素——入栈、进栈、压栈</p>\n<p>删除元素——出栈、弹栈</p>\n</blockquote>\n<p>栈中元素除了具有线性关系外，还具有***&#x3D;&#x3D;后进先出&#x3D;&#x3D;***的特性</p>\n<p>栈的顺序存储结构称为顺序栈，本质上是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底</p>\n<p>通常把数组中下标为0的一段作为栈底，同时附设变量top指示栈顶元素在数组中的位置</p>\n<p>设存储栈的数组长度为StackSize，则栈空时栈顶位置top&#x3D;-1；栈满时栈顶位置top&#x3D;StackSize-1</p>\n<blockquote>\n<p>[!TIP]</p>\n<p>在有些教程中，将top指向栈中第一个空闲位置，如果这样的话，空栈应该表示为top&#x3D;0</p>\n</blockquote>\n<p>入栈时，栈顶位置top加1；出栈时，栈顶位置top减1</p>\n<h3 id=\"顺序栈的实现\"><a href=\"#顺序栈的实现\" class=\"headerlink\" title=\"顺序栈的实现\"></a>顺序栈的实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">10</span>;<span class=\"hljs-comment\">//</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">SeqStack</span>();<span class=\"hljs-comment\">//初始化一个空栈</span><br>    ~<span class=\"hljs-built_in\">SeqStack</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x入栈</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出栈操作，将栈顶元素弹出</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取栈顶元素(并不删除)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断栈是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<br>    <span class=\"hljs-type\">int</span> top;<span class=\"hljs-comment\">//栈顶元素在数组中的下标</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqStack</span>() &#123;<br>    top=<span class=\"hljs-number\">-1</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqStack&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqStack</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==StackSize<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    data[++top]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top++;</span><br><span class=\"hljs-comment\">    s[top] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>() &#123;<br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    x=data[top--];<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    x=data[top];</span><br><span class=\"hljs-comment\">    top--;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">GetTop</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> data[top];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    SeqStack&lt;<span class=\"hljs-type\">int</span>&gt; S&#123;&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;对15和10入栈&quot;</span>;<br>    S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">15</span>);S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">10</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前栈顶元素为:&quot;</span>&lt;&lt;S.<span class=\"hljs-built_in\">GetTop</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=S.<span class=\"hljs-built_in\">Pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;出栈&quot;</span>&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入待入栈元素&quot;</span>;<br>        cin&gt;&gt;x;<br>        S.<span class=\"hljs-built_in\">Push</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(S.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"栈的链接存储结构及实现\"><a href=\"#栈的链接存储结构及实现\" class=\"headerlink\" title=\"栈的链接存储结构及实现\"></a>栈的链接存储结构及实现</h3><p>栈的链接存储结构称为链栈，通常用单链表表示，其节点结构与单链表的结点结构相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>因为只能在栈顶执行入栈(插入)和出栈(删除)操作，所以以单链表的头部做栈顶是最方便的，而且没有必要像单链表那样为了运算方便附加头结点</p>\n<blockquote>\n<p>[!TIP]</p>\n<p>在单链表中，如果我们将头部用作栈顶（top），那么入栈和出栈操作都会非常高效，这是因为单链表的特性允许我们在头部进行 O(1) 时间复杂度的操作。</p>\n<p>具体来说，有以下几点原因：</p>\n<ol>\n<li><strong>插入操作</strong>：当我们需要向栈中添加一个元素时（即入栈操作），我们只需要创建一个新的节点，并让它指向当前的头部（即当前栈顶），然后更新头部指针指向这个新节点。这样的操作不需要遍历整个链表来找到插入位置，因此时间复杂度为 O(1)。</li>\n<li><strong>删除操作</strong>：当我们需要从栈中移除一个元素时（即出栈操作），我们只需改变头部指针，让它指向原来的头部所指向的下一个节点，并释放原来的头部节点即可。这也同样是一个 O(1) 的操作。</li>\n<li><strong>访问栈顶元素</strong>：由于头部就是栈顶，访问栈顶元素也仅需要返回头部指针指向的节点的数据，这也是 O(1) 的操作。</li>\n</ol>\n<p>关于是否需要附加头结点（dummy head）的问题，通常情况下，如果单链表只用于实现栈的功能，并且不需要支持其他额外操作（比如查找特定元素等），那么就没有必要设置一个额外的头结点。因为所有的操作都在头部进行，直接将头部视为栈顶已经足够高效了。</p>\n</blockquote>\n<p>时间复杂度 —— O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkStack</span>();<br>    ~<span class=\"hljs-built_in\">LinkStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x入栈</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出栈操作，将栈顶元素弹出</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取栈顶元素(并不删除)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断栈是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *top;<span class=\"hljs-comment\">//栈顶指针即链栈的头指针</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkStack</span>() &#123;<br>    top=<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkStack&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkStack</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;data=x;<br>    s-&gt;next=top;<br>    top=s;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>() &#123;<br>    Node&lt;DataType&gt; *p=<span class=\"hljs-literal\">nullptr</span>;<br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    x=top-&gt;data;<br>    p=top;<br>    top=top-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">GetTop</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> top-&gt;data;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    LinkStack&lt;<span class=\"hljs-type\">int</span>&gt; S&#123;&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;对15和10入栈&quot;</span>;<br>    S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">15</span>);S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">10</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前栈顶元素为:&quot;</span>&lt;&lt;S.<span class=\"hljs-built_in\">GetTop</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=S.<span class=\"hljs-built_in\">Pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;出栈&quot;</span>&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入待入栈元素&quot;</span>;<br>        cin&gt;&gt;x;<br>        S.<span class=\"hljs-built_in\">Push</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(S.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"顺序栈和链栈的比较\"><a href=\"#顺序栈和链栈的比较\" class=\"headerlink\" title=\"顺序栈和链栈的比较\"></a>顺序栈和链栈的比较</h3><p>作为一般规律，当栈的使用过程中元素变化较大时，应该采用链栈，反之，应使用顺序栈</p>\n<h3 id=\"STL中的栈\"><a href=\"#STL中的栈\" class=\"headerlink\" title=\"STL中的栈\"></a>STL中的栈</h3><p>C++ Stack(堆栈) 是一个容器类的改编，为程序员提供了堆栈的全部功能，–也就是说实现了一个先进后出(FILO)的数据结构。</p>\n<p>栈stack的头文件为:</p>\n<p>#include <stack></p>\n<h4 id=\"c-stl栈stack的成员函数介绍\"><a href=\"#c-stl栈stack的成员函数介绍\" class=\"headerlink\" title=\"c++ stl栈stack的成员函数介绍\"></a>c++ stl栈stack的成员函数介绍</h4><p>操作   比较和分配堆栈</p>\n<p>empty()堆栈为空则返回真</p>\n<p>pop()移除栈顶元素(删除)</p>\n<p>push()在栈顶增加元素(增加)</p>\n<p>size() 返回栈中元素数目</p>\n<p>top() 返回栈顶元素，不删除(获取)</p>\n<h5 id=\"1-什么是stack\"><a href=\"#1-什么是stack\" class=\"headerlink\" title=\"1.什么是stack\"></a>1.什么是<a href=\"https://so.csdn.net/so/search?q=stack&spm=1001.2101.3001.7020\">stack</a></h5><p><strong>1. stack</strong>是一种<strong>容器适配器</strong>，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。**(后进先出)**</p>\n<p><strong>2. stack</strong>是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。</p>\n<p><strong>3. stack</strong>的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下</p>\n<p><strong>操作：</strong></p>\n<blockquote>\n<p><strong>empty：判空操作</strong></p>\n<p><strong>back：获取尾部元素操作</strong></p>\n<p><strong>push_back：尾部插入元素操作</strong></p>\n<p><strong>pop_back：尾部删除元素操作</strong></p>\n</blockquote>\n<p><strong>4.</strong> 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/667251d46c039b39d506132e9fa06b51.png\" alt=\"img\"></p>\n<h5 id=\"2-容器适配器\"><a href=\"#2-容器适配器\" class=\"headerlink\" title=\"2.容器适配器\"></a>2.容器适配器</h5><p><strong>容器适配器（Container Adapters）是 C++ 标准库提供的一种数据结构，它们基于现有的容器类型，提供了特定的接口和功能，以便更方便地实现某些特定的数据结构和算法</strong>。容器适配器本质上是对底层容器的封装，提供了不同的数据访问方式，使它们适用于特定的用途。 </p>\n<p><strong>标准库中提供了三种常用的容器适配器：</strong></p>\n<blockquote>\n<p>**<em>*stack：栈适配器*<em>，基于底层容器提供了栈数据结构的操作，如压入（push）、弹出（pop）、查看栈顶元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。</em></em></p>\n<p>**<em>*queue：队列适配器*<em>，基于底层容器提供了队列数据结构的操作，如入队（push）、出队（pop）、查看队首元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。</em></em></p>\n<p>**<em>*priority_queue：优先队列适配器*<em>，基于底层容器提供了优先队列数据结构的操作，支持在插入元素时根据优先级进行排序。默认底层容器是 vector，但也可以使用其他支持随机访问和插入操作的容器。</em></em></p>\n</blockquote>\n<h5 id=\"3-stack的使用\"><a href=\"#3-stack的使用\" class=\"headerlink\" title=\"3.stack的使用\"></a>3.stack的使用</h5><p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8591236db69c7870d8bd8f1c680badcb.png\" alt=\"img\"></p>\n<p>这些是C++<a href=\"https://so.csdn.net/so/search?q=%E6%A0%87%E5%87%86%E5%BA%93&spm=1001.2101.3001.7020\">标准库</a>中stack类的构造函数声明。stack是一个适配器容器，它可以使用不同的底层容器来实现栈的功能。这些构造函数声明提供了不同的方式来创建和初始化stack对象，可以根据需求选择合适的构造函数。 </p>\n<blockquote>\n<p><strong>stack的Construct中除了构造函数，其他什么都没有，它连拷贝构造、析构都没有。这个也跟它是容器适配器有关系，因为它的成员都是自定义类型，编译器默认生成的就够用。</strong></p>\n<p><strong>stack是容器适配器以后，就开始不支持迭代器了。容器支持迭代器，容器适配器不支持迭代器。</strong></p>\n<p><strong>栈随便去遍历反而是不好的，因为要保证后进先出的性质。</strong></p>\n<p><strong>所以取数据得用top，想取下一个数据就得先pop。</strong></p>\n</blockquote>\n<h5 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a><a href=\"https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020\">top</a></h5><p>reference top(); 和 const_reference top() const; 是 C++ 标准库中 std::stack 类的成员函数之一。它们用于获取栈顶元素的引用。</p>\n<p>reference top();：返回栈顶元素的引用。如果需要修改栈顶元素，可以使用这个版本。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br> <br>\t\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br> <br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">42</span>);<br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">15</span>);<br> <br>\t\t<span class=\"hljs-comment\">// 使用 top() 获取栈顶元素</span><br>\t\t<span class=\"hljs-type\">int</span> topElement = m.<span class=\"hljs-built_in\">top</span>();<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Top element: &quot;</span> &lt;&lt; topElement &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-comment\">// 修改栈顶元素</span><br>\t\tm.<span class=\"hljs-built_in\">top</span>() = <span class=\"hljs-number\">99</span>;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;New top element: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">top</span>() &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<br> <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> <img src=\"https://i-blog.csdnimg.cn/blog_migrate/af9dbb720d78efb612f5c4bb64dbb6ec.png\" alt=\"img\"></p>\n<p>后进先出，15先出，然后修改为99，最后出99</p>\n<h5 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h5><p><strong>是 C++ 标准库中 <code>std::stack</code> 类的成员函数之一。它们用于将一个新的元素压入栈中。</strong></p>\n<p><strong>这两个版本的 push 函数允许你在栈顶添加新的元素。如果需要保持传入值的不变性，可以使用第一个版本；如果你想利用移动语义来避免不必要的复制，可以使用第二个版本。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br> <br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br> <br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 使用右值，将 10 压入栈中</span><br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">19</span>);<br> <br>\t\t<span class=\"hljs-type\">int</span> newElement = <span class=\"hljs-number\">99</span>;<br>\t\tm.<span class=\"hljs-built_in\">push</span>(newElement); <span class=\"hljs-comment\">// 使用常量引用，将 newElement 压入栈中</span><br> <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-keyword\">while</span> (!m.<span class=\"hljs-built_in\">empty</span>())  <span class=\"hljs-comment\">// 遍历不能用迭代器，容器适配器不支持迭代器</span><br>\t\t&#123;<br>\t\t\tcout &lt;&lt; m.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出栈顶元素</span><br>\t\t\tm.<span class=\"hljs-built_in\">pop</span>(); <span class=\"hljs-comment\">// 弹出栈顶元素</span><br>\t\t&#125;<br> <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/fe6f4bb4063818fce45d827a5bc7661c.png\" alt=\"img\"></p>\n<h5 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h5><p><strong><code>void pop();</code> 是 C++ 标准库中 <code>stack</code> 类的成员函数之一。它用于将栈顶元素弹出（删除）。</strong></p>\n<p><strong>这个函数没有返回值，它只是从栈中移除栈顶元素。在调用 <code>pop()</code> 函数之前，需要确保栈不为空，否则会导致未定义行为。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br><br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 使用右值，将 10 压入栈中</span><br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">19</span>);<br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">29</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\tm.<span class=\"hljs-built_in\">pop</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack new size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/84b16ae75feec2ff17399e8a5edab7b8.png\" alt=\"img\"></p>\n<h5 id=\"公共成员函数：\"><a href=\"#公共成员函数：\" class=\"headerlink\" title=\"公共成员函数：\"></a><strong>公共成员函数</strong>：</h5><blockquote>\n<p>push(const T&amp; x)：将传入的元素值 x 添加到底层容器的末尾，实现了入栈操作。</p>\n<p>pop()：从底层容器的末尾删除一个元素，实现了出栈操作。</p>\n<p>T&amp; top() 和 const T&amp; top() const：分别返回底层容器的末尾元素的引用（允许修改）和常量引用（只读），实现了查看栈顶元素操作。</p>\n<p>bool empty() const：返回底层容器是否为空。</p>\n<p>size_t size() const：返回底层容器中元素的数量。</p>\n<p>私有成员变量 _con：这是一个模板类的私有成员变量，用于存储实际的栈元素。其类型是根据模板参数 Container 确定的，在实例化时会被替换为具体的容器类型。</p>\n</blockquote>\n<h3 id=\"实例-o2r函数，用于将整数n转换为基数r的字符串表示\"><a href=\"#实例-o2r函数，用于将整数n转换为基数r的字符串表示\" class=\"headerlink\" title=\"实例(o2r函数，用于将整数n转换为基数r的字符串表示)\"></a>实例(o2r函数，用于将整数n转换为基数r的字符串表示)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义o2r函数，用于将整数n转换为基数r的字符串表示</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">o2r</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 使用栈来存储转换过程中的每一位数字</span><br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; s;<br>    <span class=\"hljs-comment\">// base数组用于将十进制数转换为r进制的字符表示</span><br>    <span class=\"hljs-type\">char</span> base[] = <span class=\"hljs-string\">&quot;0123456789ABCDEF&quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 当n不为0时，继续转换过程</span><br>    <span class=\"hljs-keyword\">while</span> (n) &#123;<br>        <span class=\"hljs-comment\">// 取n除以r的余数，得到当前位的值，并将其加入栈中</span><br>        s.<span class=\"hljs-built_in\">push</span>(base[n % r]);<br>        <span class=\"hljs-comment\">// 更新n为n除以r的商，继续下一位的计算</span><br>        n = n / r;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 当栈不为空时，依次取出栈中的元素并输出，完成r进制数的构建</span><br>    <span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        cout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>();<br>        <span class=\"hljs-comment\">// 取出栈顶元素后，将其从栈中移除</span><br>        s.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 在输出后换行，以便于阅读</span><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 示例：将10进制的255转换为16进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的255转换为16进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">// 输出: FF</span><br><br>    <span class=\"hljs-comment\">// 示例：将10进制的100转换为2进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的100转换为2进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 输出: 1100100</span><br><br>    <span class=\"hljs-comment\">// 示例：将10进制的1234转换为8进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的1234转换为8进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// 输出: 2322</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入(入队、进队)的一端称为队尾，允许删除(出队)的一端称为队头。</p>\n<p>队列中的元素除了具有线性关系外，还具有&#x3D;&#x3D;<em><strong>先进先出</strong></em>&#x3D;&#x3D;的特性</p>\n<h3 id=\"队列的顺序存储结构及实现\"><a href=\"#队列的顺序存储结构及实现\" class=\"headerlink\" title=\"队列的顺序存储结构及实现\"></a>队列的顺序存储结构及实现</h3><p>队列的顺序存储结构称为顺序队列。假设队列有n个元素，顺序队列把队列的所有元素存储在数组的前n个单元。如果把队头元素放在数组中下标为0的一端，则入队操作相当于追加，不需要移动元素，其时间性能为O(1)，但是出队操作的时间性能为O(n)，因为要保证剩下的n-1个元素仍然存储在数组的前n-1个单元，所有元素都要向前移动一个位置。</p>\n<p>如果放宽队列的所有元素必须存储在数组的前n个单元这一条件，就可以得到一种更为有效的存储方式。此时入队和出队操作的时间性能都是O(1)，因为没有移动任何元素。需要设置队头、队尾两个位置变量front和rear，入队时rear加1，出队时front加1，并且约定：front指向队头元素的前一个位置，rear指向队尾元素的位置。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>这样约定的目的是方便运算，例如rear-front等于队列的长度。</p>\n</blockquote>\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>在顺序队列中，随着队列的插入和删除操作，整个队列向数组的高端移过去，从而产生了队列的“单向移动性”。当元素被插入到数组中下标最大的位置之后，数组空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫做“假溢出”</p>\n<p>解决假溢出的方法是将存储队列的数组看成是头尾相接的循环结构，这可以通过取模操作来实现，设存储队列的数组长度为QueueSize，操作语句为rear&#x3D;(rear+1)%QueueSize</p>\n<p>队列的这种头尾相接的顺序存储结构称为循环队列。</p>\n<p>队空的条件是front&#x3D;rear</p>\n<p>队满的条件是(rear+1)%QueueSize&#x3D;front</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> QueueSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CirQueue</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">CirQueue</span>();<span class=\"hljs-comment\">//构造函数，初始化空队列</span><br>    ~<span class=\"hljs-built_in\">CirQueue</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueue</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">DeQueue</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取队头元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断队列是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[QueueSize];<span class=\"hljs-comment\">//存放队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front,rear;<span class=\"hljs-comment\">//游标，队头和队尾指针</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">CirQueue</span>() &#123;<br>    rear=front=QueueSize<span class=\"hljs-number\">-1</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>CirQueue&lt;DataType&gt;::~<span class=\"hljs-built_in\">CirQueue</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">EnQueue</span>(DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>((rear<span class=\"hljs-number\">+1</span>)%QueueSize==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    rear=(rear<span class=\"hljs-number\">+1</span>)%QueueSize;<span class=\"hljs-comment\">//队尾指针在循环意义下加1</span><br>    data[rear]=x;<span class=\"hljs-comment\">//在队尾处插入元素</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">DeQueue</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    front=(front<span class=\"hljs-number\">+1</span>)%QueueSize;<span class=\"hljs-comment\">//队头在循环意义下加1</span><br>    <span class=\"hljs-keyword\">return</span> data[front];<span class=\"hljs-comment\">//返回出队前的队头元素</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">GetHead</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    <span class=\"hljs-keyword\">return</span> data[(front<span class=\"hljs-number\">+1</span>)%QueueSize];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span> (rear==front) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    CirQueue&lt;<span class=\"hljs-type\">int</span>&gt; Q&#123;&#125;;<br>    Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">5</span>);Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">8</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前队头元素为：&quot;</span>&lt;&lt;Q.<span class=\"hljs-built_in\">GetHead</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=Q.<span class=\"hljs-built_in\">DeQueue</span>();<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行一次出队操作，出队元素是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入入队元素:&quot;</span>;<br>        cin&gt;&gt;x;<br>        Q.<span class=\"hljs-built_in\">EnQueue</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(Q.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"队列的链存储结构及实现\"><a href=\"#队列的链存储结构及实现\" class=\"headerlink\" title=\"队列的链存储结构及实现\"></a>队列的链存储结构及实现</h3><p>队列的链接存储结构称为链队列，通常用单链表表示，其结点结构与单链表的结点结构相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>为了使空队列和非空队列的操作一致，链队列也加上头结点；为了操作上的方便，设置队头指针指向链队列的头结点，队尾指针指向终端结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkQueue</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkQueue</span>();<span class=\"hljs-comment\">//构造函数，初始化空队列</span><br>    ~<span class=\"hljs-built_in\">LinkQueue</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueue</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">DeQueue</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取队头元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断队列是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *front,*rear;<span class=\"hljs-comment\">//队头和队尾指针</span><br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkQueue</span>() &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    front=rear=s;<span class=\"hljs-comment\">//将队头指针和队尾指针都指向头结点s</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkQueue&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkQueue</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">EnQueue</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;data=x;s-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    rear-&gt;next=s;<br>    rear=s;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">DeQueue</span>() &#123;<br>    DataType x;<br>    Node&lt;DataType&gt; *p=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    p=front-&gt;next;x=p-&gt;data;<br>    front-&gt;next=p-&gt;next;<br>    <span class=\"hljs-keyword\">if</span>(p-&gt;next==<span class=\"hljs-literal\">nullptr</span>)&#123;<span class=\"hljs-comment\">//出队前队列长度为1</span><br>        rear=front;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">GetHead</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> front-&gt;next-&gt;data;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(front==rear) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    LinkQueue&lt;<span class=\"hljs-type\">int</span>&gt; Q&#123;&#125;;<br>    Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">5</span>);Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">8</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前队头元素为：&quot;</span>&lt;&lt;Q.<span class=\"hljs-built_in\">GetHead</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=Q.<span class=\"hljs-built_in\">DeQueue</span>();<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行一次出队操作，出队元素是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入入队元素:&quot;</span>;<br>        cin&gt;&gt;x;<br>        Q.<span class=\"hljs-built_in\">EnQueue</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(Q.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"循环队列和链队列的比较\"><a href=\"#循环队列和链队列的比较\" class=\"headerlink\" title=\"循环队列和链队列的比较\"></a>循环队列和链队列的比较</h3><p>循环队列和链队列基本操作的时间复杂度均为O(1)，因此可以比较的只有空间性能。作为一般规律，当队列中元素个数变化较大时，应采用链队列，反之，应该采用循环队列，如果确定不会发生假溢出，也可以采用顺序队列</p>\n<h2 id=\"扩展与提高-1\"><a href=\"#扩展与提高-1\" class=\"headerlink\" title=\"扩展与提高\"></a>扩展与提高</h2><h3 id=\"两栈共享空间\"><a href=\"#两栈共享空间\" class=\"headerlink\" title=\"两栈共享空间\"></a>两栈共享空间</h3><p>在一个程序中，如果同时使用具有相同数据类型的两个顺序栈，最直接的方法是为每个栈开辟一个数组空间，这样做的结果可能出现一个栈的空间已被占满而无法再进行插入操作，同时另一个栈的空间仍有大量剩余而没有得到利用的情况，从而造成存储空间的浪费。</p>\n<p>可以充分利用顺序栈单向延伸的特性，使用一个数组来存储两个栈，让一个栈的栈底位于该数组的始端，另一个栈的栈底位于该数组的末端，每个栈从各自的端点向中间延伸。</p>\n<p>其中，topl 和 top2分别为栈1 和栈2 的栈顶位置，StackSize 为整个数组空间的大小，栈1的底位于下标为。的一端；栈2的底位于下标为 StackSize一1 的一端。</p>\n<p>在两栈共享空间中，由于两个栈相向增长，浪费的数组空间就会减少，同时发生上溢的概率也会减少。<strong>但是，只有当两个栈的空间需求有相反的关系时，这种方法才会奏效，也就是说，最好一个栈增长时另一个栈缩短。</strong>下面给出两栈共享空间的类定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BothStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BothStack</span>();<span class=\"hljs-comment\">//构造函数，将两个栈分别初始化</span><br>    ~<span class=\"hljs-built_in\">BothStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x压入栈i</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//出栈操作，对栈i执行出栈操作</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//取栈i的栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//判断栈i是否为空栈</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<span class=\"hljs-comment\">//存放两个栈的数组</span><br>    <span class=\"hljs-type\">int</span> top1,top2;<span class=\"hljs-comment\">//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>设整型变量i只取1和2两个值。当i&#x3D;1时，表示对栈1操作；当i&#x3D;2时，表示对栈2操作</p>\n<p>下面讨论两栈共享空间的入栈和出栈操作：</p>\n<h4 id=\"入栈\"><a href=\"#入栈\" class=\"headerlink\" title=\"入栈\"></a>入栈</h4><p>当存储栈的数组中没用空闲单元时为栈满，此时栈1的栈顶元素和栈2的栈顶元素位于数组中的相邻位置，即top1&#x3D;top2-1。另外，当新元素插入栈2时，栈顶位置top2不是加一而是减一</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top1==top2<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>)data[++top1]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top1++;</span><br><span class=\"hljs-comment\">    data[top1] = x;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>)data[--top2]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top2--;</span><br><span class=\"hljs-comment\">    data[top2] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"出栈\"><a href=\"#出栈\" class=\"headerlink\" title=\"出栈\"></a>出栈</h4><p>当top1&#x3D;-1时栈1为空，当top2&#x3D;StackSize时栈2为空。另外，当从栈2删除元素时，top2不是减一而是加一</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top1==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top1--];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top2==StackSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top2++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BothStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BothStack</span>();<span class=\"hljs-comment\">//构造函数，将两个栈分别初始化</span><br>    ~<span class=\"hljs-built_in\">BothStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x压入栈i</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//出栈操作，对栈i执行出栈操作</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//取栈i的栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//判断栈i是否为空栈</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<span class=\"hljs-comment\">//存放两个栈的数组</span><br>    <span class=\"hljs-type\">int</span> top1,top2;<span class=\"hljs-comment\">//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top1==top2<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>)data[++top1]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top1++;</span><br><span class=\"hljs-comment\">    data[top1] = x;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>)data[--top2]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top2--;</span><br><span class=\"hljs-comment\">    data[top2] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top1==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top1--];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top2==StackSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top2++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>双端队列是队列的扩展，</p>\n<p>如果允许在队列的两端进行插人和删除操作，则称为双端队列；</p>\n<p>如果允许在两端插入但只允许在一端删除，则称为二进一出队列；</p>\n<p>如果只允许在一端插入但允许在两端删除，则称为一进二出队列。</p>\n<p>双端队列和普通队列一样，具有人队、出队、取队头元素等基本操作，不同的是必须指明操作的位置，其抽象数据类型定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ADT\">ADT DoubleQueue<br>DataModel<br>\t相邻元素具有前驱和后继关系，允许在队列的两端进行插入和删除操作<br>Operation<br>\tInitQueue<br>\t\t输入：无<br>\t\t功能：初始化双端队列<br>\t\t输出：一个空的双端队列<br>\tDestroyQueue<br>\t\t输人：无<br>\t\t功能：队列的销毁<br>\t\t输出：释放双端队列占用的存储空间<br>\tEnQueueHead<br>\t\t输入：元素值x<br>\t\t功能：入队操作，将元素x插人到双端队列的队头输出：如果插入成功，双端队列的队头增加了一个元素<br>\tEnQueueTail<br>\t\t输人：元素值x<br>\t\t功能：入队操作，将元素×插入到双端队列的队尾输出：如果插入成功，双端队列的队尾增加了一个元系<br>\tDeQueueHead<br>\t\t输入：无<br>\t\t功能：出队操作，删除双端队列的队头元素<br>\t\t输出：如果删除成功，将队头元素出队<br>\tDeQueueTail<br>\t\t输人：无<br>\t\t功能：出队操作，删除双端队列的队尾元素输出：如果删除成功，将队尾元素出队<br>\tGetHead<br>\t\t输人：无<br>\t\t功能：读取双端队列的队头元素<br>\t\t输出：若双端队列不空，返回队头元素<br>\tGetTail<br>\t\t输人：无<br>\t\t功能：读取双端队列的队尾元素<br>\t\t输出：若双端队列不空，返回队尾元素<br>\tEmpty<br>\t\t输人：无<br>\t\t功能：判空操作，判断双端队列是否为空输出：如果双端队列为空，返回1，否则返回0。<br>endADT<br></code></pre></td></tr></table></figure>\n\n<p>双端队列可以采用循环队列的存储方式，基本算法可以在循环队列的基础上修改而成。不同的是，在队头入队时，先将新元素插人到 front处，再把队头位置 front 在循环意义下减1；在队尾出队时，先将 rear 处的队尾元素暂存，再把队尾位置 rear 在循环意义下减1。</p>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdexcept&gt;</span></span><br><br><span class=\"hljs-comment\">// 定义链表节点</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>\t<span class=\"hljs-type\">int</span> data;<br>\tNode* prev;<br>\tNode* next;<br>\t<br>\t<span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-type\">int</span> val) : <span class=\"hljs-built_in\">data</span>(val), <span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 双端队列类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DoubleQueue</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>\tNode* head;<br>\tNode* tail;<br>\t<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">DoubleQueue</span>() : <span class=\"hljs-built_in\">head</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">tail</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">DoubleQueue</span>() &#123;<br>\t\t<span class=\"hljs-built_in\">DestroyQueue</span>();<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 初始化双端队列</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">InitQueue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\thead = <span class=\"hljs-literal\">nullptr</span>;<br>\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 销毁双端队列</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DestroyQueue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\tNode* temp = head;<br>\t\t\thead = head-&gt;next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t&#125;<br>\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 在队头插入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueueHead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123;<br>\t\tNode* newNode = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead = tail = newNode;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewNode-&gt;next = head;<br>\t\t\thead-&gt;prev = newNode;<br>\t\t\thead = newNode;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 在队尾插入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueueTail</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123;<br>\t\tNode* newNode = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead = tail = newNode;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewNode-&gt;prev = tail;<br>\t\t\ttail-&gt;next = newNode;<br>\t\t\ttail = newNode;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 从队头删除元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DeQueueHead</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\tNode* temp = head;<br>\t\thead = head-&gt;next;<br>\t\t<span class=\"hljs-keyword\">if</span> (head != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 从队尾删除元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DeQueueTail</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\tNode* temp = tail;<br>\t\ttail = tail-&gt;prev;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\ttail-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\thead = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 获取队头元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;Queue is empty&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> head-&gt;data;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 获取队尾元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetTail</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;Queue is empty&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> tail-&gt;data;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 判断双端队列是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head == <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tDoubleQueue dq;<br>\t<br>\t<span class=\"hljs-comment\">// 测试操作</span><br>\tdq.<span class=\"hljs-built_in\">EnQueueHead</span>(<span class=\"hljs-number\">1</span>);<br>\tdq.<span class=\"hljs-built_in\">EnQueueTail</span>(<span class=\"hljs-number\">2</span>);<br>\tdq.<span class=\"hljs-built_in\">EnQueueHead</span>(<span class=\"hljs-number\">3</span>);<br>\t<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Head: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, Tail: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetTail</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Head: 3, Tail: 2</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueHead</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;After DeQueueHead, Head: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Head: 1</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueTail</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;After DeQueueTail, Tail: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Tail: 1</span><br>\t<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Is the queue empty? &quot;</span> &lt;&lt; (dq.<span class=\"hljs-built_in\">Empty</span>() ? <span class=\"hljs-string\">&quot;Yes&quot;</span> : <span class=\"hljs-string\">&quot;No&quot;</span>) &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 No</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueHead</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Is the queue empty after all elements removed? &quot;</span> &lt;&lt; (dq.<span class=\"hljs-built_in\">Empty</span>() ? <span class=\"hljs-string\">&quot;Yes&quot;</span> : <span class=\"hljs-string\">&quot;No&quot;</span>) &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Yes</span><br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用举例\"><a href=\"#应用举例\" class=\"headerlink\" title=\"应用举例\"></a>应用举例</h2><h3 id=\"括号匹配问题\"><a href=\"#括号匹配问题\" class=\"headerlink\" title=\"括号匹配问题\"></a>括号匹配问题</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Matcher</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Matcher</span>(string str);<br>    ~<span class=\"hljs-built_in\">Matcher</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Match</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    string str;<br>&#125;;<br>Matcher::<span class=\"hljs-built_in\">Matcher</span>(string str) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;str=str;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Matcher::Match</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">char</span> S[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-type\">int</span> i,top=<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;str[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(str[i]==<span class=\"hljs-string\">&#x27;)&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span>(top&gt;<span class=\"hljs-number\">-1</span>)top--;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(str[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>            S[++top]=str[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br>Matcher::~<span class=\"hljs-built_in\">Matcher</span>() &#123;<br><br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string str;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入一个算数表达式&quot;</span>;<br>    cin&gt;&gt;str;<br>    Matcher M&#123;str&#125;;<br>    <span class=\"hljs-type\">int</span> k=M.<span class=\"hljs-built_in\">Match</span>();<br>    <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;正确匹配\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;多左括号\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;多右括号\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h3><p>表达式求值需要根据运算符的优先级来确定计算顺序。因此，在求值过程中需要保存优先级较低的运算符以及没有参与计算的运算对象，并将当前运算符与已经扫描过的、尚未计算的运算符进行比较，以确定哪个运算符以及哪两个运算对象参与计算。这需要两个栈来辅助完成：运算对象栈 OPND 和运算符栈 OPTR。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Expression</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Expression</span>(string str);<br>    ~<span class=\"hljs-built_in\">Expression</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Compute</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Comp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> str1,<span class=\"hljs-type\">char</span> str2)</span></span>;<br>    string str;<br>&#125;;<br>Expression::<span class=\"hljs-built_in\">Expression</span>(string str) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;str=str+<span class=\"hljs-string\">&quot;#&quot;</span>;<br>&#125;<br>Expression::~<span class=\"hljs-built_in\">Expression</span>() &#123;<br><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Expression::Compute</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">char</span> OPND[<span class=\"hljs-number\">100</span>],OPTR[<span class=\"hljs-number\">100</span>];<br>    OPTR[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-string\">&#x27;#&#x27;</span>;<br>    <span class=\"hljs-type\">int</span> top1=<span class=\"hljs-number\">-1</span>,top2=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> i,k,x,y,z,op;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;str[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>;) &#123;<br>        <span class=\"hljs-keyword\">if</span>(str[i]&gt;=<span class=\"hljs-number\">48</span> &amp;&amp; str[i]&lt;=<span class=\"hljs-number\">57</span>) &#123;<br>            OPND[++top1]=str[i++]<span class=\"hljs-number\">-48</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            k=<span class=\"hljs-built_in\">Comp</span>(str[i],OPTR[top2]);<br>            <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>) &#123;<br>                OPTR[++top2]=str[i++];<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">-1</span>) &#123;<br>                y=OPND[top1--];<br>                x=OPND[top1--];<br>                op=OPTR[top2--];<br>                <span class=\"hljs-keyword\">switch</span> (op) &#123;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;+&#x27;</span>:z=x+y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>:z=x-y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;*&#x27;</span>:z=x*y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;/&#x27;</span>:z=x/y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>                OPND[++top1]=z;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                top2--;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> OPND[top1];<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Expression::Comp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> str1, <span class=\"hljs-type\">char</span> str2)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">switch</span> (str1) &#123;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;+&#x27;</span>:<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;(&#x27;</span> || str2==<span class=\"hljs-string\">&#x27;#&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;*&#x27;</span>:<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;/&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;*&#x27;</span> || str2==<span class=\"hljs-string\">&#x27;/&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;(&#x27;</span>:<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;)&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;(&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;#&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;#&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">default</span>:<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string str;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入一个表达式&quot;</span>&lt;&lt;endl;<br>    cin&gt;&gt;str;<br>    Expression E&#123;str&#125;;<br>    <span class=\"hljs-type\">int</span> result=E.<span class=\"hljs-built_in\">Compute</span>();<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;表达式的值是&quot;</span>&lt;&lt;result&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h2><h1 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h1><h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>给定两个字符串S，T，在主串S中寻找子串T的过程称为模式匹配，T称为模式。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。</p>\n<h3 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h3><p>BF算法的基本思想是蛮力匹配，即从主串S的第一个字符开始和模式T的第一个字符进行比较。若相等，则继续比较两者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本趟匹配的开始位置；否则匹配失败，返回0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">BF</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> S[],<span class=\"hljs-type\">char</span> T[])</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> start=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>,j=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span>((S[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>) &amp;&amp; (T[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>))&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(S[i]==T[i])&#123;<br>\t\t\ti++;j++;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\tstart++;<br>\t\t\ti=start;j=<span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(T[j]==<span class=\"hljs-string\">&#x27;\\0&#x27;</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> start<span class=\"hljs-number\">+1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最坏情况下的时间复杂度是O(n*m)（设主串S长度为n，模式T长度为m）</p>\n<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p>【最浅显易懂的 KMP 算法讲解】 <a href=\"https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a><br>【【天勤考研】KMP算法易懂版】 <a href=\"https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a><br>【KMP算法之求next数组代码讲解】 <a href=\"https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a></p>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><h2 id=\"矩阵压缩存储\"><a href=\"#矩阵压缩存储\" class=\"headerlink\" title=\"矩阵压缩存储\"></a>矩阵压缩存储</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"七桥问题\"><a href=\"#七桥问题\" class=\"headerlink\" title=\"七桥问题\"></a>七桥问题</h2><p>七桥问题是一个经典的图论问题，它是由数学家欧拉在18世纪提出的。问题的背景是哥尼斯堡（今俄罗斯的加里宁格勒）的一个地区，该地区被普雷格尔河分成四个区域，并由七座桥连接。问题是：是否有可能从某个区域出发，不重复地走过所有七座桥，并且回到起点。<br>我们可以这样求解七桥问题：</p>\n<ol>\n<li>首先，我们需要确定每个顶点（即每个城区）相关联的边数（即桥的数量）。</li>\n<li>然后，我们根据以下规则进行判定：<ul>\n<li>如果所有顶点相关联的边数都是偶数，则存在欧拉回路。</li>\n<li>如果有超过两个顶点相关联的边数是奇数，则不存在欧拉回路。</li>\n<li>如果恰好有两个顶点相关联的边数是奇数，则不存在欧拉回路，但存在一条从这两个顶点之一出发的欧拉路径（不会回到起点）。<br>对于七桥问题，我们可以将四个区域视为四个顶点，七座桥视为连接这些顶点的边。通过计算每个顶点相关联的边数，我们可以得到以下结果：</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>两个区域（顶点）各有三座桥相连，因此这两个区域相关联的边数是奇数。</li>\n<li>另外两个区域（顶点）各有两座桥相连，因此这两个区域相关联的边数是偶数。<br>根据判定规则，因为有超过两个顶点相关联的边数是奇数（具体来说，有两个顶点），所以七桥问题中不存在欧拉回路。同时，也不存在从这两个顶点之一出发的欧拉路径，因为路径要求不重复地走过所有边，而这是不可能的。<br>因此，结论是：在七桥问题中，不可能找到一条不重复地走过所有七座桥的路径，并且返回起点。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">4</span>;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EulerCircuit</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">EulerCircuit</span>(<span class=\"hljs-type\">int</span> a[][MaxSize],<span class=\"hljs-type\">int</span> n);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">oddVertexNum</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mat[MaxSize][MaxSize];<br>    <span class=\"hljs-type\">int</span> vertexNum;<br>&#125;;<br>EulerCircuit::<span class=\"hljs-built_in\">EulerCircuit</span>(<span class=\"hljs-type\">int</span> a[][MaxSize],<span class=\"hljs-type\">int</span> n)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>            mat[i][j]=a[i][j];<br>        &#125;<br>    &#125;<br>    vertexNum=n;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">EulerCircuit::oddVertexNum</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>,i,j,degree;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;vertexNum;i++)&#123;<br>        degree=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;vertexNum;j++)&#123; <span class=\"hljs-comment\">// 这里应该是 j++ 而不是 i++</span><br>            degree=degree+mat[i][j];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(degree%<span class=\"hljs-number\">2</span>!=<span class=\"hljs-number\">0</span>)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> a[<span class=\"hljs-number\">4</span>][MaxSize]=&#123;<br>        &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>&#125;,<br>        &#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>&#125;,<br>        &#123;<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;,<br>        &#123;<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;<br>    &#125;;<br>    EulerCircuit G&#123;a,<span class=\"hljs-number\">4</span>&#125;;<br>    <span class=\"hljs-type\">int</span> num=G.<span class=\"hljs-built_in\">oddVertexNum</span>();<br>    <span class=\"hljs-keyword\">if</span>(num&gt;=<span class=\"hljs-number\">2</span>)&#123;<br>        cout&lt;&lt;num&lt;&lt;<span class=\"hljs-string\">&quot;个地方通奇数桥，不存在欧拉回路&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;存在欧拉回路&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h2><p>欧几里得算法用自然语言描述如下：</p>\n<p>步骤1：将m除以n得到余数r</p>\n<p>步骤2：若r等于0，则n为最大公约数，算法结束；否则执行步骤3</p>\n<p>步骤3：将n的值放在m中，将r的值放在n中，重新执行步骤1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">ComFactor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m,<span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r=m%n;<br>    <span class=\"hljs-keyword\">while</span> (r!=<span class=\"hljs-number\">0</span>) &#123;<br>        m=n;<br>        n=r;<br>        r=m%n;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> n;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;最大公约数是&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">ComFactor</span>(<span class=\"hljs-number\">35</span>,<span class=\"hljs-number\">25</span>)&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h1><h2 id=\"线性表的定义\"><a href=\"#线性表的定义\" class=\"headerlink\" title=\"线性表的定义\"></a>线性表的定义</h2><p>线性表简称表，是n个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度，长度等于零的线性表称为空表，一个非空表通常记为：<br>$$<br>L&#x3D;(a1,a2,…,an)<br>$$<br>其中，ai称为数据元素，下角标i表示该元素在线性表中的位置或序号，称元素ai位于表的第i个位置，或称是ai是表中的第i的元素。a1称为表头元素，an称为表尾元素，任意一对相邻的数据元素a（i-1）和ai（1&lt;i&lt;&#x3D;n）之间存在序偶关系&lt;a(i-1),ai&gt;，且a(i-1)称为ai的前驱，ai称为a(i-1)的后继。在这个序列中，元素a1无前驱，元素an无后继，其他每个元素有且仅有一个前驱和一个后继</p>\n<p>线性表的基本操作包括：</p>\n<ol>\n<li><strong>初始化</strong>：创建一个空的线性表。</li>\n<li><strong>销毁</strong>：销毁线性表，释放其占用的内存空间。</li>\n<li><strong>插入</strong>：在指定位置插入一个元素。</li>\n<li><strong>删除</strong>：删除指定位置的元素。</li>\n<li><strong>查找</strong>：查找并返回指定元素的位置。</li>\n<li><strong>取值</strong>：获取指定位置的元素。</li>\n<li><strong>修改</strong>：修改指定位置的元素。</li>\n<li><strong>长度</strong>：返回线性表的长度（元素个数）。</li>\n<li><strong>判空</strong>：判断线性表是否为空。</li>\n</ol>\n<h2 id=\"线性表的顺序存储结构及实现\"><a href=\"#线性表的顺序存储结构及实现\" class=\"headerlink\" title=\"线性表的顺序存储结构及实现\"></a>线性表的顺序存储结构及实现</h2><p>线性表的顺序存储结构称为顺序表，其基本思想是用一段地址连续的存储单元依次存储线性表的数据元素</p>\n<p>设顺序表的每个元素占用c个存储单元，则第i个元素的存储地址为：<br>$$<br>Loc(ai)&#x3D;Loc(a1)+(i-1)*c<br>$$<br>顺序表中数据元素的存储地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任何一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存取结构</p>\n<p>通常用一维数组来实现顺序表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//根据实际问题具体定义</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<span class=\"hljs-comment\">//由于线性表的数据元素类型不确定，所以采用模板机制</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">SeqList</span>();<span class=\"hljs-comment\">//创建一个空的线性表</span><br>    <span class=\"hljs-built_in\">SeqList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<span class=\"hljs-comment\">//建立长度为n的顺序表</span><br>    ~<span class=\"hljs-built_in\">SeqList</span>();<span class=\"hljs-comment\">//析构函数，销毁线性表，释放其占用的内存空间</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[MaxSize];<span class=\"hljs-comment\">//存放数据元素的数组</span><br>    <span class=\"hljs-type\">int</span> length;<span class=\"hljs-comment\">//线性表的长度</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    length=<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-keyword\">if</span>(n&gt;MaxSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;参数非法&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        data[i]=a[i];<br>    &#125;<br>    length=n;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqList</span>() &#123;&#125;<span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> length==<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> length;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;length;i++) &#123;<br>        cout&lt;&lt;data[i]&lt;&lt;<span class=\"hljs-string\">&#x27;\\t&#x27;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//时间复杂度为O(1)</span><br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;查找位置非法&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> data[i<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;length;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(data[i]==x)<span class=\"hljs-keyword\">return</span> i<span class=\"hljs-number\">+1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    <span class=\"hljs-keyword\">if</span>(length==MaxSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;表满，上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length<span class=\"hljs-number\">+1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=length;j&gt;=i;j--) &#123;<br>        data[j]==data[j<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    data[i<span class=\"hljs-number\">-1</span>]=x;<br>    length++;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//平均时间性能是O(n)</span><br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(length==<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;空表 下溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;删除位置错误&quot;</span>;<br>    x=data[i<span class=\"hljs-number\">-1</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;length;j++) &#123;<br>        data[j<span class=\"hljs-number\">-1</span>]=data[j];<br>    &#125;<br>    length--;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    SeqList&lt;<span class=\"hljs-type\">int</span>&gt;L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"线性表的链接存储结构及其实现\"><a href=\"#线性表的链接存储结构及其实现\" class=\"headerlink\" title=\"线性表的链接存储结构及其实现\"></a>线性表的链接存储结构及其实现</h2><p>单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。为了能正确表示元素之间的逻辑关系，每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成了数据元素的存储映像，称为结点。</p>\n<h3 id=\"单链表的结点定义\"><a href=\"#单链表的结点定义\" class=\"headerlink\" title=\"单链表的结点定义\"></a>单链表的结点定义</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在使用单链表时，关心的只是数据元素以及数据元素之间的逻辑关系</p>\n<p>单链表中每个结点的存储地址存放在其前驱结点的next域中，而第一个结点无前驱，所以设头指针指向第一个元素所在结点，整个单链表的存取必须从头指针开始进行，因而头指针具有标识一个单链表的作用。最后一个元素所在结点的指针域为空。</p>\n<h3 id=\"单链表的实现\"><a href=\"#单链表的实现\" class=\"headerlink\" title=\"单链表的实现\"></a>单链表的实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt; *next;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkList</span>();<br>    <span class=\"hljs-built_in\">LinkList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">LinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *first;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkList</span>() &#123;<br>    first=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-comment\">/* nullptr是一个字面常量，表示空指针</span><br><span class=\"hljs-comment\">       它用于初始化指针变量或将其赋值给指针变量，</span><br><span class=\"hljs-comment\">       以确保指针不指向任何有效的内存地址 */</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> first-&gt;next==<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    <span class=\"hljs-comment\">//设置工作指针p依次指向各节点</span><br>    <span class=\"hljs-comment\">//p后移不能写作p++</span><br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;查找位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> p-&gt;data;<br>    &#125;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n),单链表是顺序存取结构</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;data==x) &#123;<br>            <span class=\"hljs-keyword\">return</span> count;<br>        &#125;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n)</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    Node&lt;DataType&gt; *p=first,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>        s-&gt;data=x;<br>        s-&gt;next=p-&gt;next;<br>        p-&gt;next=s;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-comment\">//头插法</span><br>    first=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>        s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>        s-&gt;data=a[i];<br>        s-&gt;next=first-&gt;next;<br>        first-&gt;next=s;<br>    &#125;<br>    <span class=\"hljs-comment\">//尾插法</span><br>    <span class=\"hljs-comment\">// first=new Node&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">// Node&lt;DataType&gt; *r=first,*s=nullptr;</span><br>    <span class=\"hljs-comment\">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class=\"hljs-comment\">//     s=new Node&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">//     s-&gt;data=a[i];</span><br>    <span class=\"hljs-comment\">//     r-&gt;next=s;</span><br>    <span class=\"hljs-comment\">//     r=s;</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// r-&gt;next=nullptr;</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    DataType x;<br>    Node&lt;DataType&gt; *p=first,*q=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span> || p-&gt;next==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;删除位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        q=p-&gt;next;<br>        x=q-&gt;data;<br>        p-&gt;next=q-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> q;<br>        <span class=\"hljs-keyword\">return</span> x;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkList&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkList</span>() &#123;<br>    Node&lt;DataType&gt; *p=first;<br>    <span class=\"hljs-keyword\">while</span> (first!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        first=first-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>        p=first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    LinkList&lt;<span class=\"hljs-type\">int</span>&gt; L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><p>在单链表的每个结点中再设置一个指向其前驱结点的指针域，这样就形成了双链表</p>\n<h3 id=\"双链表的结点结构定义：\"><a href=\"#双链表的结点结构定义：\" class=\"headerlink\" title=\"双链表的结点结构定义：\"></a>双链表的结点结构定义：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Datatype&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DulNode</span> &#123;<br>    Datatype data;<br>    DulNode&lt;Datatype&gt; *prior,*next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在双链表中求表长等操作与单链表基本相同，下面讨论插入和删除操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> Datatype&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DulNode</span> &#123;<br>    Datatype data;<br>    DulNode&lt;Datatype&gt; *prior,*next;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DulLinkList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">DulLinkList</span>();<br>    <span class=\"hljs-built_in\">DulLinkList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">DulLinkList</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DulNode&lt;DataType&gt; *first;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">DulLinkList</span>() &#123;<br>    first=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    first-&gt;prior=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-comment\">/* nullptr是一个字面常量，表示空指针</span><br><span class=\"hljs-comment\">       它用于初始化指针变量或将其赋值给指针变量，</span><br><span class=\"hljs-comment\">       以确保指针不指向任何有效的内存地址 */</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> first-&gt;next==<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">PrintList</span>() &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    <span class=\"hljs-comment\">//设置工作指针p依次指向各节点</span><br>    <span class=\"hljs-comment\">//p后移不能写作p++</span><br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Length</span>() &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> count;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Get</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i) &#123;<br>        p=p-&gt;next;<span class=\"hljs-comment\">//工作指针后移</span><br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;查找位置错误&quot;</span> ;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> p-&gt;data;<br>    &#125;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n),单链表是顺序存取结构</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Locate</span>(DataType x) &#123;<br>    DulNode&lt;DataType&gt; *p=first-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;data==x) &#123;<br>            <span class=\"hljs-keyword\">return</span> count;<br>        &#125;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">//平均时间性能为O(n)</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<span class=\"hljs-comment\">//时间复杂度为O(n)</span><br>    DulNode&lt;DataType&gt; *p=first,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; count&lt;i<span class=\"hljs-number\">-1</span>) &#123;<br>        p=p-&gt;next;<br>        count++;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(p==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误&quot;</span>;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        s=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>        s-&gt;data=x;<br>        <span class=\"hljs-comment\">//与单链表不同之处//这里</span><br>        s-&gt;prior=p;<br>        s-&gt;next=p-&gt;next;<br>        p-&gt;next-&gt;prior=s;<br>        p-&gt;next=s;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">DulLinkList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    <span class=\"hljs-comment\">//头插法</span><br>    first=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>    first-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        DulNode&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>        s=<span class=\"hljs-keyword\">new</span> DulNode&lt;DataType&gt;;<br>        s-&gt;data=a[i];<br>        s-&gt;next=first-&gt;next;<br>        first-&gt;next=s;<br>    &#125;<br>    <span class=\"hljs-comment\">//尾插法</span><br>    <span class=\"hljs-comment\">// first=new DulNode&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">// DulNode&lt;DataType&gt; *r=first,*s=nullptr;</span><br>    <span class=\"hljs-comment\">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class=\"hljs-comment\">//     s=new DulNode&lt;DataType&gt;;</span><br>    <span class=\"hljs-comment\">//     s-&gt;data=a[i];</span><br>    <span class=\"hljs-comment\">//     r-&gt;next=s;</span><br>    <span class=\"hljs-comment\">//     r=s;</span><br>    <span class=\"hljs-comment\">// &#125;</span><br>    <span class=\"hljs-comment\">// r-&gt;next=nullptr;</span><br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType DulLinkList&lt;DataType&gt;::<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-type\">int</span> i) &#123;<span class=\"hljs-comment\">//这里</span><br>    DulNode&lt;DataType&gt; *p = first;<br>    DulNode&lt;DataType&gt; *q;<br>    <span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (p != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; count &lt; i - <span class=\"hljs-number\">1</span>) &#123;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span> || p-&gt;next == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">runtime_error</span>(<span class=\"hljs-string\">&quot;删除位置错误&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        q = p-&gt;next; <span class=\"hljs-comment\">// Save the node to be deleted</span><br>        p-&gt;next = q-&gt;next; <span class=\"hljs-comment\">// Update next of the previous node</span><br>        q-&gt;next-&gt;prior = p; <span class=\"hljs-comment\">// Update prior of the next node</span><br>        DataType x = q-&gt;data; <span class=\"hljs-comment\">// Save data to return</span><br>        <span class=\"hljs-keyword\">delete</span> q; <br>        <span class=\"hljs-keyword\">return</span> x; <br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DulLinkList&lt;DataType&gt;::~<span class=\"hljs-built_in\">DulLinkList</span>() &#123;<br>    DulNode&lt;DataType&gt; *p=first;<br>    <span class=\"hljs-keyword\">while</span> (first!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        first=first-&gt;next;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>        p=first;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> r[<span class=\"hljs-number\">5</span>]=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;,i,x;<br>    DulLinkList&lt;<span class=\"hljs-type\">int</span>&gt; L&#123;r,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的数据为：&quot;</span>;<br>    L.<span class=\"hljs-built_in\">PrintList</span>();<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        L.<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">8</span>);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行插入操作后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前线性表的长度为：&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Length</span>()&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找的元素值：&quot;</span>;<br>    cin&gt;&gt;x;<br>    i=L.<span class=\"hljs-built_in\">Locate</span>(x);<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>==i)cout&lt;&lt;<span class=\"hljs-string\">&quot;查找失败&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;元素&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;的位置为：&quot;</span>&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入查找第几个元素值：&quot;</span>;<br>        cin&gt;&gt;i;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;第&quot;</span>&lt;&lt;i&lt;&lt;<span class=\"hljs-string\">&quot;个元素值是&quot;</span>&lt;&lt;L.<span class=\"hljs-built_in\">Get</span>(i)&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入要删除的第几个元素&quot;</span>;<br>        cin&gt;&gt;i;<br>        x=L.<span class=\"hljs-built_in\">Delete</span>(i);<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;删除的元素是&quot;</span>&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;,删除后数据为：&quot;</span>;<br>        L.<span class=\"hljs-built_in\">PrintList</span>();<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><p>在单链表中，如果将终端结点的指针由空指针改为指向头结点，就使得整个单链表形成一个环，这种头尾相接的单链表称为循环单链表。实际应用中多采用尾指针指示的循环单链表</p>\n<p>在双链表中，如果将终端结点的后继指针由空指针改为指向头结点，将头结点的前驱指针由空指针改为指向终端结点，就使得整个双链表形成一个环，这种头尾相接的单链表称为循环双链表</p>\n<p>循环链表中没有明显的尾端，可能会使循环链表的处理操作进入死循环，通常判断用作循环变量的工作指针是否等于某一特定指针（如头指针或尾指针），以判定工作指针是否扫描了整个链表，例如可以用循环条件  <code>p!=first</code>  判断工作指针是否扫描了整个链表</p>\n<h2 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h2><h3 id=\"1-时间性能比较\"><a href=\"#1-时间性能比较\" class=\"headerlink\" title=\"1.时间性能比较\"></a>1.时间性能比较</h3><p>所谓时间性能是指基某种存储结构的基本操作（即算法）的时间复杂度。</p>\n<p><strong>随机访问</strong></p>\n<ul>\n<li><strong>顺序表</strong>：能够直接定位到任意位置，实现快速访问，时间复杂度为 O(1)。</li>\n<li><strong>链表</strong>：必须从头部开始遍历至目标位置，平均时间复杂度为 O(n)。</li>\n</ul>\n<p><strong>插入与删除</strong></p>\n<ul>\n<li><strong>链表</strong>：一旦拥有指向目标位置的指针，插入或删除操作无需移动其他元素，时间复杂度为 O(1)。</li>\n<li><strong>顺序表</strong>：插入或删除元素需要调整后续所有元素的位置，平均时间复杂度为 O(n)，尤其是当元素数量大或每个元素占用较大存储空间时，移动元素的成本显著增加。</li>\n</ul>\n<p><strong>一般来说</strong></p>\n<ul>\n<li>当线性表的主要操作是<strong>频繁查找</strong>且<strong>插入和删除较少</strong>，或操作依赖于<strong>数据元素的绝对位置</strong>时，<strong>顺序表</strong>是更优的选择。</li>\n<li>若线性表中<strong>频繁执行插入和删除操作</strong>，<strong>链表</strong>则提供更好的性能。</li>\n</ul>\n<h3 id=\"2-空间性能比较\"><a href=\"#2-空间性能比较\" class=\"headerlink\" title=\"2.空间性能比较\"></a>2.空间性能比较</h3><p>所谓空间性能是指某种存储结构所占用的存储空间的大小。</p>\n<ul>\n<li><strong>存储特性</strong><ul>\n<li><strong>顺序表</strong>: 每个结点仅包含数据元素，存储密度高，空间利用率好。</li>\n<li><strong>链表</strong>: 结点包含数据元素和指针，指针增加结构开销，降低存储密度。</li>\n</ul>\n</li>\n<li><strong>空间分配</strong><ul>\n<li><strong>顺序表</strong>: 需预分配固定大小空间，可能造成浪费（分配过多）或上溢（分配不足）。</li>\n<li><strong>链表</strong>: 动态分配，元素数量不受限，只要系统有可用内存。</li>\n</ul>\n</li>\n<li><strong>适用场景</strong><ul>\n<li><strong>顺序表</strong>: 适合已知大致长度的线性表，以优化空间效率。</li>\n<li><strong>链表</strong>: 更适用于元素数量变化大或未知的情况。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"扩展与提高\"><a href=\"#扩展与提高\" class=\"headerlink\" title=\"扩展与提高\"></a>扩展与提高</h2><h3 id=\"线性表的静态链表存储\"><a href=\"#线性表的静态链表存储\" class=\"headerlink\" title=\"线性表的静态链表存储\"></a>线性表的静态链表存储</h3><p>静态链表用数组来表示链表。由于是利用数组定义的链表，属于静态存储分配，因此叫静态链表。最常用的是静态单链表。</p>\n<p>avail是空闲链表（全部由空闲数组单元组成的单链表）头指针，first是静态链表头指针，为了运算方便通常静态链表也带头指针。</p>\n<p><strong>静态链表的数组元素定义：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DateType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SNode</span> &#123;<br>    DateType data;<br>    <span class=\"hljs-type\">int</span> next;<span class=\"hljs-comment\">//指针域(也称游标),注意不是指针类型</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>静态链表的定义：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MaxSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">StaList</span>();<br>    <span class=\"hljs-built_in\">StaList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">StaList</span>();<br>    <span class=\"hljs-comment\">//与单链表成员函数相同</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    SNode&lt;DataType&gt; SList[MaxSize];<br>    <span class=\"hljs-type\">int</span> first,avail;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>静态链表采用静态存储分配，因此析构函数为空，求表长等操作的实现基本与单链表相同，下面讨论<strong>插入和删除</strong>操作</p>\n<p>在静态链表中进行插入操作，首先从空闲链的最前端摘下一个结点，将该结点插入静态链表中，假设新结点插在结点p的后面，则修改指针的操作为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">s=avail;<br>avail=SList[avail].next;<br>SList[s].data=x;<br>SList[s].next=SList[p].next;<br>SList[p].next=s;<br></code></pre></td></tr></table></figure>\n\n<p>在静态链表中进行删除操作，首先将被删除结点从静态链表中摘下，再插入空闲链的最前端，假设要删除结点p的后继结点，则修改指针的操作为：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">q</span><span class=\"hljs-operator\">=</span>SList[p].next<span class=\"hljs-comment\">;</span><br>SList[p].next<span class=\"hljs-operator\">=</span>SList[q].next<span class=\"hljs-comment\">;</span><br>SList[q].next<span class=\"hljs-operator\">=</span>avail<span class=\"hljs-comment\">;</span><br><span class=\"hljs-attribute\">avail</span><span class=\"hljs-operator\">=</span>q<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"顺序表的动态分配方式\"><a href=\"#顺序表的动态分配方式\" class=\"headerlink\" title=\"顺序表的动态分配方式\"></a>顺序表的动态分配方式</h3><p>顺序表的动态分配方式是在程序执行过程中通过动态存储分配，一旦数组空间占满，另外再分配一块更大的存储空间，用来替换原来的存储空间，从而达到扩充数组空间的目的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> InitSize=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//顺序表的初始长度</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> IncreSize=<span class=\"hljs-number\">10</span>;<span class=\"hljs-comment\">//顺序表存储空间每次扩展的长度</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqList</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//与顺序表的静态分配相同</span><br>    <span class=\"hljs-built_in\">SeqList</span>();<br>    <span class=\"hljs-built_in\">SeqList</span>(DataType a[],<span class=\"hljs-type\">int</span> n);<br>    ~<span class=\"hljs-built_in\">SeqList</span>();<br>    <span class=\"hljs-comment\">//与单链表成员函数相同</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Length</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//求线性表的长度</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//按位查找，查找第i个元素的值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Locate</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//按值查找，查找值为x的元素序号；</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//插入操作，在第i个位置插入值为x的元素</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//删除操作，删除第i个元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断线性表是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintList</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//按序号输出各元素</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType *data;<span class=\"hljs-comment\">//动态申请数组空间的首地址</span><br>    <span class=\"hljs-type\">int</span> maxSize;<span class=\"hljs-comment\">//当前数组空间的最大长度</span><br>    <span class=\"hljs-type\">int</span> length;<span class=\"hljs-comment\">//线性表的长度</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>在顺序表的动态分配方式下，求线性表的长度等操作与顺序表的静态分配方式相同，下面讨论其他基本操作的实现</p>\n<h4 id=\"无参构造函数——初始化顺序表：\"><a href=\"#无参构造函数——初始化顺序表：\" class=\"headerlink\" title=\"无参构造函数——初始化顺序表：\"></a>无参构造函数——初始化顺序表：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    data=<span class=\"hljs-keyword\">new</span> DataType[InitSize];<br>    maxSize=InitSize;<br>    length=<span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"有参构造函数——建立顺序表：\"><a href=\"#有参构造函数——建立顺序表：\" class=\"headerlink\" title=\"有参构造函数——建立顺序表：\"></a>有参构造函数——建立顺序表：</h4><p>建立一个长度为<em>n</em>的顺序表需要申请长度大于n的存储空间，一般是当前线性表长度两倍的存储空间：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqList</span>(DataType a[], <span class=\"hljs-type\">int</span> n) &#123;<br>    data=<span class=\"hljs-keyword\">new</span> DataType[<span class=\"hljs-number\">2</span>*n];<br>    maxSize=<span class=\"hljs-number\">2</span>*n;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++) &#123;<br>        data[i]=a[i];<br>    &#125;<br>    length=n;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"析构函数——销毁顺序表\"><a href=\"#析构函数——销毁顺序表\" class=\"headerlink\" title=\"析构函数——销毁顺序表\"></a>析构函数——销毁顺序表</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqList&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqList</span>() &#123;<br>    <span class=\"hljs-keyword\">delete</span>[] data;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 在序列的第i个位置插入元素x</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqList&lt;DataType&gt;::<span class=\"hljs-built_in\">Insert</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-comment\">// 检查插入位置是否合法</span><br>    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">1</span>||i&gt;length<span class=\"hljs-number\">+1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;插入位置错误!&quot;</span>;<br>    <span class=\"hljs-comment\">// 检查序列是否已满</span><br>    <span class=\"hljs-keyword\">if</span>(length==maxSize) &#123;<br>        <span class=\"hljs-comment\">// 发生上溢,扩充存储空间</span><br>        DataType *oldData=data;<br>        maxSize+=IncreSize;<br>        data=<span class=\"hljs-keyword\">new</span> DataType[maxSize];<br>        <span class=\"hljs-comment\">// 将旧数据复制到新数组</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;length;j++) &#123;<br>            data[j]=oldData[j];<br>        &#125;<br>        <span class=\"hljs-comment\">// 释放旧数组的内存</span><br>        <span class=\"hljs-keyword\">delete</span>[] oldData;<br>    &#125;<br>    <span class=\"hljs-comment\">// 为新元素腾出空间</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=length;j&gt;=i;j--) &#123;<br>        data[j]=data[j<span class=\"hljs-number\">-1</span>];<br>    &#125;<br>    <span class=\"hljs-comment\">// 插入新元素</span><br>    data[i<span class=\"hljs-number\">-1</span>]=x;<br>    <span class=\"hljs-comment\">// 更新序列长度</span><br>    length++;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h2><h3 id=\"约瑟夫环问题\"><a href=\"#约瑟夫环问题\" class=\"headerlink\" title=\"约瑟夫环问题\"></a>约瑟夫环问题</h3><p>由于约瑟夫环问题本身具有循环性质，考虑采用循环单链表。求解约瑟夫环的问题的基本思路是：设置一个计数器count和工作指针p，当计数器累加到m时删除结点p。为了统一对链表中任意结点进行计数和删除操作，循环单链表不带头结点；为了便于删除操作设两个工作指针pre和p，指针pre指向p的前驱结点；为了使计数器从1开始奇数，采用尾指针指示的循环单链表，将指针pre初始化为指向终端结点，将指针p初始化为开始结点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<span class=\"hljs-comment\">//约瑟夫环的结点定义</span><br>    <span class=\"hljs-type\">int</span> data;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *next;<br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">JosephRing</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">JosephRing</span>(<span class=\"hljs-type\">int</span> n);<span class=\"hljs-comment\">//构造函数，初始化n个结点的循环单链表</span><br>    ~<span class=\"hljs-built_in\">JosephRing</span>();<span class=\"hljs-comment\">//析构函数，类似单链表的析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span></span>;<span class=\"hljs-comment\">//为m，打印出环的顺序</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node *rear;<br>&#125;;<br>JosephRing::~<span class=\"hljs-built_in\">JosephRing</span>() &#123;<br>    <br>&#125;<br>JosephRing::<span class=\"hljs-built_in\">JosephRing</span>(<span class=\"hljs-type\">int</span> n) &#123;<br>    Node *s=<span class=\"hljs-literal\">nullptr</span>;<br>    rear=<span class=\"hljs-keyword\">new</span> Node;<br>    rear-&gt;data=<span class=\"hljs-number\">1</span>;rear-&gt;next=rear;<span class=\"hljs-comment\">//建立长度为1的循环单链表</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++) &#123;<span class=\"hljs-comment\">//依次插入数据域为2、3...n的结点</span><br>        s=<span class=\"hljs-keyword\">new</span> Node;<br>        s-&gt;data=i;<br>        s-&gt;next=rear-&gt;next;<span class=\"hljs-comment\">//将结点s插入尾结点rear的后面</span><br>        rear-&gt;next=s;<br>        rear=s;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">JosephRing::Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> m)</span> </span>&#123;<br>    Node *pre=rear,*p=rear-&gt;next;<br>    <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">1</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;出环的顺序是:&quot;</span>;<br>    <span class=\"hljs-keyword\">while</span> (p-&gt;next!=p) &#123;<br>        <span class=\"hljs-keyword\">if</span>(count&lt;m) &#123;<br>            pre=p;p=p-&gt;next;<br>            count++;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot;\\t&quot;</span>;<br>            pre-&gt;next=p-&gt;next;<span class=\"hljs-comment\">//将p摘链</span><br>            <span class=\"hljs-keyword\">delete</span> p;<br>            p=pre-&gt;next;<span class=\"hljs-comment\">//工作指针p后移，但pre不动</span><br>            count=<span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;p-&gt;data&lt;&lt;<span class=\"hljs-string\">&quot;\\t&quot;</span>;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n,m;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入约瑟夫环的长度：&quot;</span>;<br>    cin&gt;&gt;n;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入密码：&quot;</span>;<br>    cin&gt;&gt;m;<br>    JosephRing R&#123;n&#125;;<br>    R.<span class=\"hljs-built_in\">Joseph</span>(m);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"一元多项式求和\"><a href=\"#一元多项式求和\" class=\"headerlink\" title=\"一元多项式求和\"></a>一元多项式求和</h3><p>若相加的某两项的指数不等，则两项应分别加在结果中，将引起线性表的插入；若某两项的指数相等，则系数相加，若相加结果为零，将引起线性表的删除。由于在线性表的合并过程中需要频繁地执行插入和删除操作，因此考虑采取单链表存储。</p>\n<p>在表示一元多项式的单链表中，每一个非零项对应单链表中的一个结点，且单链表应按指数递增有序排列。</p>\n<p>其中，coef 为系数域，存放非零项的系数；exp为指数域，存放非零项的指数；next 为指针域，存放指向下一结点的指针。</p>\n<p>下面分析一元多项式求和的执行过程。</p>\n<p>设单链表A和B分别存储两个多项式，求和结果存储在单链表 A 中，设两个工作指针p和q分别指向两个单链表的开始结点。</p>\n<p>两个多项式求和实质上是对结点p的指数域和结点q的指数域进行比较，有下列三种情况：</p>\n<p>① 若p一&gt;exp 小于q一&gt;exp，则结点p应为结果链表中的一个结点，将指针p后移</p>\n<p>② 若p-&gt;exp大于q一＞exp，则结点q应为结果中的一个结点，将q插入到第一个单链表中结点P之前，并将指针q指向单链表B中的下一个结点。为此，在单链表A 中应该设置两个工作指针 pre 和p，使得pre 指向p的前驱结点。</p>\n<p>③ 若p-&gt;exp等于q-&gt;exp，则p与q所指为同类项，将q的系数加到p的系数上。若相加结果不为0，则将指针P后移，并删除结点q，为此，在单链表B中应该设置两个工作指针 qre 和q，使得gre 指向q的前驱结点；若相加结果为0，则表明结果中无此项，删除结点p和结点 q，并将指针p 和指针q分别后移。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    <span class=\"hljs-type\">int</span> coef,exp;<br>    Node *next;<br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Polynomial</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Polynomial</span>();<br>    <span class=\"hljs-built_in\">Polynomial</span>(<span class=\"hljs-type\">const</span> Polynomial &amp;B);<span class=\"hljs-comment\">//拷贝构造函数</span><br>    <span class=\"hljs-comment\">/*拷贝构造函数是C++中一种特殊的构造函数，用于创建一个对象作为已存在对象的副本</span><br><span class=\"hljs-comment\">    这种构造函数的名称与类名相同，形式参数只有一个，即该类的引用类型的对象.</span><br><span class=\"hljs-comment\">    通常，这个形参会被声明为const，以确保在构造过程中不会修改原对象.</span><br><span class=\"hljs-comment\">    拷贝构造函数的主要应用场景包括，当一个对象作为值传递的参数传递给函数，</span><br><span class=\"hljs-comment\">    或者函数返回一个对象时，都需要调用到拷贝构造函数*/</span><br>    ~<span class=\"hljs-built_in\">Polynomial</span>();<br>    Polynomial <span class=\"hljs-keyword\">operator</span>+(Polynomial &amp;B);<span class=\"hljs-comment\">//重载运算符,多项式相加</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    Node *first;<span class=\"hljs-comment\">//一元多项式单链表的头指针</span><br>&#125;;<br><br>Polynomial::<span class=\"hljs-built_in\">Polynomial</span>() &#123;<br>    Node *r=<span class=\"hljs-literal\">nullptr</span>,*s=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-type\">int</span> coef,exp;<br>    first=<span class=\"hljs-keyword\">new</span> Node;<span class=\"hljs-comment\">//申请头结点</span><br>    r=first;<span class=\"hljs-comment\">//尾插法建立单链表</span><br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入系数和指数&quot;</span>;<br>    cin&gt;&gt;coef&gt;&gt;exp;<br>    <span class=\"hljs-keyword\">while</span> (coef!=<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//循环结束的条件是输入系数为0</span><br>        s=<span class=\"hljs-keyword\">new</span> Node;<br>        s-&gt;coef=coef;s-&gt;exp=exp;<br>        r-&gt;next=s;r=s;<span class=\"hljs-comment\">//将结点s插入单链表的尾部</span><br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入系数和指数&quot;</span>;<br>        cin&gt;&gt;coef&gt;&gt;exp;<br>    &#125;<br>    r-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>&#125;<br>Polynomial::<span class=\"hljs-built_in\">Polynomial</span>(<span class=\"hljs-type\">const</span> Polynomial &amp;B) &#123;<br>    first=B.first;<br>&#125;<br>Polynomial::~<span class=\"hljs-built_in\">Polynomial</span>() &#123;<br><br>&#125;<br>Polynomial Polynomial::<span class=\"hljs-keyword\">operator</span>+(Polynomial &amp;B) &#123;<br>    Node *pre=first,*p=pre-&gt;next;<span class=\"hljs-comment\">//工作指针pre和p初始化</span><br>    Node *qre=B.first,*q=qre-&gt;next;<span class=\"hljs-comment\">//工作指针qre和q初始化</span><br>    Node *qtemp=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; q!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;exp &lt; q-&gt;exp) &#123;<span class=\"hljs-comment\">//第1种情况</span><br>            pre=p;p=p-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(p-&gt;exp &gt; q-&gt;exp) &#123;<span class=\"hljs-comment\">//第2种情况</span><br>            qtemp=q-&gt;next;<br>            pre-&gt;next=q;<span class=\"hljs-comment\">//将结点q插入到结点p之前</span><br>            q-&gt;next=p;<br>            pre=q;<br>            q=qtemp;<br>            qre-&gt;next=q;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//第3种情况</span><br>            p-&gt;coef=p-&gt;coef+q-&gt;coef;<br>            <span class=\"hljs-keyword\">if</span>(p-&gt;coef==<span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//系数相加为0,则删除结点p</span><br>                pre-&gt;next=p-&gt;next;<br>                <span class=\"hljs-keyword\">delete</span> p;<br>                p=pre-&gt;next;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                pre=p;<br>                p=p-&gt;next;<br>            &#125;<br>            qre-&gt;next=q-&gt;next;<span class=\"hljs-comment\">//第3种情况都要删除结点q</span><br>            <span class=\"hljs-keyword\">delete</span> q;<br>            q=qre-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(q!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        pre-&gt;next=q;<span class=\"hljs-comment\">//将结点q链接到第一个单链表的后面</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Polynomial::Print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Node *p=first-&gt;next;<br>    <span class=\"hljs-keyword\">if</span>(p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<span class=\"hljs-comment\">//输出第一项</span><br>        cout&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>    &#125;<br>    p=p-&gt;next;<br>    <span class=\"hljs-keyword\">while</span> (p!=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(p-&gt;coef&gt;<span class=\"hljs-number\">0</span>) &#123;<br>            cout&lt;&lt;<span class=\"hljs-string\">&quot;+&quot;</span>&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            cout&lt;&lt;p-&gt;coef&lt;&lt;<span class=\"hljs-string\">&quot;x^&quot;</span>&lt;&lt;p-&gt;exp;<br>        &#125;<br>        p=p-&gt;next;<br>    &#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Polynomial A&#123;&#125;,B&#123;&#125;;<br>    A.<span class=\"hljs-built_in\">Print</span>();<br>    B.<span class=\"hljs-built_in\">Print</span>();<br>    A=A+B;<span class=\"hljs-comment\">//运算符重载，对象赋值调用拷贝构造函数</span><br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;结果是：&quot;</span>;<br>    A.<span class=\"hljs-built_in\">Print</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight parser3\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs parser3\"><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">7</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">12</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">3</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">-2</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">8</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">5</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">12</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">0</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">4</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">1</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">6</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">3</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">2</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">8</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">5</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">20</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">7</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">请输入系数和指数</span><span class=\"hljs-number\">0</span><span class=\"language-xml\"> </span><span class=\"hljs-number\">0</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^0</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">12</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3-2x</span><span class=\"hljs-keyword\">^8</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^12</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><span class=\"hljs-number\">4</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^1</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">6</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">2</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^8</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^20</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\">结果是：</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^0</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">4</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^1</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">18</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^3</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^12</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">5</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^20</span><span class=\"language-xml\">+</span><span class=\"hljs-number\">7</span><span class=\"language-xml\">x</span><span class=\"hljs-keyword\">^28</span><span class=\"language-xml\"></span><br><span class=\"language-xml\"></span><br><span class=\"language-xml\">进程已结束，退出代码为 </span><span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"思想火花\"><a href=\"#思想火花\" class=\"headerlink\" title=\"思想火花\"></a>思想火花</h2><p> <strong>实验问题：</strong></p>\n<p>  将一个具有n个元素的数组向左循环移动i个位置。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>如图1 数组元素循环左移1位：</p>\n<p><img src=\"/img%5C1485495-20190604181312769-273893486.png\" alt=\"数组元素循环左移1位\"></p>\n<p>将一个具有n个元素的数组向左循环移动i个位置，<strong>意味着将数组的前i个元素移动到数组的末尾，而原数组中的其余元素则相应地向左移动</strong></p>\n</blockquote>\n<p> 有许多应用程序会调用这个问题的算法，例如在文本编辑器中移动行的操作，磁盘整理时交换两个不同大小的相邻内存块等。所以，这个问题的算法要求有较高的时间和空间性能。 </p>\n<p><strong>基本要求：</strong></p>\n<p>  ⑴在原数组中实现循环右移，不另外申请空间；</p>\n<p>  ⑵时间性能尽可能好；</p>\n<p>   ⑶分析算法的时间复杂度。</p>\n<p> 要在不另申请空间的情况下，保证算法的时间性能尽可能好，如果先设计一个函数将数组向左移动一位，然后再调用该算法i次，是一些人通常想到的方法，但显然这个算法的时间性能不是最好的。要在有限的资源中解决这个问题，似乎比较困难，是否存在这种既不另申请存储空间，又能够达到最好时间性能的完美算法呢。</p>\n<p>  <strong>求解步骤：</strong></p>\n<p>1）可以通过下面的方法解决这个问题：先将数组中的前i个元素存放在一个临时数组中，再将余下的n-i个元素左移i个位置， 最后将前i个元素从临时数组复制回原数组中后面的位置。但是这个算法使用了i个额外的存储单元，使得空间性能降低。</p>\n<p>2）如上所述，先设计一个函数将数组向左循环移动一个位置，然后再调用该算法i次， 显然，这个算法的时间性能不好。 </p>\n<p> 3）现在我们换一个角度看这个问题： 将这个问题看作是把数组ab转换成数组ba（a代表数组的前i个元素，b代表数组中余下的n-i个元素）， 先将a逆置得到ar b，再将b逆置得到ar br，最后将整个ar br逆置得到(ar br)r&#x3D;ba。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>数组元素逆置是指将数组中的元素按照相反的顺序重新排列，即第一个元素和最后一个元素交换，第二个元素和倒数第二个元素交换，以此类推，直到所有元素都逆序排列完毕</strong>。</p>\n</blockquote>\n<p>设Reverse函数执行将数组元素逆置的操作， 对abcdefgh向左循环移动3个位置的过程如下：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\"><span class=\"hljs-built_in\">Reverse</span>(<span class=\"hljs-number\">0</span>, i-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到cbadefgh(逆置abc)</span><br><span class=\"hljs-built_in\">Reverse</span>(i, n-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到cbahgfed(逆置defgh)</span><br><span class=\"hljs-built_in\">Reverse</span>(<span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//得到defghabc(逆置cbahgfed)</span><br></code></pre></td></tr></table></figure>\n\n<p>其原理可以用一个简单的游戏来理解：将两手的掌心对着自己，左手在右手上面， 可以实现将一个具有10 个元素的数组向左循环移动5位，如图所示。</p>\n<p><img src=\"/img%5C1358339139_6806.jpg\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">reverseArr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> start,<span class=\"hljs-type\">int</span> rear)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=start,j=rear;i&lt;j;i++,j--) &#123;<br>        <span class=\"hljs-type\">int</span> t=A[i];<br>        A[i]=A[j];<br>        A[j]=t;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">leftCir</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> k)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(k&lt;=<span class=\"hljs-number\">0</span> || k&gt;=n)<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;ERROR&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,<span class=\"hljs-number\">0</span>,k<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,k,n<span class=\"hljs-number\">-1</span>);<br>        <span class=\"hljs-built_in\">reverseArr</span>(A,<span class=\"hljs-number\">0</span>,n<span class=\"hljs-number\">-1</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> A[],<span class=\"hljs-type\">int</span> n)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;++i)<br>        cout&lt;&lt;A[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n,p;<br>    cin&gt;&gt;n&gt;&gt;p;<br>    <span class=\"hljs-type\">int</span> a[n];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;++i)<br>        cin&gt;&gt;a[i];<br>    <span class=\"hljs-built_in\">leftCir</span>(a,n,p);<br>    <span class=\"hljs-built_in\">show</span>(a,n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该算法在时间和空间上都很有效，并且是这么简短和简单，想出错都很难。 Brian Kernighan在Software Tools in Pascal中使用了这个算法在文本编辑器中移动各行。</p>\n<p><a href=\"https://openlibrary.org/books/OL4258115M/Software_tools_in_Pascal\">Software tools in Pascal by Brian W. Kernighan | 开放图书馆 (openlibrary.org)</a></p>\n<blockquote>\n<p>Brian Kernighan 在他的著作 <em>Software Tools in Pascal</em> 中，讨论了一个将 n 个元素的数组向左循环移动 i 个位置的算法。原文如下：</p>\n<p>“To rotate an array left by i positions, reverse the first i elements, then reverse the remaining n-i elements, and finally reverse the entire array.”</p>\n<p>翻译过来大致是：</p>\n<p>“要将一个数组向左循环移动 i 个位置，首先反转数组的前 i 个元素，然后反转剩下的 n-i 个元素，最后反转整个数组。”</p>\n<p>这种方法基于三个步骤的反转操作，可以高效地完成数组的左循环移动。</p>\n</blockquote>\n<p>作为一个规律，一个好的算法是反复努力和重新修正的结果，即使足够幸运地得到了一个貌似完美的算法思想， 我们也应该尝试着改进它。 </p>\n<h2 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h2><h1 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>栈是限定仅在表的一段进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>插入元素——入栈、进栈、压栈</p>\n<p>删除元素——出栈、弹栈</p>\n</blockquote>\n<p>栈中元素除了具有线性关系外，还具有***&#x3D;&#x3D;后进先出&#x3D;&#x3D;***的特性</p>\n<p>栈的顺序存储结构称为顺序栈，本质上是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底</p>\n<p>通常把数组中下标为0的一段作为栈底，同时附设变量top指示栈顶元素在数组中的位置</p>\n<p>设存储栈的数组长度为StackSize，则栈空时栈顶位置top&#x3D;-1；栈满时栈顶位置top&#x3D;StackSize-1</p>\n<blockquote>\n<p>[!TIP]</p>\n<p>在有些教程中，将top指向栈中第一个空闲位置，如果这样的话，空栈应该表示为top&#x3D;0</p>\n</blockquote>\n<p>入栈时，栈顶位置top加1；出栈时，栈顶位置top减1</p>\n<h3 id=\"顺序栈的实现\"><a href=\"#顺序栈的实现\" class=\"headerlink\" title=\"顺序栈的实现\"></a>顺序栈的实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">10</span>;<span class=\"hljs-comment\">//</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">SeqStack</span>();<span class=\"hljs-comment\">//初始化一个空栈</span><br>    ~<span class=\"hljs-built_in\">SeqStack</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x入栈</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出栈操作，将栈顶元素弹出</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取栈顶元素(并不删除)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断栈是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<br>    <span class=\"hljs-type\">int</span> top;<span class=\"hljs-comment\">//栈顶元素在数组中的下标</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">SeqStack</span>() &#123;<br>    top=<span class=\"hljs-number\">-1</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>SeqStack&lt;DataType&gt;::~<span class=\"hljs-built_in\">SeqStack</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==StackSize<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    data[++top]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top++;</span><br><span class=\"hljs-comment\">    s[top] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>() &#123;<br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    x=data[top--];<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    x=data[top];</span><br><span class=\"hljs-comment\">    top--;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">GetTop</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> data[top];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> SeqStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    SeqStack&lt;<span class=\"hljs-type\">int</span>&gt; S&#123;&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;对15和10入栈&quot;</span>;<br>    S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">15</span>);S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">10</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前栈顶元素为:&quot;</span>&lt;&lt;S.<span class=\"hljs-built_in\">GetTop</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=S.<span class=\"hljs-built_in\">Pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;出栈&quot;</span>&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入待入栈元素&quot;</span>;<br>        cin&gt;&gt;x;<br>        S.<span class=\"hljs-built_in\">Push</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(S.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"栈的链接存储结构及实现\"><a href=\"#栈的链接存储结构及实现\" class=\"headerlink\" title=\"栈的链接存储结构及实现\"></a>栈的链接存储结构及实现</h3><p>栈的链接存储结构称为链栈，通常用单链表表示，其节点结构与单链表的结点结构相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>因为只能在栈顶执行入栈(插入)和出栈(删除)操作，所以以单链表的头部做栈顶是最方便的，而且没有必要像单链表那样为了运算方便附加头结点</p>\n<blockquote>\n<p>[!TIP]</p>\n<p>在单链表中，如果我们将头部用作栈顶（top），那么入栈和出栈操作都会非常高效，这是因为单链表的特性允许我们在头部进行 O(1) 时间复杂度的操作。</p>\n<p>具体来说，有以下几点原因：</p>\n<ol>\n<li><strong>插入操作</strong>：当我们需要向栈中添加一个元素时（即入栈操作），我们只需要创建一个新的节点，并让它指向当前的头部（即当前栈顶），然后更新头部指针指向这个新节点。这样的操作不需要遍历整个链表来找到插入位置，因此时间复杂度为 O(1)。</li>\n<li><strong>删除操作</strong>：当我们需要从栈中移除一个元素时（即出栈操作），我们只需改变头部指针，让它指向原来的头部所指向的下一个节点，并释放原来的头部节点即可。这也同样是一个 O(1) 的操作。</li>\n<li><strong>访问栈顶元素</strong>：由于头部就是栈顶，访问栈顶元素也仅需要返回头部指针指向的节点的数据，这也是 O(1) 的操作。</li>\n</ol>\n<p>关于是否需要附加头结点（dummy head）的问题，通常情况下，如果单链表只用于实现栈的功能，并且不需要支持其他额外操作（比如查找特定元素等），那么就没有必要设置一个额外的头结点。因为所有的操作都在头部进行，直接将头部视为栈顶已经足够高效了。</p>\n</blockquote>\n<p>时间复杂度 —— O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkStack</span>();<br>    ~<span class=\"hljs-built_in\">LinkStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x入栈</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出栈操作，将栈顶元素弹出</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取栈顶元素(并不删除)</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断栈是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *top;<span class=\"hljs-comment\">//栈顶指针即链栈的头指针</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkStack</span>() &#123;<br>    top=<span class=\"hljs-literal\">nullptr</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkStack&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkStack</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;data=x;<br>    s-&gt;next=top;<br>    top=s;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>() &#123;<br>    Node&lt;DataType&gt; *p=<span class=\"hljs-literal\">nullptr</span>;<br>    DataType x;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    x=top-&gt;data;<br>    p=top;<br>    top=top-&gt;next;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">GetTop</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> top-&gt;data;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-literal\">nullptr</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    LinkStack&lt;<span class=\"hljs-type\">int</span>&gt; S&#123;&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;对15和10入栈&quot;</span>;<br>    S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">15</span>);S.<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-number\">10</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前栈顶元素为:&quot;</span>&lt;&lt;S.<span class=\"hljs-built_in\">GetTop</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=S.<span class=\"hljs-built_in\">Pop</span>();<br>        cout&lt;&lt;x&lt;&lt;<span class=\"hljs-string\">&quot;出栈&quot;</span>&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入待入栈元素&quot;</span>;<br>        cin&gt;&gt;x;<br>        S.<span class=\"hljs-built_in\">Push</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(S.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;栈非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"顺序栈和链栈的比较\"><a href=\"#顺序栈和链栈的比较\" class=\"headerlink\" title=\"顺序栈和链栈的比较\"></a>顺序栈和链栈的比较</h3><p>作为一般规律，当栈的使用过程中元素变化较大时，应该采用链栈，反之，应使用顺序栈</p>\n<h3 id=\"STL中的栈\"><a href=\"#STL中的栈\" class=\"headerlink\" title=\"STL中的栈\"></a>STL中的栈</h3><p>C++ Stack(堆栈) 是一个容器类的改编，为程序员提供了堆栈的全部功能，–也就是说实现了一个先进后出(FILO)的数据结构。</p>\n<p>栈stack的头文件为:</p>\n<p>#include <stack></p>\n<h4 id=\"c-stl栈stack的成员函数介绍\"><a href=\"#c-stl栈stack的成员函数介绍\" class=\"headerlink\" title=\"c++ stl栈stack的成员函数介绍\"></a>c++ stl栈stack的成员函数介绍</h4><p>操作   比较和分配堆栈</p>\n<p>empty()堆栈为空则返回真</p>\n<p>pop()移除栈顶元素(删除)</p>\n<p>push()在栈顶增加元素(增加)</p>\n<p>size() 返回栈中元素数目</p>\n<p>top() 返回栈顶元素，不删除(获取)</p>\n<h5 id=\"1-什么是stack\"><a href=\"#1-什么是stack\" class=\"headerlink\" title=\"1.什么是stack\"></a>1.什么是<a href=\"https://so.csdn.net/so/search?q=stack&spm=1001.2101.3001.7020\">stack</a></h5><p><strong>1. stack</strong>是一种<strong>容器适配器</strong>，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行 元素的插入与提取操作。**(后进先出)**</p>\n<p><strong>2. stack</strong>是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定 的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。</p>\n<p><strong>3. stack</strong>的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下</p>\n<p><strong>操作：</strong></p>\n<blockquote>\n<p><strong>empty：判空操作</strong></p>\n<p><strong>back：获取尾部元素操作</strong></p>\n<p><strong>push_back：尾部插入元素操作</strong></p>\n<p><strong>pop_back：尾部删除元素操作</strong></p>\n</blockquote>\n<p><strong>4.</strong> 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器， 默认情况下使用deque。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/667251d46c039b39d506132e9fa06b51.png\" alt=\"img\"></p>\n<h5 id=\"2-容器适配器\"><a href=\"#2-容器适配器\" class=\"headerlink\" title=\"2.容器适配器\"></a>2.容器适配器</h5><p><strong>容器适配器（Container Adapters）是 C++ 标准库提供的一种数据结构，它们基于现有的容器类型，提供了特定的接口和功能，以便更方便地实现某些特定的数据结构和算法</strong>。容器适配器本质上是对底层容器的封装，提供了不同的数据访问方式，使它们适用于特定的用途。 </p>\n<p><strong>标准库中提供了三种常用的容器适配器：</strong></p>\n<blockquote>\n<p>**<em>*stack：栈适配器*<em>，基于底层容器提供了栈数据结构的操作，如压入（push）、弹出（pop）、查看栈顶元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。</em></em></p>\n<p>**<em>*queue：队列适配器*<em>，基于底层容器提供了队列数据结构的操作，如入队（push）、出队（pop）、查看队首元素等。默认底层容器是 deque，但也可以使用其他支持 back() 和 push_back() 操作的容器。</em></em></p>\n<p>**<em>*priority_queue：优先队列适配器*<em>，基于底层容器提供了优先队列数据结构的操作，支持在插入元素时根据优先级进行排序。默认底层容器是 vector，但也可以使用其他支持随机访问和插入操作的容器。</em></em></p>\n</blockquote>\n<h5 id=\"3-stack的使用\"><a href=\"#3-stack的使用\" class=\"headerlink\" title=\"3.stack的使用\"></a>3.stack的使用</h5><p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8591236db69c7870d8bd8f1c680badcb.png\" alt=\"img\"></p>\n<p>这些是C++<a href=\"https://so.csdn.net/so/search?q=%E6%A0%87%E5%87%86%E5%BA%93&spm=1001.2101.3001.7020\">标准库</a>中stack类的构造函数声明。stack是一个适配器容器，它可以使用不同的底层容器来实现栈的功能。这些构造函数声明提供了不同的方式来创建和初始化stack对象，可以根据需求选择合适的构造函数。 </p>\n<blockquote>\n<p><strong>stack的Construct中除了构造函数，其他什么都没有，它连拷贝构造、析构都没有。这个也跟它是容器适配器有关系，因为它的成员都是自定义类型，编译器默认生成的就够用。</strong></p>\n<p><strong>stack是容器适配器以后，就开始不支持迭代器了。容器支持迭代器，容器适配器不支持迭代器。</strong></p>\n<p><strong>栈随便去遍历反而是不好的，因为要保证后进先出的性质。</strong></p>\n<p><strong>所以取数据得用top，想取下一个数据就得先pop。</strong></p>\n</blockquote>\n<h5 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a><a href=\"https://so.csdn.net/so/search?q=top&spm=1001.2101.3001.7020\">top</a></h5><p>reference top(); 和 const_reference top() const; 是 C++ 标准库中 std::stack 类的成员函数之一。它们用于获取栈顶元素的引用。</p>\n<p>reference top();：返回栈顶元素的引用。如果需要修改栈顶元素，可以使用这个版本。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br> <br>\t\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br> <br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">42</span>);<br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">15</span>);<br> <br>\t\t<span class=\"hljs-comment\">// 使用 top() 获取栈顶元素</span><br>\t\t<span class=\"hljs-type\">int</span> topElement = m.<span class=\"hljs-built_in\">top</span>();<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Top element: &quot;</span> &lt;&lt; topElement &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-comment\">// 修改栈顶元素</span><br>\t\tm.<span class=\"hljs-built_in\">top</span>() = <span class=\"hljs-number\">99</span>;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;New top element: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">top</span>() &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t<br> <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> <img src=\"https://i-blog.csdnimg.cn/blog_migrate/af9dbb720d78efb612f5c4bb64dbb6ec.png\" alt=\"img\"></p>\n<p>后进先出，15先出，然后修改为99，最后出99</p>\n<h5 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h5><p><strong>是 C++ 标准库中 <code>std::stack</code> 类的成员函数之一。它们用于将一个新的元素压入栈中。</strong></p>\n<p><strong>这两个版本的 push 函数允许你在栈顶添加新的元素。如果需要保持传入值的不变性，可以使用第一个版本；如果你想利用移动语义来避免不必要的复制，可以使用第二个版本。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br> <br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br> <br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 使用右值，将 10 压入栈中</span><br>\t\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">19</span>);<br> <br>\t\t<span class=\"hljs-type\">int</span> newElement = <span class=\"hljs-number\">99</span>;<br>\t\tm.<span class=\"hljs-built_in\">push</span>(newElement); <span class=\"hljs-comment\">// 使用常量引用，将 newElement 压入栈中</span><br> <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br> <br>\t\t<span class=\"hljs-keyword\">while</span> (!m.<span class=\"hljs-built_in\">empty</span>())  <span class=\"hljs-comment\">// 遍历不能用迭代器，容器适配器不支持迭代器</span><br>\t\t&#123;<br>\t\t\tcout &lt;&lt; m.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出栈顶元素</span><br>\t\t\tm.<span class=\"hljs-built_in\">pop</span>(); <span class=\"hljs-comment\">// 弹出栈顶元素</span><br>\t\t&#125;<br> <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/fe6f4bb4063818fce45d827a5bc7661c.png\" alt=\"img\"></p>\n<h5 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h5><p><strong><code>void pop();</code> 是 C++ 标准库中 <code>stack</code> 类的成员函数之一。它用于将栈顶元素弹出（删除）。</strong></p>\n<p><strong>这个函数没有返回值，它只是从栈中移除栈顶元素。在调用 <code>pop()</code> 函数之前，需要确保栈不为空，否则会导致未定义行为。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; m;<br><br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 使用右值，将 10 压入栈中</span><br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">19</span>);<br>\tm.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">29</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\tm.<span class=\"hljs-built_in\">pop</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Stack new size: &quot;</span> &lt;&lt; m.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/84b16ae75feec2ff17399e8a5edab7b8.png\" alt=\"img\"></p>\n<h5 id=\"公共成员函数：\"><a href=\"#公共成员函数：\" class=\"headerlink\" title=\"公共成员函数：\"></a><strong>公共成员函数</strong>：</h5><blockquote>\n<p>push(const T&amp; x)：将传入的元素值 x 添加到底层容器的末尾，实现了入栈操作。</p>\n<p>pop()：从底层容器的末尾删除一个元素，实现了出栈操作。</p>\n<p>T&amp; top() 和 const T&amp; top() const：分别返回底层容器的末尾元素的引用（允许修改）和常量引用（只读），实现了查看栈顶元素操作。</p>\n<p>bool empty() const：返回底层容器是否为空。</p>\n<p>size_t size() const：返回底层容器中元素的数量。</p>\n<p>私有成员变量 _con：这是一个模板类的私有成员变量，用于存储实际的栈元素。其类型是根据模板参数 Container 确定的，在实例化时会被替换为具体的容器类型。</p>\n</blockquote>\n<h3 id=\"实例-o2r函数，用于将整数n转换为基数r的字符串表示\"><a href=\"#实例-o2r函数，用于将整数n转换为基数r的字符串表示\" class=\"headerlink\" title=\"实例(o2r函数，用于将整数n转换为基数r的字符串表示)\"></a>实例(o2r函数，用于将整数n转换为基数r的字符串表示)</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义o2r函数，用于将整数n转换为基数r的字符串表示</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">o2r</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 使用栈来存储转换过程中的每一位数字</span><br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; s;<br>    <span class=\"hljs-comment\">// base数组用于将十进制数转换为r进制的字符表示</span><br>    <span class=\"hljs-type\">char</span> base[] = <span class=\"hljs-string\">&quot;0123456789ABCDEF&quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 当n不为0时，继续转换过程</span><br>    <span class=\"hljs-keyword\">while</span> (n) &#123;<br>        <span class=\"hljs-comment\">// 取n除以r的余数，得到当前位的值，并将其加入栈中</span><br>        s.<span class=\"hljs-built_in\">push</span>(base[n % r]);<br>        <span class=\"hljs-comment\">// 更新n为n除以r的商，继续下一位的计算</span><br>        n = n / r;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 当栈不为空时，依次取出栈中的元素并输出，完成r进制数的构建</span><br>    <span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        cout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>();<br>        <span class=\"hljs-comment\">// 取出栈顶元素后，将其从栈中移除</span><br>        s.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 在输出后换行，以便于阅读</span><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 示例：将10进制的255转换为16进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的255转换为16进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">16</span>); <span class=\"hljs-comment\">// 输出: FF</span><br><br>    <span class=\"hljs-comment\">// 示例：将10进制的100转换为2进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的100转换为2进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 输出: 1100100</span><br><br>    <span class=\"hljs-comment\">// 示例：将10进制的1234转换为8进制</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;10进制的1234转换为8进制：&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">o2r</span>(<span class=\"hljs-number\">1234</span>, <span class=\"hljs-number\">8</span>); <span class=\"hljs-comment\">// 输出: 2322</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入(入队、进队)的一端称为队尾，允许删除(出队)的一端称为队头。</p>\n<p>队列中的元素除了具有线性关系外，还具有&#x3D;&#x3D;<em><strong>先进先出</strong></em>&#x3D;&#x3D;的特性</p>\n<h3 id=\"队列的顺序存储结构及实现\"><a href=\"#队列的顺序存储结构及实现\" class=\"headerlink\" title=\"队列的顺序存储结构及实现\"></a>队列的顺序存储结构及实现</h3><p>队列的顺序存储结构称为顺序队列。假设队列有n个元素，顺序队列把队列的所有元素存储在数组的前n个单元。如果把队头元素放在数组中下标为0的一端，则入队操作相当于追加，不需要移动元素，其时间性能为O(1)，但是出队操作的时间性能为O(n)，因为要保证剩下的n-1个元素仍然存储在数组的前n-1个单元，所有元素都要向前移动一个位置。</p>\n<p>如果放宽队列的所有元素必须存储在数组的前n个单元这一条件，就可以得到一种更为有效的存储方式。此时入队和出队操作的时间性能都是O(1)，因为没有移动任何元素。需要设置队头、队尾两个位置变量front和rear，入队时rear加1，出队时front加1，并且约定：front指向队头元素的前一个位置，rear指向队尾元素的位置。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>这样约定的目的是方便运算，例如rear-front等于队列的长度。</p>\n</blockquote>\n<h3 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h3><p>在顺序队列中，随着队列的插入和删除操作，整个队列向数组的高端移过去，从而产生了队列的“单向移动性”。当元素被插入到数组中下标最大的位置之后，数组空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫做“假溢出”</p>\n<p>解决假溢出的方法是将存储队列的数组看成是头尾相接的循环结构，这可以通过取模操作来实现，设存储队列的数组长度为QueueSize，操作语句为rear&#x3D;(rear+1)%QueueSize</p>\n<p>队列的这种头尾相接的顺序存储结构称为循环队列。</p>\n<p>队空的条件是front&#x3D;rear</p>\n<p>队满的条件是(rear+1)%QueueSize&#x3D;front</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> QueueSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CirQueue</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">CirQueue</span>();<span class=\"hljs-comment\">//构造函数，初始化空队列</span><br>    ~<span class=\"hljs-built_in\">CirQueue</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueue</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">DeQueue</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取队头元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断队列是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[QueueSize];<span class=\"hljs-comment\">//存放队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front,rear;<span class=\"hljs-comment\">//游标，队头和队尾指针</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">CirQueue</span>() &#123;<br>    rear=front=QueueSize<span class=\"hljs-number\">-1</span>;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>CirQueue&lt;DataType&gt;::~<span class=\"hljs-built_in\">CirQueue</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">EnQueue</span>(DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>((rear<span class=\"hljs-number\">+1</span>)%QueueSize==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    rear=(rear<span class=\"hljs-number\">+1</span>)%QueueSize;<span class=\"hljs-comment\">//队尾指针在循环意义下加1</span><br>    data[rear]=x;<span class=\"hljs-comment\">//在队尾处插入元素</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">DeQueue</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    front=(front<span class=\"hljs-number\">+1</span>)%QueueSize;<span class=\"hljs-comment\">//队头在循环意义下加1</span><br>    <span class=\"hljs-keyword\">return</span> data[front];<span class=\"hljs-comment\">//返回出队前的队头元素</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">GetHead</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    <span class=\"hljs-keyword\">return</span> data[(front<span class=\"hljs-number\">+1</span>)%QueueSize];<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> CirQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span> (rear==front) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    CirQueue&lt;<span class=\"hljs-type\">int</span>&gt; Q&#123;&#125;;<br>    Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">5</span>);Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">8</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前队头元素为：&quot;</span>&lt;&lt;Q.<span class=\"hljs-built_in\">GetHead</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=Q.<span class=\"hljs-built_in\">DeQueue</span>();<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行一次出队操作，出队元素是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入入队元素:&quot;</span>;<br>        cin&gt;&gt;x;<br>        Q.<span class=\"hljs-built_in\">EnQueue</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(Q.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"队列的链存储结构及实现\"><a href=\"#队列的链存储结构及实现\" class=\"headerlink\" title=\"队列的链存储结构及实现\"></a>队列的链存储结构及实现</h3><p>队列的链接存储结构称为链队列，通常用单链表表示，其结点结构与单链表的结点结构相同</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>为了使空队列和非空队列的操作一致，链队列也加上头结点；为了操作上的方便，设置队头指针指向链队列的头结点，队尾指针指向终端结点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    DataType data;<br>    Node&lt;DataType&gt;* next;<br>&#125;;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkQueue</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkQueue</span>();<span class=\"hljs-comment\">//构造函数，初始化空队列</span><br>    ~<span class=\"hljs-built_in\">LinkQueue</span>();<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueue</span><span class=\"hljs-params\">(DataType x)</span></span>;<span class=\"hljs-comment\">//入队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">DeQueue</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//出队</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//取队头元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//判断队列是否为空</span><br><span class=\"hljs-keyword\">private</span>:<br>    Node&lt;DataType&gt; *front,*rear;<span class=\"hljs-comment\">//队头和队尾指针</span><br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">LinkQueue</span>() &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    front=rear=s;<span class=\"hljs-comment\">//将队头指针和队尾指针都指向头结点s</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>LinkQueue&lt;DataType&gt;::~<span class=\"hljs-built_in\">LinkQueue</span>() &#123;<br><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">EnQueue</span>(DataType x) &#123;<br>    Node&lt;DataType&gt; *s=<span class=\"hljs-literal\">nullptr</span>;<br>    s=<span class=\"hljs-keyword\">new</span> Node&lt;DataType&gt;;<br>    s-&gt;data=x;s-&gt;next=<span class=\"hljs-literal\">nullptr</span>;<br>    rear-&gt;next=s;<br>    rear=s;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">DeQueue</span>() &#123;<br>    DataType x;<br>    Node&lt;DataType&gt; *p=<span class=\"hljs-literal\">nullptr</span>;<br>    <span class=\"hljs-keyword\">if</span>(rear==front)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>    p=front-&gt;next;x=p-&gt;data;<br>    front-&gt;next=p-&gt;next;<br>    <span class=\"hljs-keyword\">if</span>(p-&gt;next==<span class=\"hljs-literal\">nullptr</span>)&#123;<span class=\"hljs-comment\">//出队前队列长度为1</span><br>        rear=front;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    <span class=\"hljs-keyword\">return</span> x;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">GetHead</span>() &#123;<br>    <span class=\"hljs-keyword\">return</span> front-&gt;next-&gt;data;<br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">int</span> LinkQueue&lt;DataType&gt;::<span class=\"hljs-built_in\">Empty</span>() &#123;<br>    <span class=\"hljs-keyword\">if</span>(front==rear) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> x;<br>    LinkQueue&lt;<span class=\"hljs-type\">int</span>&gt; Q&#123;&#125;;<br>    Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">5</span>);Q.<span class=\"hljs-built_in\">EnQueue</span>(<span class=\"hljs-number\">8</span>);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;当前队头元素为：&quot;</span>&lt;&lt;Q.<span class=\"hljs-built_in\">GetHead</span>()&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        x=Q.<span class=\"hljs-built_in\">DeQueue</span>();<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;执行一次出队操作，出队元素是：&quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入入队元素:&quot;</span>;<br>        cin&gt;&gt;x;<br>        Q.<span class=\"hljs-built_in\">EnQueue</span>(x);<br>    &#125;<span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">char</span> *str)&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;<br>    <span class=\"hljs-keyword\">if</span>(Q.<span class=\"hljs-built_in\">Empty</span>()==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列为空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;队列非空&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"循环队列和链队列的比较\"><a href=\"#循环队列和链队列的比较\" class=\"headerlink\" title=\"循环队列和链队列的比较\"></a>循环队列和链队列的比较</h3><p>循环队列和链队列基本操作的时间复杂度均为O(1)，因此可以比较的只有空间性能。作为一般规律，当队列中元素个数变化较大时，应采用链队列，反之，应该采用循环队列，如果确定不会发生假溢出，也可以采用顺序队列</p>\n<h2 id=\"扩展与提高-1\"><a href=\"#扩展与提高-1\" class=\"headerlink\" title=\"扩展与提高\"></a>扩展与提高</h2><h3 id=\"两栈共享空间\"><a href=\"#两栈共享空间\" class=\"headerlink\" title=\"两栈共享空间\"></a>两栈共享空间</h3><p>在一个程序中，如果同时使用具有相同数据类型的两个顺序栈，最直接的方法是为每个栈开辟一个数组空间，这样做的结果可能出现一个栈的空间已被占满而无法再进行插入操作，同时另一个栈的空间仍有大量剩余而没有得到利用的情况，从而造成存储空间的浪费。</p>\n<p>可以充分利用顺序栈单向延伸的特性，使用一个数组来存储两个栈，让一个栈的栈底位于该数组的始端，另一个栈的栈底位于该数组的末端，每个栈从各自的端点向中间延伸。</p>\n<p>其中，topl 和 top2分别为栈1 和栈2 的栈顶位置，StackSize 为整个数组空间的大小，栈1的底位于下标为。的一端；栈2的底位于下标为 StackSize一1 的一端。</p>\n<p>在两栈共享空间中，由于两个栈相向增长，浪费的数组空间就会减少，同时发生上溢的概率也会减少。<strong>但是，只有当两个栈的空间需求有相反的关系时，这种方法才会奏效，也就是说，最好一个栈增长时另一个栈缩短。</strong>下面给出两栈共享空间的类定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BothStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BothStack</span>();<span class=\"hljs-comment\">//构造函数，将两个栈分别初始化</span><br>    ~<span class=\"hljs-built_in\">BothStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x压入栈i</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//出栈操作，对栈i执行出栈操作</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//取栈i的栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//判断栈i是否为空栈</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<span class=\"hljs-comment\">//存放两个栈的数组</span><br>    <span class=\"hljs-type\">int</span> top1,top2;<span class=\"hljs-comment\">//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>设整型变量i只取1和2两个值。当i&#x3D;1时，表示对栈1操作；当i&#x3D;2时，表示对栈2操作</p>\n<p>下面讨论两栈共享空间的入栈和出栈操作：</p>\n<h4 id=\"入栈\"><a href=\"#入栈\" class=\"headerlink\" title=\"入栈\"></a>入栈</h4><p>当存储栈的数组中没用空闲单元时为栈满，此时栈1的栈顶元素和栈2的栈顶元素位于数组中的相邻位置，即top1&#x3D;top2-1。另外，当新元素插入栈2时，栈顶位置top2不是加一而是减一</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top1==top2<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>)data[++top1]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top1++;</span><br><span class=\"hljs-comment\">    data[top1] = x;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>)data[--top2]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top2--;</span><br><span class=\"hljs-comment\">    data[top2] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"出栈\"><a href=\"#出栈\" class=\"headerlink\" title=\"出栈\"></a>出栈</h4><p>当top1&#x3D;-1时栈1为空，当top2&#x3D;StackSize时栈2为空。另外，当从栈2删除元素时，top2不是减一而是加一</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top1==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top1--];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top2==StackSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top2++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> StackSize=<span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BothStack</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">BothStack</span>();<span class=\"hljs-comment\">//构造函数，将两个栈分别初始化</span><br>    ~<span class=\"hljs-built_in\">BothStack</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i,DataType x)</span></span>;<span class=\"hljs-comment\">//入栈操作，将元素x压入栈i</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">Pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//出栈操作，对栈i执行出栈操作</span><br>    <span class=\"hljs-function\">DataType <span class=\"hljs-title\">GetTop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//取栈i的栈顶元素</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span></span>;<span class=\"hljs-comment\">//判断栈i是否为空栈</span><br><span class=\"hljs-keyword\">private</span>:<br>    DataType data[StackSize];<span class=\"hljs-comment\">//存放两个栈的数组</span><br>    <span class=\"hljs-type\">int</span> top1,top2;<span class=\"hljs-comment\">//两个栈的栈顶指针，分别为各自栈顶元素在数组中的下标</span><br>&#125;;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br><span class=\"hljs-type\">void</span> BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Push</span>(<span class=\"hljs-type\">int</span> i, DataType x) &#123;<br>    <span class=\"hljs-keyword\">if</span>(top1==top2<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;上溢&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>)data[++top1]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top1++;</span><br><span class=\"hljs-comment\">    data[top1] = x;</span><br><span class=\"hljs-comment\">    */</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>)data[--top2]=x;<br>    <span class=\"hljs-comment\">/*即:</span><br><span class=\"hljs-comment\">    top2--;</span><br><span class=\"hljs-comment\">    data[top2] = x;</span><br><span class=\"hljs-comment\">    */</span><br>&#125;<br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> DataType&gt;<br>DataType BothStack&lt;DataType&gt;::<span class=\"hljs-built_in\">Pop</span>(<span class=\"hljs-type\">int</span> i) &#123;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top1==<span class=\"hljs-number\">-1</span>)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top1--];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span>(top2==StackSize)<span class=\"hljs-keyword\">throw</span><span class=\"hljs-string\">&quot;下溢&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> data[top2++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>双端队列是队列的扩展，</p>\n<p>如果允许在队列的两端进行插人和删除操作，则称为双端队列；</p>\n<p>如果允许在两端插入但只允许在一端删除，则称为二进一出队列；</p>\n<p>如果只允许在一端插入但允许在两端删除，则称为一进二出队列。</p>\n<p>双端队列和普通队列一样，具有人队、出队、取队头元素等基本操作，不同的是必须指明操作的位置，其抽象数据类型定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ADT\">ADT DoubleQueue<br>DataModel<br>\t相邻元素具有前驱和后继关系，允许在队列的两端进行插入和删除操作<br>Operation<br>\tInitQueue<br>\t\t输入：无<br>\t\t功能：初始化双端队列<br>\t\t输出：一个空的双端队列<br>\tDestroyQueue<br>\t\t输人：无<br>\t\t功能：队列的销毁<br>\t\t输出：释放双端队列占用的存储空间<br>\tEnQueueHead<br>\t\t输入：元素值x<br>\t\t功能：入队操作，将元素x插人到双端队列的队头输出：如果插入成功，双端队列的队头增加了一个元素<br>\tEnQueueTail<br>\t\t输人：元素值x<br>\t\t功能：入队操作，将元素×插入到双端队列的队尾输出：如果插入成功，双端队列的队尾增加了一个元系<br>\tDeQueueHead<br>\t\t输入：无<br>\t\t功能：出队操作，删除双端队列的队头元素<br>\t\t输出：如果删除成功，将队头元素出队<br>\tDeQueueTail<br>\t\t输人：无<br>\t\t功能：出队操作，删除双端队列的队尾元素输出：如果删除成功，将队尾元素出队<br>\tGetHead<br>\t\t输人：无<br>\t\t功能：读取双端队列的队头元素<br>\t\t输出：若双端队列不空，返回队头元素<br>\tGetTail<br>\t\t输人：无<br>\t\t功能：读取双端队列的队尾元素<br>\t\t输出：若双端队列不空，返回队尾元素<br>\tEmpty<br>\t\t输人：无<br>\t\t功能：判空操作，判断双端队列是否为空输出：如果双端队列为空，返回1，否则返回0。<br>endADT<br></code></pre></td></tr></table></figure>\n\n<p>双端队列可以采用循环队列的存储方式，基本算法可以在循环队列的基础上修改而成。不同的是，在队头入队时，先将新元素插人到 front处，再把队头位置 front 在循环意义下减1；在队尾出队时，先将 rear 处的队尾元素暂存，再把队尾位置 rear 在循环意义下减1。</p>\n<h4 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdexcept&gt;</span></span><br><br><span class=\"hljs-comment\">// 定义链表节点</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>\t<span class=\"hljs-type\">int</span> data;<br>\tNode* prev;<br>\tNode* next;<br>\t<br>\t<span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-type\">int</span> val) : <span class=\"hljs-built_in\">data</span>(val), <span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 双端队列类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DoubleQueue</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>\tNode* head;<br>\tNode* tail;<br>\t<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">DoubleQueue</span>() : <span class=\"hljs-built_in\">head</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">tail</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">DoubleQueue</span>() &#123;<br>\t\t<span class=\"hljs-built_in\">DestroyQueue</span>();<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 初始化双端队列</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">InitQueue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\thead = <span class=\"hljs-literal\">nullptr</span>;<br>\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 销毁双端队列</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DestroyQueue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\tNode* temp = head;<br>\t\t\thead = head-&gt;next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t&#125;<br>\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 在队头插入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueueHead</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123;<br>\t\tNode* newNode = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead = tail = newNode;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewNode-&gt;next = head;<br>\t\t\thead-&gt;prev = newNode;<br>\t\t\thead = newNode;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 在队尾插入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">EnQueueTail</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123;<br>\t\tNode* newNode = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(x);<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead = tail = newNode;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tnewNode-&gt;prev = tail;<br>\t\t\ttail-&gt;next = newNode;<br>\t\t\ttail = newNode;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 从队头删除元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DeQueueHead</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\tNode* temp = head;<br>\t\thead = head-&gt;next;<br>\t\t<span class=\"hljs-keyword\">if</span> (head != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\thead-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\ttail = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 从队尾删除元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DeQueueTail</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\tNode* temp = tail;<br>\t\ttail = tail-&gt;prev;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t\ttail-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\thead = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> temp;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 获取队头元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetHead</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;Queue is empty&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> head-&gt;data;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 获取队尾元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetTail</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (tail == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;Queue is empty&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> tail-&gt;data;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 判断双端队列是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> head == <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tDoubleQueue dq;<br>\t<br>\t<span class=\"hljs-comment\">// 测试操作</span><br>\tdq.<span class=\"hljs-built_in\">EnQueueHead</span>(<span class=\"hljs-number\">1</span>);<br>\tdq.<span class=\"hljs-built_in\">EnQueueTail</span>(<span class=\"hljs-number\">2</span>);<br>\tdq.<span class=\"hljs-built_in\">EnQueueHead</span>(<span class=\"hljs-number\">3</span>);<br>\t<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Head: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, Tail: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetTail</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Head: 3, Tail: 2</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueHead</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;After DeQueueHead, Head: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Head: 1</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueTail</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;After DeQueueTail, Tail: &quot;</span> &lt;&lt; dq.<span class=\"hljs-built_in\">GetHead</span>() &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Tail: 1</span><br>\t<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Is the queue empty? &quot;</span> &lt;&lt; (dq.<span class=\"hljs-built_in\">Empty</span>() ? <span class=\"hljs-string\">&quot;Yes&quot;</span> : <span class=\"hljs-string\">&quot;No&quot;</span>) &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 No</span><br>\t<br>\tdq.<span class=\"hljs-built_in\">DeQueueHead</span>();<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Is the queue empty after all elements removed? &quot;</span> &lt;&lt; (dq.<span class=\"hljs-built_in\">Empty</span>() ? <span class=\"hljs-string\">&quot;Yes&quot;</span> : <span class=\"hljs-string\">&quot;No&quot;</span>) &lt;&lt; std::endl; <span class=\"hljs-comment\">// 应该输出 Yes</span><br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"应用举例\"><a href=\"#应用举例\" class=\"headerlink\" title=\"应用举例\"></a>应用举例</h2><h3 id=\"括号匹配问题\"><a href=\"#括号匹配问题\" class=\"headerlink\" title=\"括号匹配问题\"></a>括号匹配问题</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Matcher</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Matcher</span>(string str);<br>    ~<span class=\"hljs-built_in\">Matcher</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Match</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    string str;<br>&#125;;<br>Matcher::<span class=\"hljs-built_in\">Matcher</span>(string str) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;str=str;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Matcher::Match</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">char</span> S[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-type\">int</span> i,top=<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;str[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>;i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(str[i]==<span class=\"hljs-string\">&#x27;)&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span>(top&gt;<span class=\"hljs-number\">-1</span>)top--;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(str[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>            S[++top]=str[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(top==<span class=\"hljs-number\">-1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br>Matcher::~<span class=\"hljs-built_in\">Matcher</span>() &#123;<br><br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string str;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入一个算数表达式&quot;</span>;<br>    cin&gt;&gt;str;<br>    Matcher M&#123;str&#125;;<br>    <span class=\"hljs-type\">int</span> k=M.<span class=\"hljs-built_in\">Match</span>();<br>    <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;正确匹配\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>) &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;多左括号\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;多右括号\\n&quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h3><p>表达式求值需要根据运算符的优先级来确定计算顺序。因此，在求值过程中需要保存优先级较低的运算符以及没有参与计算的运算对象，并将当前运算符与已经扫描过的、尚未计算的运算符进行比较，以确定哪个运算符以及哪两个运算对象参与计算。这需要两个栈来辅助完成：运算对象栈 OPND 和运算符栈 OPTR。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Expression</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Expression</span>(string str);<br>    ~<span class=\"hljs-built_in\">Expression</span>();<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Compute</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Comp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> str1,<span class=\"hljs-type\">char</span> str2)</span></span>;<br>    string str;<br>&#125;;<br>Expression::<span class=\"hljs-built_in\">Expression</span>(string str) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;str=str+<span class=\"hljs-string\">&quot;#&quot;</span>;<br>&#125;<br>Expression::~<span class=\"hljs-built_in\">Expression</span>() &#123;<br><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Expression::Compute</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">char</span> OPND[<span class=\"hljs-number\">100</span>],OPTR[<span class=\"hljs-number\">100</span>];<br>    OPTR[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-string\">&#x27;#&#x27;</span>;<br>    <span class=\"hljs-type\">int</span> top1=<span class=\"hljs-number\">-1</span>,top2=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> i,k,x,y,z,op;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;str[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>;) &#123;<br>        <span class=\"hljs-keyword\">if</span>(str[i]&gt;=<span class=\"hljs-number\">48</span> &amp;&amp; str[i]&lt;=<span class=\"hljs-number\">57</span>) &#123;<br>            OPND[++top1]=str[i++]<span class=\"hljs-number\">-48</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            k=<span class=\"hljs-built_in\">Comp</span>(str[i],OPTR[top2]);<br>            <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>) &#123;<br>                OPTR[++top2]=str[i++];<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">-1</span>) &#123;<br>                y=OPND[top1--];<br>                x=OPND[top1--];<br>                op=OPTR[top2--];<br>                <span class=\"hljs-keyword\">switch</span> (op) &#123;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;+&#x27;</span>:z=x+y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>:z=x-y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;*&#x27;</span>:z=x*y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;/&#x27;</span>:z=x/y;<span class=\"hljs-keyword\">break</span>;<br>                    <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>                OPND[++top1]=z;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                top2--;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> OPND[top1];<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Expression::Comp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> str1, <span class=\"hljs-type\">char</span> str2)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">switch</span> (str1) &#123;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;+&#x27;</span>:<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;-&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;(&#x27;</span> || str2==<span class=\"hljs-string\">&#x27;#&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;*&#x27;</span>:<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;/&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;*&#x27;</span> || str2==<span class=\"hljs-string\">&#x27;/&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;(&#x27;</span>:<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;)&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;(&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;#&#x27;</span>:<br>            <span class=\"hljs-keyword\">if</span>(str2==<span class=\"hljs-string\">&#x27;#&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-keyword\">default</span>:<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string str;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;请输入一个表达式&quot;</span>&lt;&lt;endl;<br>    cin&gt;&gt;str;<br>    Expression E&#123;str&#125;;<br>    <span class=\"hljs-type\">int</span> result=E.<span class=\"hljs-built_in\">Compute</span>();<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;表达式的值是&quot;</span>&lt;&lt;result&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h2><h1 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h1><h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>给定两个字符串S，T，在主串S中寻找子串T的过程称为模式匹配，T称为模式。如果匹配成功，返回T在S中的位置；如果匹配失败，返回0。</p>\n<h3 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h3><p>BF算法的基本思想是蛮力匹配，即从主串S的第一个字符开始和模式T的第一个字符进行比较。若相等，则继续比较两者的后续字符；否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直至S或T中所有字符比较完毕。若T中的字符全部比较完毕，则匹配成功，返回本趟匹配的开始位置；否则匹配失败，返回0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">BF</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> S[],<span class=\"hljs-type\">char</span> T[])</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> start=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>,j=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span>((S[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>) &amp;&amp; (T[i]!=<span class=\"hljs-string\">&#x27;\\0&#x27;</span>))&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(S[i]==T[i])&#123;<br>\t\t\ti++;j++;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\tstart++;<br>\t\t\ti=start;j=<span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(T[j]==<span class=\"hljs-string\">&#x27;\\0&#x27;</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> start<span class=\"hljs-number\">+1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最坏情况下的时间复杂度是O(n*m)（设主串S长度为n，模式T长度为m）</p>\n<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p>【最浅显易懂的 KMP 算法讲解】 <a href=\"https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a><br>【【天勤考研】KMP算法易懂版】 <a href=\"https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a><br>【KMP算法之求next数组代码讲解】 <a href=\"https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&vd_source=440c7ec5d64e62c0d02675282b15de02\">https://www.bilibili.com/video/BV16X4y137qw/?share_source=copy_web&amp;vd_source=440c7ec5d64e62c0d02675282b15de02</a></p>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><h2 id=\"矩阵压缩存储\"><a href=\"#矩阵压缩存储\" class=\"headerlink\" title=\"矩阵压缩存储\"></a>矩阵压缩存储</h2>"},{"title":"软件开发方向选修课程指导","date":"2024-08-18T04:26:08.000Z","_content":"\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;color:black;mso-themecolor:text1;background:yellow;mso-highlight:\nyellow'>大一：</span></b><b><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-size:\n20.0pt;color:black;mso-themecolor:text1;background:yellow;mso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span><span lang=EN-US><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;background:aqua;mso-highlight:aqua'>C</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:aqua;mso-highlight:aqua'>语言程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（底层编程，性能优化）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-family:Wingdings;mso-fareast-font-family:Wingdings;\nmso-bidi-font-family:Wingdings'><span style='mso-list:Ignore'>&Oslash;<span\nstyle='font:7.0pt \"Times New Roman\"'>&nbsp; </span></span></span><![endif]><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:aqua;mso-highlight:aqua'>C++</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:aqua;\nmso-highlight:aqua'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（面向对象编程，封装、继承、多态基础）</span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大二：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（目前在大二下开设，建议大二上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>数据库原理与技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（关系型数据库基础，数据持久化，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SQL</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语句）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>HTML</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（静态页面，前端基础，涉及</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>CSS+DIV</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>页面布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JS</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>事件等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Java</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Java</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语言基础，控制台应用程序，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>数据库驱动链接，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>ORM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>映射）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二下）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>JavaWeb</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:lime;mso-highlight:lime'>程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Jsp+Servlet+JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，页面程序基础，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>MVC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>分层等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大三：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件工程导论</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（工程概念，软件全生命周期管理，各阶段建模工具，数据流图、实体联系图、类图、用例图等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三下）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件体系结构设计与原理</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（强调软件复用，不同粒度的构件，软件体系结构风格，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>UML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>建模，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>XML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>WebService</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，软件产品线等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:lime;mso-highlight:lime'>框架编程技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（企业级项目开发，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SSM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>框架，或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Spring\nBoot+Mybatis</span><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>框架的搭建，配置文件的编写，依赖隔离，切面编程等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='line-height:150%'><b><span style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:yellow;\nmso-highlight:yellow'>补充：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;background:yellow;mso-highlight:\nyellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>因当前很多软件系统涉及多领域开发，如人工智能，数据挖掘，数据可视化等，建议（大二）选修<b><span\nstyle='background:lime;mso-highlight:lime'>《</span></b></span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Python</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计》《数据挖掘》</span></b><span style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等课程；</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>前端相关课程较少，建议大家自学</span><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Bootstrap</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>响应式布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Vue.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Node.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等相关框架。</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n","source":"_posts/QFNU_GuidanceForElectiveCoursesInSoftwareDevelopmentDirection.md","raw":"---\ntitle: 软件开发方向选修课程指导\ndate: 2024-08-18 12:26:08\n---\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;color:black;mso-themecolor:text1;background:yellow;mso-highlight:\nyellow'>大一：</span></b><b><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-size:\n20.0pt;color:black;mso-themecolor:text1;background:yellow;mso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span><span lang=EN-US><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;background:aqua;mso-highlight:aqua'>C</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:aqua;mso-highlight:aqua'>语言程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（底层编程，性能优化）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-family:Wingdings;mso-fareast-font-family:Wingdings;\nmso-bidi-font-family:Wingdings'><span style='mso-list:Ignore'>&Oslash;<span\nstyle='font:7.0pt \"Times New Roman\"'>&nbsp; </span></span></span><![endif]><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:aqua;mso-highlight:aqua'>C++</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:aqua;\nmso-highlight:aqua'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（面向对象编程，封装、继承、多态基础）</span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大二：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（目前在大二下开设，建议大二上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>数据库原理与技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（关系型数据库基础，数据持久化，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SQL</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语句）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>HTML</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（静态页面，前端基础，涉及</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>CSS+DIV</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>页面布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JS</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>事件等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Java</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Java</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语言基础，控制台应用程序，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>数据库驱动链接，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>ORM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>映射）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二下）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>JavaWeb</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:lime;mso-highlight:lime'>程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Jsp+Servlet+JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，页面程序基础，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>MVC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>分层等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大三：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件工程导论</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（工程概念，软件全生命周期管理，各阶段建模工具，数据流图、实体联系图、类图、用例图等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三下）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件体系结构设计与原理</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（强调软件复用，不同粒度的构件，软件体系结构风格，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>UML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>建模，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>XML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>WebService</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，软件产品线等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:lime;mso-highlight:lime'>框架编程技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（企业级项目开发，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SSM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>框架，或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Spring\nBoot+Mybatis</span><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>框架的搭建，配置文件的编写，依赖隔离，切面编程等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='line-height:150%'><b><span style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:yellow;\nmso-highlight:yellow'>补充：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;background:yellow;mso-highlight:\nyellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>因当前很多软件系统涉及多领域开发，如人工智能，数据挖掘，数据可视化等，建议（大二）选修<b><span\nstyle='background:lime;mso-highlight:lime'>《</span></b></span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Python</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计》《数据挖掘》</span></b><span style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等课程；</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>前端相关课程较少，建议大家自学</span><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Bootstrap</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>响应式布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Vue.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Node.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等相关框架。</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n","slug":"QFNU_GuidanceForElectiveCoursesInSoftwareDevelopmentDirection","published":1,"updated":"2024-10-30T13:02:19.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3eq0005c0wcasysfjl9","content":"<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;color:black;mso-themecolor:text1;background:yellow;mso-highlight:\nyellow'>大一：</span></b><b><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-size:\n20.0pt;color:black;mso-themecolor:text1;background:yellow;mso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span><span lang=EN-US><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;background:aqua;mso-highlight:aqua'>C</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:aqua;mso-highlight:aqua'>语言程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（底层编程，性能优化）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-family:Wingdings;mso-fareast-font-family:Wingdings;\nmso-bidi-font-family:Wingdings'><span style='mso-list:Ignore'>&Oslash;<span\nstyle='font:7.0pt \"Times New Roman\"'>&nbsp; </span></span></span><![endif]><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:aqua;mso-highlight:aqua'>C++</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:aqua;\nmso-highlight:aqua'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（面向对象编程，封装、继承、多态基础）</span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大二：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（目前在大二下开设，建议大二上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>数据库原理与技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（关系型数据库基础，数据持久化，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SQL</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语句）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>HTML</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（静态页面，前端基础，涉及</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>CSS+DIV</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>页面布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JS</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>事件等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Java</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Java</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语言基础，控制台应用程序，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>数据库驱动链接，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>ORM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>映射）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二下）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>JavaWeb</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:lime;mso-highlight:lime'>程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Jsp+Servlet+JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，页面程序基础，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>MVC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>分层等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大三：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件工程导论</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（工程概念，软件全生命周期管理，各阶段建模工具，数据流图、实体联系图、类图、用例图等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三下）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件体系结构设计与原理</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（强调软件复用，不同粒度的构件，软件体系结构风格，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>UML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>建模，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>XML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>WebService</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，软件产品线等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:lime;mso-highlight:lime'>框架编程技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（企业级项目开发，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SSM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>框架，或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Spring\nBoot+Mybatis</span><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>框架的搭建，配置文件的编写，依赖隔离，切面编程等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='line-height:150%'><b><span style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:yellow;\nmso-highlight:yellow'>补充：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;background:yellow;mso-highlight:\nyellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>因当前很多软件系统涉及多领域开发，如人工智能，数据挖掘，数据可视化等，建议（大二）选修<b><span\nstyle='background:lime;mso-highlight:lime'>《</span></b></span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Python</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计》《数据挖掘》</span></b><span style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等课程；</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>前端相关课程较少，建议大家自学</span><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Bootstrap</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>响应式布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Vue.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Node.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等相关框架。</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n","site":{"data":{}},"excerpt":"","more":"<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;color:black;mso-themecolor:text1;background:yellow;mso-highlight:\nyellow'>大一：</span></b><b><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-size:\n20.0pt;color:black;mso-themecolor:text1;background:yellow;mso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span><span lang=EN-US><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;background:aqua;mso-highlight:aqua'>C</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:aqua;mso-highlight:aqua'>语言程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（底层编程，性能优化）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-family:Wingdings;mso-fareast-font-family:Wingdings;\nmso-bidi-font-family:Wingdings'><span style='mso-list:Ignore'>&Oslash;<span\nstyle='font:7.0pt \"Times New Roman\"'>&nbsp; </span></span></span><![endif]><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:aqua;mso-highlight:aqua'>C++</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:aqua;\nmso-highlight:aqua'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（面向对象编程，封装、继承、多态基础）</span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大二：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（目前在大二下开设，建议大二上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>数据库原理与技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（关系型数据库基础，数据持久化，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SQL</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语句）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>HTML</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（静态页面，前端基础，涉及</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>CSS+DIV</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>页面布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JS</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>事件等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二上）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Java</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计</span></b><span lang=EN-US style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%'>--</span><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Java</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>语言基础，控制台应用程序，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>数据库驱动链接，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>ORM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>映射）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大二下）</span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>JavaWeb</span></b><b><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;\nbackground:lime;mso-highlight:lime'>程序设计</span></b><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Jsp+Servlet+JDBC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，页面程序基础，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>MVC</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>分层等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:16.0pt;mso-bidi-font-size:20.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin;background:yellow;mso-highlight:yellow'>大三：</span></b><b><span\nlang=EN-US style='font-size:16.0pt;mso-bidi-font-size:20.0pt;background:yellow;\nmso-highlight:yellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业核心课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件工程导论</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（工程概念，软件全生命周期管理，各阶段建模工具，数据流图、实体联系图、类图、用例图等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三下）<b><span\nstyle='background:aqua;mso-highlight:aqua'>软件体系结构设计与原理</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（强调软件复用，不同粒度的构件，软件体系结构风格，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>UML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>建模，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>XML</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>WebService</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>，软件产品线等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal><b><span style='font-size:14.0pt;mso-bidi-font-size:18.0pt;\nfont-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;\nmso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:\nminor-latin'>专业选修课：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='margin-left:41.95pt;text-indent:-21.0pt;line-height:\n150%;mso-list:l0 level1 lfo1;tab-stops:21.0pt'><![if !supportLists]><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nfont-family:Wingdings;mso-fareast-font-family:Wingdings;mso-bidi-font-family:\nWingdings'><span style='mso-list:Ignore'>&Oslash;<span style='font:7.0pt \"Times New Roman\"'>&nbsp;\n</span></span></span><![endif]><span style='font-size:12.0pt;mso-bidi-font-size:\n16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;\nmso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（大三上）<b><span\nstyle='background:lime;mso-highlight:lime'>框架编程技术</span></b></span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>--</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>（企业级项目开发，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>SSM</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>框架，或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Spring\nBoot+Mybatis</span><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>框架的搭建，配置文件的编写，依赖隔离，切面编程等）</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='line-height:150%'><b><span style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:yellow;\nmso-highlight:yellow'>补充：</span></b><b><span lang=EN-US style='font-size:14.0pt;\nmso-bidi-font-size:18.0pt;line-height:150%;background:yellow;mso-highlight:\nyellow'><o:p></o:p></span></b></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>因当前很多软件系统涉及多领域开发，如人工智能，数据挖掘，数据可视化等，建议（大二）选修<b><span\nstyle='background:lime;mso-highlight:lime'>《</span></b></span><b><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;\nbackground:lime;mso-highlight:lime'>Python</span></b><b><span style='font-size:\n12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;background:lime;\nmso-highlight:lime'>程序设计》《数据挖掘》</span></b><span style='font-size:12.0pt;\nmso-bidi-font-size:16.0pt;line-height:150%;font-family:宋体;mso-ascii-font-family:\nCalibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:minor-fareast;\nmso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等课程；</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n\n<p class=MsoNormal style='text-indent:36.0pt;mso-char-indent-count:3.0;\nline-height:150%'><span style='font-size:12.0pt;mso-bidi-font-size:16.0pt;\nline-height:150%;font-family:宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:\nminor-latin;mso-fareast-theme-font:minor-fareast;mso-hansi-font-family:Calibri;\nmso-hansi-theme-font:minor-latin'>前端相关课程较少，建议大家自学</span><span lang=EN-US\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Bootstrap</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>响应式布局，</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Vue.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>或</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'>Node.js</span><span\nstyle='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%;font-family:\n宋体;mso-ascii-font-family:Calibri;mso-ascii-theme-font:minor-latin;mso-fareast-theme-font:\nminor-fareast;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin'>等相关框架。</span><span\nlang=EN-US style='font-size:12.0pt;mso-bidi-font-size:16.0pt;line-height:150%'><o:p></o:p></span></p>\n"},{"title":"编写C语言程序时必须有#include<stdio.h>这一行吗？为什么有时候不需要？","date":"2024-11-26T15:19:01.000Z","_content":"\n> 编写C语言程序时必须有#include<stdio.h>这一行吗？为什么有时候不需要？\n>\n> 作者：夏洛克\n> 链接：https://www.zhihu.com/question/21287371/answer/2819849667\n> 来源：知乎\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n我的回答不限于当前这个问题。由于市面上C语言教程的编排太垃圾而引发的初学者的一系列困惑都可以在这里解决。\n\n我认为给编程入门者的C语言教材，**第一课就应该讲清楚 #include**，由此自然的引出[模块化设计](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=模块化设计&zhida_source=entity)等通用编程思想，展现出从一行代码到一个完整项目的整体印象, 而不是去写无用程序 Hello World。\n\n\n\n## 前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\n\n\n\n市面上C语言教程的编排都很垃圾，完全没有逻辑，无脑陈列细节。包括C语言之父 [Dennis Ritchie](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=Dennis+Ritchie&zhida_source=entity) 的那本《C程序设计语言》。或者说这本就是罪魁祸首?\n\n《[C程序设计语言](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=2&q=C程序设计语言&zhida_source=entity)》就是一本C语言特性介绍手册，明显是给\"**初学C语言的编程人员\"**设计的，而不是为**编程初学者**设计的。这书的存在本身没问题, 问题在于是它之后所有的编程教材(不限于C语言)都只会按着这样的编排顺序去堆砌细节，没有一个合理的主线逻辑. 像[《C Primer Plus》](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=《C+Primer+Plus》&zhida_source=entity)这些流行教材更是加剧了这种趋势，实际上只是一些更厚更啰嗦的字典罢了。国内的那些垃圾就更不必提了！\n\n于是, C语言作为一门流行的编程入门语言, 竟然使得**“学编程要先学C，学C要先懂编程”** 这个 bug 流传至今。以下是我为解决这个 bug 做的尝试。我相信看了这篇回答可以消解初学者们大部分疑惑，包括本题主的疑惑。\n\n（当然还有第二种方案，那就是先去学 Python 。Python 是真正的 0 基础编程语言，没有上述 Bug. 但是用 Python 入门之后, 还是建议回来学学 C, 学编程是绕不开C语言的。）\n\n\n\n## 第一课：#include 与 模块化编程\n\n\n\n一个程序就像一台机器，是多个功能模块组合而成的。各模块组合起来后靠一个主体程序( 通常叫做 main )去集中调度。\n\n例如一台简略的C语言玩具车写法如下：\n\n### 1.0版\n\n玩具车.c\n\n```c\nvoid 前进(int 距离){/*具体实现*/}\nvoid 后退(int 距离){/*具体实现*/}\nvoid 左转(int 角度){/*具体实现*/}\nvoid 右转(int 角度){/*具体实现*/}\n\nint main(){\n\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    return 0;\n}\n```\n\n\n\n可以观察到，程序由四个辅助功能块：前进，后退，左转，右转，和一个主体功能 main 构成。\n\n主体通过某种流程去调用了4个功能中的2个，实现了让小车走一个 10×10 正方形回到原地的功能。\n\n可以看到，我并没有 #include <stdio.h>，但是程序是完全正确的，不作任何修改就可以编译运行（目前没有任何运行结果，因为所有功能函数都是空的）。\n\n\n\n### 2.0版\n\n引入 #include 后，可以进一步优化我们的代码结构。\n\n我们可以把 main 上方的那一大块同类的内容打包起来写在另一个文件里（比如 \"遥控器.h\"），然后把它与原来的 \"玩具车.c\" 文件放在同一目录下，如下所示：\n\n遥控器.h\n\n```c\nvoid 前进(int 距离){/*具体实现*/}\nvoid 后退(int 距离){/*具体实现*/}\nvoid 左转(int 角度){/*具体实现*/}\nvoid 右转(int 角度){/*具体实现*/}\n```\n\n玩具车.c\n\n```c\n#include \"遥控器.h\"\n\nint main()\n{\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    return 0;\n}\n```\n\n玩具车.c 里面有了 #include \"遥控器.h\" 这句话，编译工具就会在编译过程中自动把 \"遥控器.h\" 里的内容复制到 \"玩具车.c\" 中 #include 语句所在的位置。这样一来，从机器的角度，2.0版程序和1.0版完全等价，不会出错；\n\n从人的角度，我们把一组相关的功能作为一个模块打包分离出去了。而 #include 就像是一个组装命令，帮我们把模块组装回来。于是我们可以用模块思想去设计小车的各个组成部分，在不同的文件里写不同的模块，一次只需专注一个部分，写完再组装起来。从此写程序就是造积木和搭积木的游戏！\n\n从生产的角度，我们可以把大问题拆解成一些子模块，可以交给不同的人分别去解决，最后用 #include 组合起来，实现分工与合作。\n\n\n\n好了，到这里你应该已经明白是否需要 #include 了, 其实就看你是否需要某个功能模块。\n\nstdio.h 是一个负责向电脑屏幕输入/输出信息的模块，十分常用，所以初学者几乎没有不需要的。\n\n有些模块就是这样, 很常用, 写起来又很麻烦，所以C语言维护者们已经写好一套常用工具，包含 stdio.h 、[stdlib.h](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=stdlib.h&zhida_source=entity)、math.h 等等十多个模块，各有各的用途，称为**“C语言[标准库](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=标准库&zhida_source=entity)”**；它们已经深度内置到编译工具包里了。\n\n\\#include \"遥控器.h\" 这个语句里，双引号里其实不是模块名, 而是模块的文件路径, 因为支持相对路径, 所以同目录下的模块只需写文件名即可。 其它地方的模块可以用绝对路径引入, 类似这样: \n\n```c\n #include \"C:/Users/WHO/Downloads/模块.h\"\n```\n\n标准库的路径编译器是认识的, 只要用尖括号 <> 表明一个模块属于标准库, 编译器就能找到它.\n\n```c\n #include <stdio.h>\n```\n\n### 3.0版\n\n[printf()](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=printf()&zhida_source=entity) 就是来自 stdio.h 的一个功能，可以用它在命令行窗口打出文字。\n\n让我们把它加进小车里，让小车学会向你实时报告运行状态吧。\n\n遥控器.h\n\n```c\n#include <stdio.h>\n\nvoid 前进(int 距离){ printf(\"前进 %d 米\\n\",距离); }\nvoid 后退(int 距离){ printf(\"后退 %d 米\\n\",距离); }\nvoid 左转(int 角度){ printf(\"左转 %d 度\\n\",角度); }\nvoid 右转(int 角度){ printf(\"前进 %d 度\\n\",角度); }\n```\n\n玩具车.c\n\n```c\n#include \"遥控器.h\"\n\nint main()\n{\n    printf(\"出发\\n\");\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    printf(\"结束\\n\");\n    return 0;\n}\n```\n\n可以看到遥控器需要使用 printf()，所以我们把 #include<stdio.h> 包含到遥控器头部。\n\n而玩具车又 #include 了遥控器，于是层层包含最终汇集到 玩具车.c 中，所以现在也可以在玩具车里使用 printf()。\n\n(能间接包含是C/C++语言的特点, 其它语言情况可能不一样, 比如 Python 的 import )\n\n去编译试试看效果吧！\n\n![img](https://picx.zhimg.com/80/v2-707190bb4d8800fec14f54bd1af9b743_720w.webp?source=2c26e567)\n\n（编译教程会在第〇课更新）\n\n\n\n## 第〇课：配置编译环境，命令行基础，带参数的 Hello World\n\n\n\n### 1. 命令行基础\n\n告诉你2个秘密: \n\n**秘密1.命令行才是多数软件真实的模样**. 日常所见的各种图形界面软件只不过是隐藏了命令行窗口罢了.\n\n**如果你想入门编程的话, 就要抛弃以电脑桌面为中心的视角, 从现在开始, 把命令行界面看作你的家, 其它的一切都是从这里打开的.**\n\n> 在 Windows 中, 按 WIN+S 搜索 \"CMD\" 或者 \"Powershell\" 或者 \"终端\", 都可打开命令行环境.\n\n**秘密2.软件本身是没有\"安装\"这个概念的**. 软件放在哪个目录无所谓, 是纯靠文件路径来定位和运行的. \n\n比如你想打开文件管理器, 标准做法是在命令行中输入完整路径 C:\\Windows\\explorer.exe 然后回车即可. 任何文件都是这个逻辑, 你可以试试这样打开一个已有的 txt 文件.\n\n但是对于一些需要经常打开的文件，每次都要输入完整路径的话就很麻烦, 有没有更便捷的做法呢? 有的, 那就是\"PATH环境变量\".\n\n什么是\"PATH环境变量\"?\n\n> PATH 是一个常用目录汇总表, 用来存放一些软件所在目录; 当一个软件的目录添加进此列表后, 便可省略完整路径, 只需敲出文件名即可运行; 对于一个命令行软件, 添加进了 PATH 就等于**\"安装\"**了这个软件.\n\n打开环境变量编辑器即可发现, C:\\Windows 已经在列表中了:\n\n![img](https://pic1.zhimg.com/80/v2-d7613e65c214e113f66f935d3801b0ed_720w.webp?source=2c26e567)\n\n这就是为什么直接输 explorer.exe 也能打开文件管理器。\n\n又因为 exe 是二进制文件, 属于系统的最基本的文件, 所以可以省略后缀名, 直接输 explorer 也能打开文件管理器.\n\n这时已经没人能看出来它原本是一个文件了, 它成为了一个**命令**.\n\n这就是各种命令的真面目, 几乎每个命令都能在某个路径下找到对应的二进制文件.\n\n- 命令行软件的典型用法：软件名+参数+参数...，以 [aria2](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=aria2&zhida_source=entity)，ffmpeg 为例......\n- C语言的编译器 GCC 也是一个命令行软件.\n\n### 2. 配置C/C++编译环境\n\n在Windows上安装GCC编译器\n\n1. 访问 [Releases · niXman/mingw-builds-binaries (github.com)](https://link.zhihu.com/?target=https%3A//github.com/niXman/mingw-builds-binaries/releases)\n2. 下载 x86_64-13.1.0-release-win32-seh-ucrt.7z\n3. 解压得 mingw64，放到合适的地方（推荐C盘根目录）\n4. 把 C:/mingw64/bin 添加到 PATH 环境变量:\n\n[win10如何添加环境变量path-百度经验](https://jingyan.baidu.com/article/49711c61197cadba451b7c6f.html)\n\n5. 执行 gcc -v 看看反应, 没有报错说明安装成功.\n\n\n\n### 3. 编译运行你的第一个程序\n\n- 打开命令行, 运行 notepad hello.c (这样就新建了文本文件 hello.c)\n- 粘贴如下内容并保存:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"你好,我是程序 %s\\n\", argv[0]);\n    if (argc > 1)\n    {\n        printf(\"太好了,有人来了!\\n\");\n    }\n    else\n    {\n        printf(\"怎么一个人都没有?\\n\");\n    }\n\n    for (int i = 1; i < argc; i++)\n    {\n        printf(\"欢迎你,%s!\\n\", argv[i]);\n    }\n    return 0;\n}\n```\n\n- 回到命令行窗口, 执行：\n\n```bash\ngcc *.c -o hello\n```\n\n> 命令解释: \n> 调用 [gcc 编译器](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=gcc+编译器&zhida_source=entity), 并传入了这三个参数: \"*.c\",  \"-o\", \"hello\".\n> *.c 表示选择当前目录下所有 .c 文件 ( 当然, 本例中你可以写 hello.c )\n> -o 表示输出\n> hello 表示会输出文件名为 hello ( 在 Windows 环境下生成的是 hello.exe )\n\n成功后，hello.c的同一目录下会生成 hello.exe 文件\n\n运行：\n\n- 无参数运行：\n\n```text\n./hello\n```\n\n- 有参数运行：\n\n```text\n./hello Tom Jerry\n```\n\n如果出现乱码, 可能是因为文本默认使用了 UTF-8 编码，可以试试把文本另存为 [GBK 编码](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=GBK+编码&zhida_source=entity)重新编译. \n\n![img](https://picx.zhimg.com/80/v2-252a8cb70c53a6501079f22aaf539749_720w.webp?source=2c26e567)\n\n或者不改文本编码，直接用下面这个更彻底的方法.\n\n### *4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象\n\n[win10 配置系统默认utf-8编码 - 聆风牧雨 - 博客园](https://www.cnblogs.com/walker-world/p/9548852.html)\n\n这样设置完以后，你的代码文件夹路径，文件名，变量名，函数名都可以包含中文字符，管理代码时不用再小心翼翼的了。\n\n这样做也有缺点，就是一些使用 GBK 编码的老软件/老游戏/老文件可能会出现乱码. 虽然这些老软件大部分已经淘汰了, 但是还是看个人情况自行选择吧。\n\n\n\n## 第二课：函数和变量，通用程序模型 \n\n### 函数是什么？\n\n函数是最小的程序单位，是程序的细胞。\n\n所以函数的基本运行逻辑和程序完全一致：输入数据->处理数据->输出结果。\n\n\n\n上文中我们直观体会了函数的功能，仔细观察可以发现所有函数的都使用同一个格式：\n\n```c\n某种标记 函数名 (输入数据) { 语句 }\n```\n\n其实整个程序就是一个大函数： int main( ) {   }\n\n其中开头的标记是在指明函数最终的计算结果是什么, int 表示最终得到一个整数, void 表示不给出任何结果 (这是可以的, 很多函数只需要默默做事情就行, 而不必报告结果).\n\n观察 main 函数可看出，语句之间用英文分号隔开, 语句之间可以换行, 函数中可以调用其它函数...等等.\n\n变量是什么？\n\n变量，是数据的搬运工。\n\n\n\n第三课：结构体，类\n\n### 结构体是什么？\n\n...\n\n### 类是什么？\n\n函数实现了操作的模块化；\n\n结构体实现了数据的模块化，\n\n类 = 结构体 + 函数；(C++内容)\n\n所以类实现了统一的模块化。\n\n所以 \"面向对象\" 不是什么高深的东西，它就是 \"模块化思想\" 的直接结果。\n\n\n\n### 实现模块的无序组合的方法：声明与定义分离\n\n\n\nC语言中，当你需要创建一个新的函数供其它函数使用时，需要注意它摆放的顺序。\n\n因为C代码是从上到下顺序解析的。所以一个函数不能调用在它下面出现的函数。\n\n```c\nvoid A()\n{ \n    B();\n}\n\nvoid B()\n{ \n    A();\n}\n```\n\n例如上述代码中 函数 A 试图使用函数 B，但在C语言中这是无法做到的，因为这一行之前没有出现过B的定义，所以A并不知道B的存在. 而 B 调用 A 则是可以的.\n\n函数的依赖往往是树状的，花费一些力气可以整理出合理的顺序. 但是网状的依赖则很难通过调整顺序做到，而且面对成百上千个函数, 没人想在这些烦人的细节上浪费精力。\n\n为了实现模块的无序组合，C语言搞出了一套方法，叫做**声明与定义分离**。使得模块只须声明了名字就可以呼叫了，模块内部的具体内容可以后面补上。\n\n比如上面例子，可以改成：\n\n```c\n//此代码仅用于举例, 请勿实机运行, 会造成死循环\n\n//声明\nvoid A();\nvoid B();\n\n//定义\nvoid A(){ B() }\nvoid B(){ A() }\n```\n\n这样一来, 无论有多少函数 ,只要它存在于声明区, 就可以随便互相调用, 不用考虑顺序. \n\n知道这个动机以后，不用学就可以知道，结构体和类也一定存在类似的设计。\n\n学C++面向对象时的时候，所谓[虚函数](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=虚函数&zhida_source=entity)也是声明与定义分离的一种应用。\n\n\n\n\n\n\n\n\n\n\n\n**本文的一个核心观点就是：先有需求，再有方法。需求出现之前，任何知识都是无用知识，任何工具都是废物。只传授知识, 不讲述动机的老师全都是不合格的老师.**\n\n你之所以需要一个程序，其实是需要它替代你做一些繁重而无脑的事情。典型的例子就是把一件事重复N遍, 所以你需要循环。\n\n\n\n\n\n\n\n## （未完待续）\n","source":"_posts/编写C语言程序时必须有-include-stdio-h-这一行吗？为什么有时候不需要？.md","raw":"---\ntitle: 编写C语言程序时必须有#include<stdio.h>这一行吗？为什么有时候不需要？\ndate: 2024-11-26 23:19:01\ntags:\n---\n\n> 编写C语言程序时必须有#include<stdio.h>这一行吗？为什么有时候不需要？\n>\n> 作者：夏洛克\n> 链接：https://www.zhihu.com/question/21287371/answer/2819849667\n> 来源：知乎\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n我的回答不限于当前这个问题。由于市面上C语言教程的编排太垃圾而引发的初学者的一系列困惑都可以在这里解决。\n\n我认为给编程入门者的C语言教材，**第一课就应该讲清楚 #include**，由此自然的引出[模块化设计](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=模块化设计&zhida_source=entity)等通用编程思想，展现出从一行代码到一个完整项目的整体印象, 而不是去写无用程序 Hello World。\n\n\n\n## 前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\n\n\n\n市面上C语言教程的编排都很垃圾，完全没有逻辑，无脑陈列细节。包括C语言之父 [Dennis Ritchie](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=Dennis+Ritchie&zhida_source=entity) 的那本《C程序设计语言》。或者说这本就是罪魁祸首?\n\n《[C程序设计语言](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=2&q=C程序设计语言&zhida_source=entity)》就是一本C语言特性介绍手册，明显是给\"**初学C语言的编程人员\"**设计的，而不是为**编程初学者**设计的。这书的存在本身没问题, 问题在于是它之后所有的编程教材(不限于C语言)都只会按着这样的编排顺序去堆砌细节，没有一个合理的主线逻辑. 像[《C Primer Plus》](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=《C+Primer+Plus》&zhida_source=entity)这些流行教材更是加剧了这种趋势，实际上只是一些更厚更啰嗦的字典罢了。国内的那些垃圾就更不必提了！\n\n于是, C语言作为一门流行的编程入门语言, 竟然使得**“学编程要先学C，学C要先懂编程”** 这个 bug 流传至今。以下是我为解决这个 bug 做的尝试。我相信看了这篇回答可以消解初学者们大部分疑惑，包括本题主的疑惑。\n\n（当然还有第二种方案，那就是先去学 Python 。Python 是真正的 0 基础编程语言，没有上述 Bug. 但是用 Python 入门之后, 还是建议回来学学 C, 学编程是绕不开C语言的。）\n\n\n\n## 第一课：#include 与 模块化编程\n\n\n\n一个程序就像一台机器，是多个功能模块组合而成的。各模块组合起来后靠一个主体程序( 通常叫做 main )去集中调度。\n\n例如一台简略的C语言玩具车写法如下：\n\n### 1.0版\n\n玩具车.c\n\n```c\nvoid 前进(int 距离){/*具体实现*/}\nvoid 后退(int 距离){/*具体实现*/}\nvoid 左转(int 角度){/*具体实现*/}\nvoid 右转(int 角度){/*具体实现*/}\n\nint main(){\n\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    return 0;\n}\n```\n\n\n\n可以观察到，程序由四个辅助功能块：前进，后退，左转，右转，和一个主体功能 main 构成。\n\n主体通过某种流程去调用了4个功能中的2个，实现了让小车走一个 10×10 正方形回到原地的功能。\n\n可以看到，我并没有 #include <stdio.h>，但是程序是完全正确的，不作任何修改就可以编译运行（目前没有任何运行结果，因为所有功能函数都是空的）。\n\n\n\n### 2.0版\n\n引入 #include 后，可以进一步优化我们的代码结构。\n\n我们可以把 main 上方的那一大块同类的内容打包起来写在另一个文件里（比如 \"遥控器.h\"），然后把它与原来的 \"玩具车.c\" 文件放在同一目录下，如下所示：\n\n遥控器.h\n\n```c\nvoid 前进(int 距离){/*具体实现*/}\nvoid 后退(int 距离){/*具体实现*/}\nvoid 左转(int 角度){/*具体实现*/}\nvoid 右转(int 角度){/*具体实现*/}\n```\n\n玩具车.c\n\n```c\n#include \"遥控器.h\"\n\nint main()\n{\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    return 0;\n}\n```\n\n玩具车.c 里面有了 #include \"遥控器.h\" 这句话，编译工具就会在编译过程中自动把 \"遥控器.h\" 里的内容复制到 \"玩具车.c\" 中 #include 语句所在的位置。这样一来，从机器的角度，2.0版程序和1.0版完全等价，不会出错；\n\n从人的角度，我们把一组相关的功能作为一个模块打包分离出去了。而 #include 就像是一个组装命令，帮我们把模块组装回来。于是我们可以用模块思想去设计小车的各个组成部分，在不同的文件里写不同的模块，一次只需专注一个部分，写完再组装起来。从此写程序就是造积木和搭积木的游戏！\n\n从生产的角度，我们可以把大问题拆解成一些子模块，可以交给不同的人分别去解决，最后用 #include 组合起来，实现分工与合作。\n\n\n\n好了，到这里你应该已经明白是否需要 #include 了, 其实就看你是否需要某个功能模块。\n\nstdio.h 是一个负责向电脑屏幕输入/输出信息的模块，十分常用，所以初学者几乎没有不需要的。\n\n有些模块就是这样, 很常用, 写起来又很麻烦，所以C语言维护者们已经写好一套常用工具，包含 stdio.h 、[stdlib.h](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=stdlib.h&zhida_source=entity)、math.h 等等十多个模块，各有各的用途，称为**“C语言[标准库](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=标准库&zhida_source=entity)”**；它们已经深度内置到编译工具包里了。\n\n\\#include \"遥控器.h\" 这个语句里，双引号里其实不是模块名, 而是模块的文件路径, 因为支持相对路径, 所以同目录下的模块只需写文件名即可。 其它地方的模块可以用绝对路径引入, 类似这样: \n\n```c\n #include \"C:/Users/WHO/Downloads/模块.h\"\n```\n\n标准库的路径编译器是认识的, 只要用尖括号 <> 表明一个模块属于标准库, 编译器就能找到它.\n\n```c\n #include <stdio.h>\n```\n\n### 3.0版\n\n[printf()](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=printf()&zhida_source=entity) 就是来自 stdio.h 的一个功能，可以用它在命令行窗口打出文字。\n\n让我们把它加进小车里，让小车学会向你实时报告运行状态吧。\n\n遥控器.h\n\n```c\n#include <stdio.h>\n\nvoid 前进(int 距离){ printf(\"前进 %d 米\\n\",距离); }\nvoid 后退(int 距离){ printf(\"后退 %d 米\\n\",距离); }\nvoid 左转(int 角度){ printf(\"左转 %d 度\\n\",角度); }\nvoid 右转(int 角度){ printf(\"前进 %d 度\\n\",角度); }\n```\n\n玩具车.c\n\n```c\n#include \"遥控器.h\"\n\nint main()\n{\n    printf(\"出发\\n\");\n    for (int i=0; i<4; i++)  //循环(4)次\n    {\n        前进(10);\n        右转(90);\n    }\n    printf(\"结束\\n\");\n    return 0;\n}\n```\n\n可以看到遥控器需要使用 printf()，所以我们把 #include<stdio.h> 包含到遥控器头部。\n\n而玩具车又 #include 了遥控器，于是层层包含最终汇集到 玩具车.c 中，所以现在也可以在玩具车里使用 printf()。\n\n(能间接包含是C/C++语言的特点, 其它语言情况可能不一样, 比如 Python 的 import )\n\n去编译试试看效果吧！\n\n![img](https://picx.zhimg.com/80/v2-707190bb4d8800fec14f54bd1af9b743_720w.webp?source=2c26e567)\n\n（编译教程会在第〇课更新）\n\n\n\n## 第〇课：配置编译环境，命令行基础，带参数的 Hello World\n\n\n\n### 1. 命令行基础\n\n告诉你2个秘密: \n\n**秘密1.命令行才是多数软件真实的模样**. 日常所见的各种图形界面软件只不过是隐藏了命令行窗口罢了.\n\n**如果你想入门编程的话, 就要抛弃以电脑桌面为中心的视角, 从现在开始, 把命令行界面看作你的家, 其它的一切都是从这里打开的.**\n\n> 在 Windows 中, 按 WIN+S 搜索 \"CMD\" 或者 \"Powershell\" 或者 \"终端\", 都可打开命令行环境.\n\n**秘密2.软件本身是没有\"安装\"这个概念的**. 软件放在哪个目录无所谓, 是纯靠文件路径来定位和运行的. \n\n比如你想打开文件管理器, 标准做法是在命令行中输入完整路径 C:\\Windows\\explorer.exe 然后回车即可. 任何文件都是这个逻辑, 你可以试试这样打开一个已有的 txt 文件.\n\n但是对于一些需要经常打开的文件，每次都要输入完整路径的话就很麻烦, 有没有更便捷的做法呢? 有的, 那就是\"PATH环境变量\".\n\n什么是\"PATH环境变量\"?\n\n> PATH 是一个常用目录汇总表, 用来存放一些软件所在目录; 当一个软件的目录添加进此列表后, 便可省略完整路径, 只需敲出文件名即可运行; 对于一个命令行软件, 添加进了 PATH 就等于**\"安装\"**了这个软件.\n\n打开环境变量编辑器即可发现, C:\\Windows 已经在列表中了:\n\n![img](https://pic1.zhimg.com/80/v2-d7613e65c214e113f66f935d3801b0ed_720w.webp?source=2c26e567)\n\n这就是为什么直接输 explorer.exe 也能打开文件管理器。\n\n又因为 exe 是二进制文件, 属于系统的最基本的文件, 所以可以省略后缀名, 直接输 explorer 也能打开文件管理器.\n\n这时已经没人能看出来它原本是一个文件了, 它成为了一个**命令**.\n\n这就是各种命令的真面目, 几乎每个命令都能在某个路径下找到对应的二进制文件.\n\n- 命令行软件的典型用法：软件名+参数+参数...，以 [aria2](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=aria2&zhida_source=entity)，ffmpeg 为例......\n- C语言的编译器 GCC 也是一个命令行软件.\n\n### 2. 配置C/C++编译环境\n\n在Windows上安装GCC编译器\n\n1. 访问 [Releases · niXman/mingw-builds-binaries (github.com)](https://link.zhihu.com/?target=https%3A//github.com/niXman/mingw-builds-binaries/releases)\n2. 下载 x86_64-13.1.0-release-win32-seh-ucrt.7z\n3. 解压得 mingw64，放到合适的地方（推荐C盘根目录）\n4. 把 C:/mingw64/bin 添加到 PATH 环境变量:\n\n[win10如何添加环境变量path-百度经验](https://jingyan.baidu.com/article/49711c61197cadba451b7c6f.html)\n\n5. 执行 gcc -v 看看反应, 没有报错说明安装成功.\n\n\n\n### 3. 编译运行你的第一个程序\n\n- 打开命令行, 运行 notepad hello.c (这样就新建了文本文件 hello.c)\n- 粘贴如下内容并保存:\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"你好,我是程序 %s\\n\", argv[0]);\n    if (argc > 1)\n    {\n        printf(\"太好了,有人来了!\\n\");\n    }\n    else\n    {\n        printf(\"怎么一个人都没有?\\n\");\n    }\n\n    for (int i = 1; i < argc; i++)\n    {\n        printf(\"欢迎你,%s!\\n\", argv[i]);\n    }\n    return 0;\n}\n```\n\n- 回到命令行窗口, 执行：\n\n```bash\ngcc *.c -o hello\n```\n\n> 命令解释: \n> 调用 [gcc 编译器](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=gcc+编译器&zhida_source=entity), 并传入了这三个参数: \"*.c\",  \"-o\", \"hello\".\n> *.c 表示选择当前目录下所有 .c 文件 ( 当然, 本例中你可以写 hello.c )\n> -o 表示输出\n> hello 表示会输出文件名为 hello ( 在 Windows 环境下生成的是 hello.exe )\n\n成功后，hello.c的同一目录下会生成 hello.exe 文件\n\n运行：\n\n- 无参数运行：\n\n```text\n./hello\n```\n\n- 有参数运行：\n\n```text\n./hello Tom Jerry\n```\n\n如果出现乱码, 可能是因为文本默认使用了 UTF-8 编码，可以试试把文本另存为 [GBK 编码](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=GBK+编码&zhida_source=entity)重新编译. \n\n![img](https://picx.zhimg.com/80/v2-252a8cb70c53a6501079f22aaf539749_720w.webp?source=2c26e567)\n\n或者不改文本编码，直接用下面这个更彻底的方法.\n\n### *4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象\n\n[win10 配置系统默认utf-8编码 - 聆风牧雨 - 博客园](https://www.cnblogs.com/walker-world/p/9548852.html)\n\n这样设置完以后，你的代码文件夹路径，文件名，变量名，函数名都可以包含中文字符，管理代码时不用再小心翼翼的了。\n\n这样做也有缺点，就是一些使用 GBK 编码的老软件/老游戏/老文件可能会出现乱码. 虽然这些老软件大部分已经淘汰了, 但是还是看个人情况自行选择吧。\n\n\n\n## 第二课：函数和变量，通用程序模型 \n\n### 函数是什么？\n\n函数是最小的程序单位，是程序的细胞。\n\n所以函数的基本运行逻辑和程序完全一致：输入数据->处理数据->输出结果。\n\n\n\n上文中我们直观体会了函数的功能，仔细观察可以发现所有函数的都使用同一个格式：\n\n```c\n某种标记 函数名 (输入数据) { 语句 }\n```\n\n其实整个程序就是一个大函数： int main( ) {   }\n\n其中开头的标记是在指明函数最终的计算结果是什么, int 表示最终得到一个整数, void 表示不给出任何结果 (这是可以的, 很多函数只需要默默做事情就行, 而不必报告结果).\n\n观察 main 函数可看出，语句之间用英文分号隔开, 语句之间可以换行, 函数中可以调用其它函数...等等.\n\n变量是什么？\n\n变量，是数据的搬运工。\n\n\n\n第三课：结构体，类\n\n### 结构体是什么？\n\n...\n\n### 类是什么？\n\n函数实现了操作的模块化；\n\n结构体实现了数据的模块化，\n\n类 = 结构体 + 函数；(C++内容)\n\n所以类实现了统一的模块化。\n\n所以 \"面向对象\" 不是什么高深的东西，它就是 \"模块化思想\" 的直接结果。\n\n\n\n### 实现模块的无序组合的方法：声明与定义分离\n\n\n\nC语言中，当你需要创建一个新的函数供其它函数使用时，需要注意它摆放的顺序。\n\n因为C代码是从上到下顺序解析的。所以一个函数不能调用在它下面出现的函数。\n\n```c\nvoid A()\n{ \n    B();\n}\n\nvoid B()\n{ \n    A();\n}\n```\n\n例如上述代码中 函数 A 试图使用函数 B，但在C语言中这是无法做到的，因为这一行之前没有出现过B的定义，所以A并不知道B的存在. 而 B 调用 A 则是可以的.\n\n函数的依赖往往是树状的，花费一些力气可以整理出合理的顺序. 但是网状的依赖则很难通过调整顺序做到，而且面对成百上千个函数, 没人想在这些烦人的细节上浪费精力。\n\n为了实现模块的无序组合，C语言搞出了一套方法，叫做**声明与定义分离**。使得模块只须声明了名字就可以呼叫了，模块内部的具体内容可以后面补上。\n\n比如上面例子，可以改成：\n\n```c\n//此代码仅用于举例, 请勿实机运行, 会造成死循环\n\n//声明\nvoid A();\nvoid B();\n\n//定义\nvoid A(){ B() }\nvoid B(){ A() }\n```\n\n这样一来, 无论有多少函数 ,只要它存在于声明区, 就可以随便互相调用, 不用考虑顺序. \n\n知道这个动机以后，不用学就可以知道，结构体和类也一定存在类似的设计。\n\n学C++面向对象时的时候，所谓[虚函数](https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=虚函数&zhida_source=entity)也是声明与定义分离的一种应用。\n\n\n\n\n\n\n\n\n\n\n\n**本文的一个核心观点就是：先有需求，再有方法。需求出现之前，任何知识都是无用知识，任何工具都是废物。只传授知识, 不讲述动机的老师全都是不合格的老师.**\n\n你之所以需要一个程序，其实是需要它替代你做一些繁重而无脑的事情。典型的例子就是把一件事重复N遍, 所以你需要循环。\n\n\n\n\n\n\n\n## （未完待续）\n","slug":"编写C语言程序时必须有-include-stdio-h-这一行吗？为什么有时候不需要？","published":1,"updated":"2024-11-29T07:25:36.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3er0006c0wc92dlhte7","content":"<blockquote>\n<p>编写C语言程序时必须有#include&lt;stdio.h&gt;这一行吗？为什么有时候不需要？</p>\n<p>作者：夏洛克<br>链接：<a href=\"https://www.zhihu.com/question/21287371/answer/2819849667\">https://www.zhihu.com/question/21287371/answer/2819849667</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>我的回答不限于当前这个问题。由于市面上C语言教程的编排太垃圾而引发的初学者的一系列困惑都可以在这里解决。</p>\n<p>我认为给编程入门者的C语言教材，<strong>第一课就应该讲清楚 #include</strong>，由此自然的引出<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1&zhida_source=entity\">模块化设计</a>等通用编程思想，展现出从一行代码到一个完整项目的整体印象, 而不是去写无用程序 Hello World。</p>\n<h2 id=\"前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\"><a href=\"#前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\" class=\"headerlink\" title=\"前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\"></a>前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程</h2><p>市面上C语言教程的编排都很垃圾，完全没有逻辑，无脑陈列细节。包括C语言之父 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=Dennis+Ritchie&zhida_source=entity\">Dennis Ritchie</a> 的那本《C程序设计语言》。或者说这本就是罪魁祸首?</p>\n<p>《<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=2&q=C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80&zhida_source=entity\">C程序设计语言</a>》就是一本C语言特性介绍手册，明显是给”<strong>初学C语言的编程人员”<strong>设计的，而不是为</strong>编程初学者</strong>设计的。这书的存在本身没问题, 问题在于是它之后所有的编程教材(不限于C语言)都只会按着这样的编排顺序去堆砌细节，没有一个合理的主线逻辑. 像<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E3%80%8AC+Primer+Plus%E3%80%8B&zhida_source=entity\">《C Primer Plus》</a>这些流行教材更是加剧了这种趋势，实际上只是一些更厚更啰嗦的字典罢了。国内的那些垃圾就更不必提了！</p>\n<p>于是, C语言作为一门流行的编程入门语言, 竟然使得<strong>“学编程要先学C，学C要先懂编程”</strong> 这个 bug 流传至今。以下是我为解决这个 bug 做的尝试。我相信看了这篇回答可以消解初学者们大部分疑惑，包括本题主的疑惑。</p>\n<p>（当然还有第二种方案，那就是先去学 Python 。Python 是真正的 0 基础编程语言，没有上述 Bug. 但是用 Python 入门之后, 还是建议回来学学 C, 学编程是绕不开C语言的。）</p>\n<h2 id=\"第一课：-include-与-模块化编程\"><a href=\"#第一课：-include-与-模块化编程\" class=\"headerlink\" title=\"第一课：#include 与 模块化编程\"></a>第一课：#include 与 模块化编程</h2><p>一个程序就像一台机器，是多个功能模块组合而成的。各模块组合起来后靠一个主体程序( 通常叫做 main )去集中调度。</p>\n<p>例如一台简略的C语言玩具车写法如下：</p>\n<h3 id=\"1-0版\"><a href=\"#1-0版\" class=\"headerlink\" title=\"1.0版\"></a>1.0版</h3><p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>可以观察到，程序由四个辅助功能块：前进，后退，左转，右转，和一个主体功能 main 构成。</p>\n<p>主体通过某种流程去调用了4个功能中的2个，实现了让小车走一个 10×10 正方形回到原地的功能。</p>\n<p>可以看到，我并没有 #include &lt;stdio.h&gt;，但是程序是完全正确的，不作任何修改就可以编译运行（目前没有任何运行结果，因为所有功能函数都是空的）。</p>\n<h3 id=\"2-0版\"><a href=\"#2-0版\" class=\"headerlink\" title=\"2.0版\"></a>2.0版</h3><p>引入 #include 后，可以进一步优化我们的代码结构。</p>\n<p>我们可以把 main 上方的那一大块同类的内容打包起来写在另一个文件里（比如 “遥控器.h”），然后把它与原来的 “玩具车.c” 文件放在同一目录下，如下所示：</p>\n<p>遥控器.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;遥控器.h&quot;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c 里面有了 #include “遥控器.h” 这句话，编译工具就会在编译过程中自动把 “遥控器.h” 里的内容复制到 “玩具车.c” 中 #include 语句所在的位置。这样一来，从机器的角度，2.0版程序和1.0版完全等价，不会出错；</p>\n<p>从人的角度，我们把一组相关的功能作为一个模块打包分离出去了。而 #include 就像是一个组装命令，帮我们把模块组装回来。于是我们可以用模块思想去设计小车的各个组成部分，在不同的文件里写不同的模块，一次只需专注一个部分，写完再组装起来。从此写程序就是造积木和搭积木的游戏！</p>\n<p>从生产的角度，我们可以把大问题拆解成一些子模块，可以交给不同的人分别去解决，最后用 #include 组合起来，实现分工与合作。</p>\n<p>好了，到这里你应该已经明白是否需要 #include 了, 其实就看你是否需要某个功能模块。</p>\n<p>stdio.h 是一个负责向电脑屏幕输入&#x2F;输出信息的模块，十分常用，所以初学者几乎没有不需要的。</p>\n<p>有些模块就是这样, 很常用, 写起来又很麻烦，所以C语言维护者们已经写好一套常用工具，包含 stdio.h 、<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=stdlib.h&zhida_source=entity\">stdlib.h</a>、math.h 等等十多个模块，各有各的用途，称为<strong>“C语言<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E6%A0%87%E5%87%86%E5%BA%93&zhida_source=entity\">标准库</a>”</strong>；它们已经深度内置到编译工具包里了。</p>\n<p>#include “遥控器.h” 这个语句里，双引号里其实不是模块名, 而是模块的文件路径, 因为支持相对路径, 所以同目录下的模块只需写文件名即可。 其它地方的模块可以用绝对路径引入, 类似这样: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;C:/Users/WHO/Downloads/模块.h&quot;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>标准库的路径编译器是认识的, 只要用尖括号 &lt;&gt; 表明一个模块属于标准库, 编译器就能找到它.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-0版\"><a href=\"#3-0版\" class=\"headerlink\" title=\"3.0版\"></a>3.0版</h3><p><a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=printf()&zhida_source=entity\">printf()</a> 就是来自 stdio.h 的一个功能，可以用它在命令行窗口打出文字。</p>\n<p>让我们把它加进小车里，让小车学会向你实时报告运行状态吧。</p>\n<p>遥控器.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;前进 %d 米\\n&quot;</span>,距离); &#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;后退 %d 米\\n&quot;</span>,距离); &#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;左转 %d 度\\n&quot;</span>,角度); &#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;前进 %d 度\\n&quot;</span>,角度); &#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;遥控器.h&quot;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;出发\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;结束\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到遥控器需要使用 printf()，所以我们把 #include&lt;stdio.h&gt; 包含到遥控器头部。</p>\n<p>而玩具车又 #include 了遥控器，于是层层包含最终汇集到 玩具车.c 中，所以现在也可以在玩具车里使用 printf()。</p>\n<p>(能间接包含是C&#x2F;C++语言的特点, 其它语言情况可能不一样, 比如 Python 的 import )</p>\n<p>去编译试试看效果吧！</p>\n<p><img src=\"https://picx.zhimg.com/80/v2-707190bb4d8800fec14f54bd1af9b743_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>（编译教程会在第〇课更新）</p>\n<h2 id=\"第〇课：配置编译环境，命令行基础，带参数的-Hello-World\"><a href=\"#第〇课：配置编译环境，命令行基础，带参数的-Hello-World\" class=\"headerlink\" title=\"第〇课：配置编译环境，命令行基础，带参数的 Hello World\"></a>第〇课：配置编译环境，命令行基础，带参数的 Hello World</h2><h3 id=\"1-命令行基础\"><a href=\"#1-命令行基础\" class=\"headerlink\" title=\"1. 命令行基础\"></a>1. 命令行基础</h3><p>告诉你2个秘密: </p>\n<p><strong>秘密1.命令行才是多数软件真实的模样</strong>. 日常所见的各种图形界面软件只不过是隐藏了命令行窗口罢了.</p>\n<p><strong>如果你想入门编程的话, 就要抛弃以电脑桌面为中心的视角, 从现在开始, 把命令行界面看作你的家, 其它的一切都是从这里打开的.</strong></p>\n<blockquote>\n<p>在 Windows 中, 按 WIN+S 搜索 “CMD” 或者 “Powershell” 或者 “终端”, 都可打开命令行环境.</p>\n</blockquote>\n<p><strong>秘密2.软件本身是没有”安装”这个概念的</strong>. 软件放在哪个目录无所谓, 是纯靠文件路径来定位和运行的. </p>\n<p>比如你想打开文件管理器, 标准做法是在命令行中输入完整路径 C:\\Windows\\explorer.exe 然后回车即可. 任何文件都是这个逻辑, 你可以试试这样打开一个已有的 txt 文件.</p>\n<p>但是对于一些需要经常打开的文件，每次都要输入完整路径的话就很麻烦, 有没有更便捷的做法呢? 有的, 那就是”PATH环境变量”.</p>\n<p>什么是”PATH环境变量”?</p>\n<blockquote>\n<p>PATH 是一个常用目录汇总表, 用来存放一些软件所在目录; 当一个软件的目录添加进此列表后, 便可省略完整路径, 只需敲出文件名即可运行; 对于一个命令行软件, 添加进了 PATH 就等于**”安装”**了这个软件.</p>\n</blockquote>\n<p>打开环境变量编辑器即可发现, C:\\Windows 已经在列表中了:</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d7613e65c214e113f66f935d3801b0ed_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>这就是为什么直接输 explorer.exe 也能打开文件管理器。</p>\n<p>又因为 exe 是二进制文件, 属于系统的最基本的文件, 所以可以省略后缀名, 直接输 explorer 也能打开文件管理器.</p>\n<p>这时已经没人能看出来它原本是一个文件了, 它成为了一个<strong>命令</strong>.</p>\n<p>这就是各种命令的真面目, 几乎每个命令都能在某个路径下找到对应的二进制文件.</p>\n<ul>\n<li>命令行软件的典型用法：软件名+参数+参数…，以 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=aria2&zhida_source=entity\">aria2</a>，ffmpeg 为例……</li>\n<li>C语言的编译器 GCC 也是一个命令行软件.</li>\n</ul>\n<h3 id=\"2-配置C-C-编译环境\"><a href=\"#2-配置C-C-编译环境\" class=\"headerlink\" title=\"2. 配置C&#x2F;C++编译环境\"></a>2. 配置C&#x2F;C++编译环境</h3><p>在Windows上安装GCC编译器</p>\n<ol>\n<li>访问 <a href=\"https://link.zhihu.com/?target=https://github.com/niXman/mingw-builds-binaries/releases\">Releases · niXman&#x2F;mingw-builds-binaries (github.com)</a></li>\n<li>下载 x86_64-13.1.0-release-win32-seh-ucrt.7z</li>\n<li>解压得 mingw64，放到合适的地方（推荐C盘根目录）</li>\n<li>把 C:&#x2F;mingw64&#x2F;bin 添加到 PATH 环境变量:</li>\n</ol>\n<p><a href=\"https://jingyan.baidu.com/article/49711c61197cadba451b7c6f.html\">win10如何添加环境变量path-百度经验</a></p>\n<ol start=\"5\">\n<li>执行 gcc -v 看看反应, 没有报错说明安装成功.</li>\n</ol>\n<h3 id=\"3-编译运行你的第一个程序\"><a href=\"#3-编译运行你的第一个程序\" class=\"headerlink\" title=\"3. 编译运行你的第一个程序\"></a>3. 编译运行你的第一个程序</h3><ul>\n<li>打开命令行, 运行 notepad hello.c (这样就新建了文本文件 hello.c)</li>\n<li>粘贴如下内容并保存:</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;你好,我是程序 %s\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-keyword\">if</span> (argc &gt; <span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;太好了,有人来了!\\n&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;怎么一个人都没有?\\n&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; argc; i++)<br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;欢迎你,%s!\\n&quot;</span>, argv[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>回到命令行窗口, 执行：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">gcc *.c -o hello<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>命令解释:<br>调用 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=gcc+%E7%BC%96%E8%AF%91%E5%99%A8&zhida_source=entity\">gcc 编译器</a>, 并传入了这三个参数: “*.c”,  “-o”, “hello”.<br>*.c 表示选择当前目录下所有 .c 文件 ( 当然, 本例中你可以写 hello.c )<br>-o 表示输出<br>hello 表示会输出文件名为 hello ( 在 Windows 环境下生成的是 hello.exe )</p>\n</blockquote>\n<p>成功后，hello.c的同一目录下会生成 hello.exe 文件</p>\n<p>运行：</p>\n<ul>\n<li>无参数运行：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">./hello<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>有参数运行：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">./hello Tom Jerry<br></code></pre></td></tr></table></figure>\n\n<p>如果出现乱码, 可能是因为文本默认使用了 UTF-8 编码，可以试试把文本另存为 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=GBK+%E7%BC%96%E7%A0%81&zhida_source=entity\">GBK 编码</a>重新编译. </p>\n<p><img src=\"https://picx.zhimg.com/80/v2-252a8cb70c53a6501079f22aaf539749_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>或者不改文本编码，直接用下面这个更彻底的方法.</p>\n<h3 id=\"4-把-Windows-切换到-UTF-8-模式，规避一切中文乱码现象\"><a href=\"#4-把-Windows-切换到-UTF-8-模式，规避一切中文乱码现象\" class=\"headerlink\" title=\"*4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象\"></a>*4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象</h3><p><a href=\"https://www.cnblogs.com/walker-world/p/9548852.html\">win10 配置系统默认utf-8编码 - 聆风牧雨 - 博客园</a></p>\n<p>这样设置完以后，你的代码文件夹路径，文件名，变量名，函数名都可以包含中文字符，管理代码时不用再小心翼翼的了。</p>\n<p>这样做也有缺点，就是一些使用 GBK 编码的老软件&#x2F;老游戏&#x2F;老文件可能会出现乱码. 虽然这些老软件大部分已经淘汰了, 但是还是看个人情况自行选择吧。</p>\n<h2 id=\"第二课：函数和变量，通用程序模型\"><a href=\"#第二课：函数和变量，通用程序模型\" class=\"headerlink\" title=\"第二课：函数和变量，通用程序模型\"></a>第二课：函数和变量，通用程序模型</h2><h3 id=\"函数是什么？\"><a href=\"#函数是什么？\" class=\"headerlink\" title=\"函数是什么？\"></a>函数是什么？</h3><p>函数是最小的程序单位，是程序的细胞。</p>\n<p>所以函数的基本运行逻辑和程序完全一致：输入数据-&gt;处理数据-&gt;输出结果。</p>\n<p>上文中我们直观体会了函数的功能，仔细观察可以发现所有函数的都使用同一个格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">某种标记 函数名 (输入数据) &#123; 语句 &#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实整个程序就是一个大函数： int main( ) {   }</p>\n<p>其中开头的标记是在指明函数最终的计算结果是什么, int 表示最终得到一个整数, void 表示不给出任何结果 (这是可以的, 很多函数只需要默默做事情就行, 而不必报告结果).</p>\n<p>观察 main 函数可看出，语句之间用英文分号隔开, 语句之间可以换行, 函数中可以调用其它函数…等等.</p>\n<p>变量是什么？</p>\n<p>变量，是数据的搬运工。</p>\n<p>第三课：结构体，类</p>\n<h3 id=\"结构体是什么？\"><a href=\"#结构体是什么？\" class=\"headerlink\" title=\"结构体是什么？\"></a>结构体是什么？</h3><p>…</p>\n<h3 id=\"类是什么？\"><a href=\"#类是什么？\" class=\"headerlink\" title=\"类是什么？\"></a>类是什么？</h3><p>函数实现了操作的模块化；</p>\n<p>结构体实现了数据的模块化，</p>\n<p>类 &#x3D; 结构体 + 函数；(C++内容)</p>\n<p>所以类实现了统一的模块化。</p>\n<p>所以 “面向对象” 不是什么高深的东西，它就是 “模块化思想” 的直接结果。</p>\n<h3 id=\"实现模块的无序组合的方法：声明与定义分离\"><a href=\"#实现模块的无序组合的方法：声明与定义分离\" class=\"headerlink\" title=\"实现模块的无序组合的方法：声明与定义分离\"></a>实现模块的无序组合的方法：声明与定义分离</h3><p>C语言中，当你需要创建一个新的函数供其它函数使用时，需要注意它摆放的顺序。</p>\n<p>因为C代码是从上到下顺序解析的。所以一个函数不能调用在它下面出现的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span><br>&#123; <br>    B();<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span><br>&#123; <br>    A();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如上述代码中 函数 A 试图使用函数 B，但在C语言中这是无法做到的，因为这一行之前没有出现过B的定义，所以A并不知道B的存在. 而 B 调用 A 则是可以的.</p>\n<p>函数的依赖往往是树状的，花费一些力气可以整理出合理的顺序. 但是网状的依赖则很难通过调整顺序做到，而且面对成百上千个函数, 没人想在这些烦人的细节上浪费精力。</p>\n<p>为了实现模块的无序组合，C语言搞出了一套方法，叫做<strong>声明与定义分离</strong>。使得模块只须声明了名字就可以呼叫了，模块内部的具体内容可以后面补上。</p>\n<p>比如上面例子，可以改成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//此代码仅用于举例, 请勿实机运行, 会造成死循环</span><br><br><span class=\"hljs-comment\">//声明</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>;<br><br><span class=\"hljs-comment\">//定义</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>&#123; B() &#125;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>&#123; A() &#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样一来, 无论有多少函数 ,只要它存在于声明区, 就可以随便互相调用, 不用考虑顺序. </p>\n<p>知道这个动机以后，不用学就可以知道，结构体和类也一定存在类似的设计。</p>\n<p>学C++面向对象时的时候，所谓<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity\">虚函数</a>也是声明与定义分离的一种应用。</p>\n<p><strong>本文的一个核心观点就是：先有需求，再有方法。需求出现之前，任何知识都是无用知识，任何工具都是废物。只传授知识, 不讲述动机的老师全都是不合格的老师.</strong></p>\n<p>你之所以需要一个程序，其实是需要它替代你做一些繁重而无脑的事情。典型的例子就是把一件事重复N遍, 所以你需要循环。</p>\n<h2 id=\"（未完待续）\"><a href=\"#（未完待续）\" class=\"headerlink\" title=\"（未完待续）\"></a>（未完待续）</h2>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>编写C语言程序时必须有#include&lt;stdio.h&gt;这一行吗？为什么有时候不需要？</p>\n<p>作者：夏洛克<br>链接：<a href=\"https://www.zhihu.com/question/21287371/answer/2819849667\">https://www.zhihu.com/question/21287371/answer/2819849667</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>我的回答不限于当前这个问题。由于市面上C语言教程的编排太垃圾而引发的初学者的一系列困惑都可以在这里解决。</p>\n<p>我认为给编程入门者的C语言教材，<strong>第一课就应该讲清楚 #include</strong>，由此自然的引出<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1&zhida_source=entity\">模块化设计</a>等通用编程思想，展现出从一行代码到一个完整项目的整体印象, 而不是去写无用程序 Hello World。</p>\n<h2 id=\"前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\"><a href=\"#前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\" class=\"headerlink\" title=\"前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程\"></a>前言：关于编程教材的吐槽：学编程要先学C，学C要先懂编程</h2><p>市面上C语言教程的编排都很垃圾，完全没有逻辑，无脑陈列细节。包括C语言之父 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=Dennis+Ritchie&zhida_source=entity\">Dennis Ritchie</a> 的那本《C程序设计语言》。或者说这本就是罪魁祸首?</p>\n<p>《<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=2&q=C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80&zhida_source=entity\">C程序设计语言</a>》就是一本C语言特性介绍手册，明显是给”<strong>初学C语言的编程人员”<strong>设计的，而不是为</strong>编程初学者</strong>设计的。这书的存在本身没问题, 问题在于是它之后所有的编程教材(不限于C语言)都只会按着这样的编排顺序去堆砌细节，没有一个合理的主线逻辑. 像<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E3%80%8AC+Primer+Plus%E3%80%8B&zhida_source=entity\">《C Primer Plus》</a>这些流行教材更是加剧了这种趋势，实际上只是一些更厚更啰嗦的字典罢了。国内的那些垃圾就更不必提了！</p>\n<p>于是, C语言作为一门流行的编程入门语言, 竟然使得<strong>“学编程要先学C，学C要先懂编程”</strong> 这个 bug 流传至今。以下是我为解决这个 bug 做的尝试。我相信看了这篇回答可以消解初学者们大部分疑惑，包括本题主的疑惑。</p>\n<p>（当然还有第二种方案，那就是先去学 Python 。Python 是真正的 0 基础编程语言，没有上述 Bug. 但是用 Python 入门之后, 还是建议回来学学 C, 学编程是绕不开C语言的。）</p>\n<h2 id=\"第一课：-include-与-模块化编程\"><a href=\"#第一课：-include-与-模块化编程\" class=\"headerlink\" title=\"第一课：#include 与 模块化编程\"></a>第一课：#include 与 模块化编程</h2><p>一个程序就像一台机器，是多个功能模块组合而成的。各模块组合起来后靠一个主体程序( 通常叫做 main )去集中调度。</p>\n<p>例如一台简略的C语言玩具车写法如下：</p>\n<h3 id=\"1-0版\"><a href=\"#1-0版\" class=\"headerlink\" title=\"1.0版\"></a>1.0版</h3><p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>&#123;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>可以观察到，程序由四个辅助功能块：前进，后退，左转，右转，和一个主体功能 main 构成。</p>\n<p>主体通过某种流程去调用了4个功能中的2个，实现了让小车走一个 10×10 正方形回到原地的功能。</p>\n<p>可以看到，我并没有 #include &lt;stdio.h&gt;，但是程序是完全正确的，不作任何修改就可以编译运行（目前没有任何运行结果，因为所有功能函数都是空的）。</p>\n<h3 id=\"2-0版\"><a href=\"#2-0版\" class=\"headerlink\" title=\"2.0版\"></a>2.0版</h3><p>引入 #include 后，可以进一步优化我们的代码结构。</p>\n<p>我们可以把 main 上方的那一大块同类的内容打包起来写在另一个文件里（比如 “遥控器.h”），然后把它与原来的 “玩具车.c” 文件放在同一目录下，如下所示：</p>\n<p>遥控器.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123;<span class=\"hljs-comment\">/*具体实现*/</span>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;遥控器.h&quot;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c 里面有了 #include “遥控器.h” 这句话，编译工具就会在编译过程中自动把 “遥控器.h” 里的内容复制到 “玩具车.c” 中 #include 语句所在的位置。这样一来，从机器的角度，2.0版程序和1.0版完全等价，不会出错；</p>\n<p>从人的角度，我们把一组相关的功能作为一个模块打包分离出去了。而 #include 就像是一个组装命令，帮我们把模块组装回来。于是我们可以用模块思想去设计小车的各个组成部分，在不同的文件里写不同的模块，一次只需专注一个部分，写完再组装起来。从此写程序就是造积木和搭积木的游戏！</p>\n<p>从生产的角度，我们可以把大问题拆解成一些子模块，可以交给不同的人分别去解决，最后用 #include 组合起来，实现分工与合作。</p>\n<p>好了，到这里你应该已经明白是否需要 #include 了, 其实就看你是否需要某个功能模块。</p>\n<p>stdio.h 是一个负责向电脑屏幕输入&#x2F;输出信息的模块，十分常用，所以初学者几乎没有不需要的。</p>\n<p>有些模块就是这样, 很常用, 写起来又很麻烦，所以C语言维护者们已经写好一套常用工具，包含 stdio.h 、<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=stdlib.h&zhida_source=entity\">stdlib.h</a>、math.h 等等十多个模块，各有各的用途，称为<strong>“C语言<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E6%A0%87%E5%87%86%E5%BA%93&zhida_source=entity\">标准库</a>”</strong>；它们已经深度内置到编译工具包里了。</p>\n<p>#include “遥控器.h” 这个语句里，双引号里其实不是模块名, 而是模块的文件路径, 因为支持相对路径, 所以同目录下的模块只需写文件名即可。 其它地方的模块可以用绝对路径引入, 类似这样: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;C:/Users/WHO/Downloads/模块.h&quot;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>标准库的路径编译器是认识的, 只要用尖括号 &lt;&gt; 表明一个模块属于标准库, 编译器就能找到它.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-0版\"><a href=\"#3-0版\" class=\"headerlink\" title=\"3.0版\"></a>3.0版</h3><p><a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=printf()&zhida_source=entity\">printf()</a> 就是来自 stdio.h 的一个功能，可以用它在命令行窗口打出文字。</p>\n<p>让我们把它加进小车里，让小车学会向你实时报告运行状态吧。</p>\n<p>遥控器.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">void</span> 前进(<span class=\"hljs-type\">int</span> 距离)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;前进 %d 米\\n&quot;</span>,距离); &#125;<br><span class=\"hljs-type\">void</span> 后退(<span class=\"hljs-type\">int</span> 距离)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;后退 %d 米\\n&quot;</span>,距离); &#125;<br><span class=\"hljs-type\">void</span> 左转(<span class=\"hljs-type\">int</span> 角度)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;左转 %d 度\\n&quot;</span>,角度); &#125;<br><span class=\"hljs-type\">void</span> 右转(<span class=\"hljs-type\">int</span> 角度)&#123; <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;前进 %d 度\\n&quot;</span>,角度); &#125;<br></code></pre></td></tr></table></figure>\n\n<p>玩具车.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;遥控器.h&quot;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;出发\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">4</span>; i++)  <span class=\"hljs-comment\">//循环(4)次</span><br>    &#123;<br>        前进(<span class=\"hljs-number\">10</span>);<br>        右转(<span class=\"hljs-number\">90</span>);<br>    &#125;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;结束\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到遥控器需要使用 printf()，所以我们把 #include&lt;stdio.h&gt; 包含到遥控器头部。</p>\n<p>而玩具车又 #include 了遥控器，于是层层包含最终汇集到 玩具车.c 中，所以现在也可以在玩具车里使用 printf()。</p>\n<p>(能间接包含是C&#x2F;C++语言的特点, 其它语言情况可能不一样, 比如 Python 的 import )</p>\n<p>去编译试试看效果吧！</p>\n<p><img src=\"https://picx.zhimg.com/80/v2-707190bb4d8800fec14f54bd1af9b743_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>（编译教程会在第〇课更新）</p>\n<h2 id=\"第〇课：配置编译环境，命令行基础，带参数的-Hello-World\"><a href=\"#第〇课：配置编译环境，命令行基础，带参数的-Hello-World\" class=\"headerlink\" title=\"第〇课：配置编译环境，命令行基础，带参数的 Hello World\"></a>第〇课：配置编译环境，命令行基础，带参数的 Hello World</h2><h3 id=\"1-命令行基础\"><a href=\"#1-命令行基础\" class=\"headerlink\" title=\"1. 命令行基础\"></a>1. 命令行基础</h3><p>告诉你2个秘密: </p>\n<p><strong>秘密1.命令行才是多数软件真实的模样</strong>. 日常所见的各种图形界面软件只不过是隐藏了命令行窗口罢了.</p>\n<p><strong>如果你想入门编程的话, 就要抛弃以电脑桌面为中心的视角, 从现在开始, 把命令行界面看作你的家, 其它的一切都是从这里打开的.</strong></p>\n<blockquote>\n<p>在 Windows 中, 按 WIN+S 搜索 “CMD” 或者 “Powershell” 或者 “终端”, 都可打开命令行环境.</p>\n</blockquote>\n<p><strong>秘密2.软件本身是没有”安装”这个概念的</strong>. 软件放在哪个目录无所谓, 是纯靠文件路径来定位和运行的. </p>\n<p>比如你想打开文件管理器, 标准做法是在命令行中输入完整路径 C:\\Windows\\explorer.exe 然后回车即可. 任何文件都是这个逻辑, 你可以试试这样打开一个已有的 txt 文件.</p>\n<p>但是对于一些需要经常打开的文件，每次都要输入完整路径的话就很麻烦, 有没有更便捷的做法呢? 有的, 那就是”PATH环境变量”.</p>\n<p>什么是”PATH环境变量”?</p>\n<blockquote>\n<p>PATH 是一个常用目录汇总表, 用来存放一些软件所在目录; 当一个软件的目录添加进此列表后, 便可省略完整路径, 只需敲出文件名即可运行; 对于一个命令行软件, 添加进了 PATH 就等于**”安装”**了这个软件.</p>\n</blockquote>\n<p>打开环境变量编辑器即可发现, C:\\Windows 已经在列表中了:</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d7613e65c214e113f66f935d3801b0ed_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>这就是为什么直接输 explorer.exe 也能打开文件管理器。</p>\n<p>又因为 exe 是二进制文件, 属于系统的最基本的文件, 所以可以省略后缀名, 直接输 explorer 也能打开文件管理器.</p>\n<p>这时已经没人能看出来它原本是一个文件了, 它成为了一个<strong>命令</strong>.</p>\n<p>这就是各种命令的真面目, 几乎每个命令都能在某个路径下找到对应的二进制文件.</p>\n<ul>\n<li>命令行软件的典型用法：软件名+参数+参数…，以 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=aria2&zhida_source=entity\">aria2</a>，ffmpeg 为例……</li>\n<li>C语言的编译器 GCC 也是一个命令行软件.</li>\n</ul>\n<h3 id=\"2-配置C-C-编译环境\"><a href=\"#2-配置C-C-编译环境\" class=\"headerlink\" title=\"2. 配置C&#x2F;C++编译环境\"></a>2. 配置C&#x2F;C++编译环境</h3><p>在Windows上安装GCC编译器</p>\n<ol>\n<li>访问 <a href=\"https://link.zhihu.com/?target=https://github.com/niXman/mingw-builds-binaries/releases\">Releases · niXman&#x2F;mingw-builds-binaries (github.com)</a></li>\n<li>下载 x86_64-13.1.0-release-win32-seh-ucrt.7z</li>\n<li>解压得 mingw64，放到合适的地方（推荐C盘根目录）</li>\n<li>把 C:&#x2F;mingw64&#x2F;bin 添加到 PATH 环境变量:</li>\n</ol>\n<p><a href=\"https://jingyan.baidu.com/article/49711c61197cadba451b7c6f.html\">win10如何添加环境变量path-百度经验</a></p>\n<ol start=\"5\">\n<li>执行 gcc -v 看看反应, 没有报错说明安装成功.</li>\n</ol>\n<h3 id=\"3-编译运行你的第一个程序\"><a href=\"#3-编译运行你的第一个程序\" class=\"headerlink\" title=\"3. 编译运行你的第一个程序\"></a>3. 编译运行你的第一个程序</h3><ul>\n<li>打开命令行, 运行 notepad hello.c (这样就新建了文本文件 hello.c)</li>\n<li>粘贴如下内容并保存:</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;你好,我是程序 %s\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>]);<br>    <span class=\"hljs-keyword\">if</span> (argc &gt; <span class=\"hljs-number\">1</span>)<br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;太好了,有人来了!\\n&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;怎么一个人都没有?\\n&quot;</span>);<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; argc; i++)<br>    &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;欢迎你,%s!\\n&quot;</span>, argv[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>回到命令行窗口, 执行：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">gcc *.c -o hello<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>命令解释:<br>调用 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=gcc+%E7%BC%96%E8%AF%91%E5%99%A8&zhida_source=entity\">gcc 编译器</a>, 并传入了这三个参数: “*.c”,  “-o”, “hello”.<br>*.c 表示选择当前目录下所有 .c 文件 ( 当然, 本例中你可以写 hello.c )<br>-o 表示输出<br>hello 表示会输出文件名为 hello ( 在 Windows 环境下生成的是 hello.exe )</p>\n</blockquote>\n<p>成功后，hello.c的同一目录下会生成 hello.exe 文件</p>\n<p>运行：</p>\n<ul>\n<li>无参数运行：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">./hello<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>有参数运行：</li>\n</ul>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">./hello Tom Jerry<br></code></pre></td></tr></table></figure>\n\n<p>如果出现乱码, 可能是因为文本默认使用了 UTF-8 编码，可以试试把文本另存为 <a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=GBK+%E7%BC%96%E7%A0%81&zhida_source=entity\">GBK 编码</a>重新编译. </p>\n<p><img src=\"https://picx.zhimg.com/80/v2-252a8cb70c53a6501079f22aaf539749_720w.webp?source=2c26e567\" alt=\"img\"></p>\n<p>或者不改文本编码，直接用下面这个更彻底的方法.</p>\n<h3 id=\"4-把-Windows-切换到-UTF-8-模式，规避一切中文乱码现象\"><a href=\"#4-把-Windows-切换到-UTF-8-模式，规避一切中文乱码现象\" class=\"headerlink\" title=\"*4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象\"></a>*4. 把 Windows 切换到 UTF-8 模式，规避一切中文乱码现象</h3><p><a href=\"https://www.cnblogs.com/walker-world/p/9548852.html\">win10 配置系统默认utf-8编码 - 聆风牧雨 - 博客园</a></p>\n<p>这样设置完以后，你的代码文件夹路径，文件名，变量名，函数名都可以包含中文字符，管理代码时不用再小心翼翼的了。</p>\n<p>这样做也有缺点，就是一些使用 GBK 编码的老软件&#x2F;老游戏&#x2F;老文件可能会出现乱码. 虽然这些老软件大部分已经淘汰了, 但是还是看个人情况自行选择吧。</p>\n<h2 id=\"第二课：函数和变量，通用程序模型\"><a href=\"#第二课：函数和变量，通用程序模型\" class=\"headerlink\" title=\"第二课：函数和变量，通用程序模型\"></a>第二课：函数和变量，通用程序模型</h2><h3 id=\"函数是什么？\"><a href=\"#函数是什么？\" class=\"headerlink\" title=\"函数是什么？\"></a>函数是什么？</h3><p>函数是最小的程序单位，是程序的细胞。</p>\n<p>所以函数的基本运行逻辑和程序完全一致：输入数据-&gt;处理数据-&gt;输出结果。</p>\n<p>上文中我们直观体会了函数的功能，仔细观察可以发现所有函数的都使用同一个格式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">某种标记 函数名 (输入数据) &#123; 语句 &#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实整个程序就是一个大函数： int main( ) {   }</p>\n<p>其中开头的标记是在指明函数最终的计算结果是什么, int 表示最终得到一个整数, void 表示不给出任何结果 (这是可以的, 很多函数只需要默默做事情就行, 而不必报告结果).</p>\n<p>观察 main 函数可看出，语句之间用英文分号隔开, 语句之间可以换行, 函数中可以调用其它函数…等等.</p>\n<p>变量是什么？</p>\n<p>变量，是数据的搬运工。</p>\n<p>第三课：结构体，类</p>\n<h3 id=\"结构体是什么？\"><a href=\"#结构体是什么？\" class=\"headerlink\" title=\"结构体是什么？\"></a>结构体是什么？</h3><p>…</p>\n<h3 id=\"类是什么？\"><a href=\"#类是什么？\" class=\"headerlink\" title=\"类是什么？\"></a>类是什么？</h3><p>函数实现了操作的模块化；</p>\n<p>结构体实现了数据的模块化，</p>\n<p>类 &#x3D; 结构体 + 函数；(C++内容)</p>\n<p>所以类实现了统一的模块化。</p>\n<p>所以 “面向对象” 不是什么高深的东西，它就是 “模块化思想” 的直接结果。</p>\n<h3 id=\"实现模块的无序组合的方法：声明与定义分离\"><a href=\"#实现模块的无序组合的方法：声明与定义分离\" class=\"headerlink\" title=\"实现模块的无序组合的方法：声明与定义分离\"></a>实现模块的无序组合的方法：声明与定义分离</h3><p>C语言中，当你需要创建一个新的函数供其它函数使用时，需要注意它摆放的顺序。</p>\n<p>因为C代码是从上到下顺序解析的。所以一个函数不能调用在它下面出现的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span><br>&#123; <br>    B();<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span><br>&#123; <br>    A();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>例如上述代码中 函数 A 试图使用函数 B，但在C语言中这是无法做到的，因为这一行之前没有出现过B的定义，所以A并不知道B的存在. 而 B 调用 A 则是可以的.</p>\n<p>函数的依赖往往是树状的，花费一些力气可以整理出合理的顺序. 但是网状的依赖则很难通过调整顺序做到，而且面对成百上千个函数, 没人想在这些烦人的细节上浪费精力。</p>\n<p>为了实现模块的无序组合，C语言搞出了一套方法，叫做<strong>声明与定义分离</strong>。使得模块只须声明了名字就可以呼叫了，模块内部的具体内容可以后面补上。</p>\n<p>比如上面例子，可以改成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//此代码仅用于举例, 请勿实机运行, 会造成死循环</span><br><br><span class=\"hljs-comment\">//声明</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>;<br><br><span class=\"hljs-comment\">//定义</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">A</span><span class=\"hljs-params\">()</span>&#123; B() &#125;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">B</span><span class=\"hljs-params\">()</span>&#123; A() &#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样一来, 无论有多少函数 ,只要它存在于声明区, 就可以随便互相调用, 不用考虑顺序. </p>\n<p>知道这个动机以后，不用学就可以知道，结构体和类也一定存在类似的设计。</p>\n<p>学C++面向对象时的时候，所谓<a href=\"https://zhida.zhihu.com/search?content_id=542784646&content_type=Answer&match_order=1&q=%E8%99%9A%E5%87%BD%E6%95%B0&zhida_source=entity\">虚函数</a>也是声明与定义分离的一种应用。</p>\n<p><strong>本文的一个核心观点就是：先有需求，再有方法。需求出现之前，任何知识都是无用知识，任何工具都是废物。只传授知识, 不讲述动机的老师全都是不合格的老师.</strong></p>\n<p>你之所以需要一个程序，其实是需要它替代你做一些繁重而无脑的事情。典型的例子就是把一件事重复N遍, 所以你需要循环。</p>\n<h2 id=\"（未完待续）\"><a href=\"#（未完待续）\" class=\"headerlink\" title=\"（未完待续）\"></a>（未完待续）</h2>"},{"title":"深刻哀悼","date":"2024-09-10T16:13:17.000Z","_content":"\nIn this era of information explosion, my blog is like a loyal friend who has accompanied me through countless unforgettable days and nights. Unfortunately, it has recently suffered severe data loss, which has left me heartbroken.\n\nThis online corner used to be a safe haven for me to express my emotions, record the details of my life, and exchange ideas. Every blog post contains my passion for life and thirst for knowledge. Nowadays, these precious words have dissipated with the wind and seem to have never appeared before. The time spent late at night with my blog witnessed my growth trajectory, recorded my laughter and tears, and I will always remember them.\n\nHere, I would like to express my deep condolences for my blog. Although it has passed away, those beautiful memories will forever be cherished in my heart. I will pick myself up again and continue writing my story from a new starting point. May my blog rest in peace on the other side of the virtual world. Old Station（ https://old.ianwusb.blog/ ）As a commemoration, a new chapter will begin here.\n\nExploring the mysteries of programming and uncovering the wonders of life - welcome to my blog!\nIn this world full of infinite possibilities, programming and biology intertwine to create a unique charm. One is synonymous with innovation, while the other is the guardian of the mysteries of life. Here, I will take you to appreciate the subtleties of these two disciplines and explore the wonderful journey of programming and biology together.\n\nProgramming is not just a string of code, it is a way of thinking and a way to solve problems. Its charm lies in its ability to turn imagination into reality and transform intangible ideas into tangible works. In this vast world, I will share my programming insights and experience the endless creativity and enormous potential that programming brings with you.\n\nAt the same time, biology attracts us with its unique charm. The mysteries of life and the miracles of evolution are all fascinating to people. Here, I will delve into high school biology knowledge, take you on a journey to appreciate the charm of biology, and together unravel the mysteries of life.\n\nMy blog is not only a platform for sharing programming and biology knowledge, but also a stage for inspiring thinking and sparking collisions. I hope that through my words, I can ignite your passion for programming and biology, and inspire your innovative potential.\n\nIn addition, we also welcome friends who love writing to submit articles here. Just send your work to fastjackcost880@gmail.com Please indicate 'blog submission', and your wisdom and insights will have the opportunity to shine here.\n\nLet's embark on the journey of exploring programming and biology together, and write our own innovative chapter! Stay tuned, more exciting content is about to be presented. Welcome to subscribe, follow, and grow together with me!\n\n# Declaration\n\nDear user:\nWelcome to visit this website. We solemnly declare that all articles contained on this website are intended for learning and communication purposes. This website is committed to providing users with rich, valuable, and legitimate information resources to promote the dissemination of knowledge and academic progress.\nAccording to the provisions of the Cybersecurity Law, Copyright Law, and other relevant laws of the People's Republic of China, we remind all users to pay attention to the following points:\n\n1. All articles published on this website are protected by copyright law. Without the explicit authorization of the article author or this website, no unit or individual may copy, disseminate, publish, reprint, excerpt, translate or use them in any form.\n2. Users shall comply with national laws and regulations when using the content of articles provided on this website, and shall not use it for any illegal purposes or commercial purposes.\n3. This website strictly prohibits any behavior that infringes on the intellectual property rights of others, including but not limited to unauthorized uploading, downloading, and dissemination of infringing content.\n   If you believe that the content of this website infringes on your copyright or other legitimate rights and interests, please contact us immediately, and we will handle it promptly and take appropriate measures.\n4. This website reserves the right to take legal action against users who violate this statement, including but not limited to warning, deleting infringing content, restricting access, and pursuing legal responsibility.\n5. This website encourages healthy communication and cooperation among users, but requires users to respect the rights of others during the communication process and not publish illegal information and harmful content.\n6. This website will continuously improve and update its content to ensure the legality, accuracy, and timeliness of information.\n   Please consciously abide by the above regulations when using this website, and jointly maintain a healthy and orderly online environment. If you have any questions or need assistance, please contact us（ blog@ianwusb.blog ）.\n   Thank you for your understanding and cooperation.\n\n\n\n在这个信息爆炸的时代，我的博客就像一位不离不弃的挚友，陪我度过了无数难忘的日夜。然而，不幸的是，最近它遭遇了严重的数据丢失，让我痛心不已。\n\n这个网络角落，曾是我倾诉情感、记载生活点滴、交流思想的避风港。每一篇博文都蕴含着我对生活的热情和对知识的渴求。如今，这些珍贵的文字随风消散，似乎从未出现过。那些深夜与博客相伴的时光，它见证了我的成长轨迹，记录了我的欢笑与泪水，我将永远铭记。\n\n在此，我要对我的博客表示深切的哀悼。虽然它已经离我而去，但那些美好的记忆将永远珍藏在我心中。我将重新振作，以新的起点，继续书写我的故事。愿我的博客在虚拟世界的另一端得以安息。旧站（https://old.ianwusb.blog/）将保留作为纪念，新的篇章将从这里开始。\n\n------\n\n探索编程的奥秘，揭秘生命的奇迹——欢迎来到我的博客！\n\n在这个充满无限可能的世界里，编程与生物学交织出独特的魅力。一方是创新的代名词，另一方则是生命奥秘的守护者。在这里，我将带你领略这两大学科的精妙之处，共同探索编程与生物学的奇妙旅程。\n编程，不仅仅是一串代码，它是一种思维方式，一种解决问题的途径。它的魅力在于，让我们能够将想象化为现实，将无形的思想转化为有形的作品。在这片广阔的天地里，我将分享我的编程心得，与你一同感受编程带来的无尽创造力和巨大潜力。\n\n与此同时，生物学以其独特的魅力吸引着我们。生命的奥秘、进化的奇迹，无不让人为之着迷。在这里，我将深入剖析高中生物知识，带你领略生物学的魅力，共同揭开生命之谜。\n\n我的博客，不仅是一个分享编程与生物学知识的平台，更是一个激发思考、碰撞火花的舞台。希望通过我的文字，能够点燃你对编程和生物学的热情，激发你的创新潜能。\n\n此外，这里也欢迎广大爱好写作的朋友投稿。只需将你的作品发送至fastjackcost880@gmail.com，注明“博客提交”，你的智慧与见解就有机会在这里绽放光芒。\n\n让我们一起，踏上探索编程与生物学的征途，书写属于我们的创新篇章！敬请期待，更多精彩内容即将呈现。欢迎订阅、关注，与我一同成长！\n\n------\n\n\n# 声明\n\n尊敬的用户：\n\n欢迎您访问本网站。我们郑重声明，本网站所包含的所有文章内容均为提供学习和交流之用。本网站致力于为用户提供丰富、有价值且合法的信息资源，以促进知识的传播和学术的进步。\n\n根据中华人民共和国网络安全法、著作权法以及其他相关法律的规定，我们提醒所有用户注意以下几点：\n\n1. 本网站上发布的所有文章均受著作权法保护，未经文章作者或本网站的明确授权，任何单位或个人不得以任何形式复制、传播、出版、转载、摘编、翻译或进行其他形式的使用。\n2. 用户在使用本网站提供的文章内容时，应遵守国家法律法规，不得用于任何非法目的或商业性使用。\n3. 本网站严格禁止任何侵犯他人知识产权的行为，包括但不限于未经许可的上传、下载、传播侵权内容。\n4. 若您认为本网站的内容侵犯了您的著作权或其他合法权益，请立即与我们联系，我们将及时处理并采取适当措施。\n5. 本网站保留对违反本声明的用户采取法律行动的权利，包括但不限于警告、删除侵权内容、限制访问、追究法律责任等。\n6. 本网站鼓励用户之间的健康交流与合作，但要求用户在交流过程中尊重他人权利，不发布违法信息和不良内容。\n7. 本网站将不断完善和更新内容，以确保信息的合法性、准确性和时效性。\n\n请您在使用本网站时，自觉遵守上述规定，共同维护一个健康、有序的网络环境。如果您有任何疑问或需要帮助，请联系我们（blog@ianwusb.blog）。\n\n感谢您的理解与合作。\n","source":"_posts/深刻哀悼.md","raw":"---\ntitle: 深刻哀悼\ndate: 2024-09-11 00:13:17\ntags:\n---\n\nIn this era of information explosion, my blog is like a loyal friend who has accompanied me through countless unforgettable days and nights. Unfortunately, it has recently suffered severe data loss, which has left me heartbroken.\n\nThis online corner used to be a safe haven for me to express my emotions, record the details of my life, and exchange ideas. Every blog post contains my passion for life and thirst for knowledge. Nowadays, these precious words have dissipated with the wind and seem to have never appeared before. The time spent late at night with my blog witnessed my growth trajectory, recorded my laughter and tears, and I will always remember them.\n\nHere, I would like to express my deep condolences for my blog. Although it has passed away, those beautiful memories will forever be cherished in my heart. I will pick myself up again and continue writing my story from a new starting point. May my blog rest in peace on the other side of the virtual world. Old Station（ https://old.ianwusb.blog/ ）As a commemoration, a new chapter will begin here.\n\nExploring the mysteries of programming and uncovering the wonders of life - welcome to my blog!\nIn this world full of infinite possibilities, programming and biology intertwine to create a unique charm. One is synonymous with innovation, while the other is the guardian of the mysteries of life. Here, I will take you to appreciate the subtleties of these two disciplines and explore the wonderful journey of programming and biology together.\n\nProgramming is not just a string of code, it is a way of thinking and a way to solve problems. Its charm lies in its ability to turn imagination into reality and transform intangible ideas into tangible works. In this vast world, I will share my programming insights and experience the endless creativity and enormous potential that programming brings with you.\n\nAt the same time, biology attracts us with its unique charm. The mysteries of life and the miracles of evolution are all fascinating to people. Here, I will delve into high school biology knowledge, take you on a journey to appreciate the charm of biology, and together unravel the mysteries of life.\n\nMy blog is not only a platform for sharing programming and biology knowledge, but also a stage for inspiring thinking and sparking collisions. I hope that through my words, I can ignite your passion for programming and biology, and inspire your innovative potential.\n\nIn addition, we also welcome friends who love writing to submit articles here. Just send your work to fastjackcost880@gmail.com Please indicate 'blog submission', and your wisdom and insights will have the opportunity to shine here.\n\nLet's embark on the journey of exploring programming and biology together, and write our own innovative chapter! Stay tuned, more exciting content is about to be presented. Welcome to subscribe, follow, and grow together with me!\n\n# Declaration\n\nDear user:\nWelcome to visit this website. We solemnly declare that all articles contained on this website are intended for learning and communication purposes. This website is committed to providing users with rich, valuable, and legitimate information resources to promote the dissemination of knowledge and academic progress.\nAccording to the provisions of the Cybersecurity Law, Copyright Law, and other relevant laws of the People's Republic of China, we remind all users to pay attention to the following points:\n\n1. All articles published on this website are protected by copyright law. Without the explicit authorization of the article author or this website, no unit or individual may copy, disseminate, publish, reprint, excerpt, translate or use them in any form.\n2. Users shall comply with national laws and regulations when using the content of articles provided on this website, and shall not use it for any illegal purposes or commercial purposes.\n3. This website strictly prohibits any behavior that infringes on the intellectual property rights of others, including but not limited to unauthorized uploading, downloading, and dissemination of infringing content.\n   If you believe that the content of this website infringes on your copyright or other legitimate rights and interests, please contact us immediately, and we will handle it promptly and take appropriate measures.\n4. This website reserves the right to take legal action against users who violate this statement, including but not limited to warning, deleting infringing content, restricting access, and pursuing legal responsibility.\n5. This website encourages healthy communication and cooperation among users, but requires users to respect the rights of others during the communication process and not publish illegal information and harmful content.\n6. This website will continuously improve and update its content to ensure the legality, accuracy, and timeliness of information.\n   Please consciously abide by the above regulations when using this website, and jointly maintain a healthy and orderly online environment. If you have any questions or need assistance, please contact us（ blog@ianwusb.blog ）.\n   Thank you for your understanding and cooperation.\n\n\n\n在这个信息爆炸的时代，我的博客就像一位不离不弃的挚友，陪我度过了无数难忘的日夜。然而，不幸的是，最近它遭遇了严重的数据丢失，让我痛心不已。\n\n这个网络角落，曾是我倾诉情感、记载生活点滴、交流思想的避风港。每一篇博文都蕴含着我对生活的热情和对知识的渴求。如今，这些珍贵的文字随风消散，似乎从未出现过。那些深夜与博客相伴的时光，它见证了我的成长轨迹，记录了我的欢笑与泪水，我将永远铭记。\n\n在此，我要对我的博客表示深切的哀悼。虽然它已经离我而去，但那些美好的记忆将永远珍藏在我心中。我将重新振作，以新的起点，继续书写我的故事。愿我的博客在虚拟世界的另一端得以安息。旧站（https://old.ianwusb.blog/）将保留作为纪念，新的篇章将从这里开始。\n\n------\n\n探索编程的奥秘，揭秘生命的奇迹——欢迎来到我的博客！\n\n在这个充满无限可能的世界里，编程与生物学交织出独特的魅力。一方是创新的代名词，另一方则是生命奥秘的守护者。在这里，我将带你领略这两大学科的精妙之处，共同探索编程与生物学的奇妙旅程。\n编程，不仅仅是一串代码，它是一种思维方式，一种解决问题的途径。它的魅力在于，让我们能够将想象化为现实，将无形的思想转化为有形的作品。在这片广阔的天地里，我将分享我的编程心得，与你一同感受编程带来的无尽创造力和巨大潜力。\n\n与此同时，生物学以其独特的魅力吸引着我们。生命的奥秘、进化的奇迹，无不让人为之着迷。在这里，我将深入剖析高中生物知识，带你领略生物学的魅力，共同揭开生命之谜。\n\n我的博客，不仅是一个分享编程与生物学知识的平台，更是一个激发思考、碰撞火花的舞台。希望通过我的文字，能够点燃你对编程和生物学的热情，激发你的创新潜能。\n\n此外，这里也欢迎广大爱好写作的朋友投稿。只需将你的作品发送至fastjackcost880@gmail.com，注明“博客提交”，你的智慧与见解就有机会在这里绽放光芒。\n\n让我们一起，踏上探索编程与生物学的征途，书写属于我们的创新篇章！敬请期待，更多精彩内容即将呈现。欢迎订阅、关注，与我一同成长！\n\n------\n\n\n# 声明\n\n尊敬的用户：\n\n欢迎您访问本网站。我们郑重声明，本网站所包含的所有文章内容均为提供学习和交流之用。本网站致力于为用户提供丰富、有价值且合法的信息资源，以促进知识的传播和学术的进步。\n\n根据中华人民共和国网络安全法、著作权法以及其他相关法律的规定，我们提醒所有用户注意以下几点：\n\n1. 本网站上发布的所有文章均受著作权法保护，未经文章作者或本网站的明确授权，任何单位或个人不得以任何形式复制、传播、出版、转载、摘编、翻译或进行其他形式的使用。\n2. 用户在使用本网站提供的文章内容时，应遵守国家法律法规，不得用于任何非法目的或商业性使用。\n3. 本网站严格禁止任何侵犯他人知识产权的行为，包括但不限于未经许可的上传、下载、传播侵权内容。\n4. 若您认为本网站的内容侵犯了您的著作权或其他合法权益，请立即与我们联系，我们将及时处理并采取适当措施。\n5. 本网站保留对违反本声明的用户采取法律行动的权利，包括但不限于警告、删除侵权内容、限制访问、追究法律责任等。\n6. 本网站鼓励用户之间的健康交流与合作，但要求用户在交流过程中尊重他人权利，不发布违法信息和不良内容。\n7. 本网站将不断完善和更新内容，以确保信息的合法性、准确性和时效性。\n\n请您在使用本网站时，自觉遵守上述规定，共同维护一个健康、有序的网络环境。如果您有任何疑问或需要帮助，请联系我们（blog@ianwusb.blog）。\n\n感谢您的理解与合作。\n","slug":"深刻哀悼","published":1,"updated":"2024-09-10T16:13:29.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3er0007c0wcf8xi20gb","content":"<p>In this era of information explosion, my blog is like a loyal friend who has accompanied me through countless unforgettable days and nights. Unfortunately, it has recently suffered severe data loss, which has left me heartbroken.</p>\n<p>This online corner used to be a safe haven for me to express my emotions, record the details of my life, and exchange ideas. Every blog post contains my passion for life and thirst for knowledge. Nowadays, these precious words have dissipated with the wind and seem to have never appeared before. The time spent late at night with my blog witnessed my growth trajectory, recorded my laughter and tears, and I will always remember them.</p>\n<p>Here, I would like to express my deep condolences for my blog. Although it has passed away, those beautiful memories will forever be cherished in my heart. I will pick myself up again and continue writing my story from a new starting point. May my blog rest in peace on the other side of the virtual world. Old Station（ <a href=\"https://old.ianwusb.blog/\">https://old.ianwusb.blog/</a> ）As a commemoration, a new chapter will begin here.</p>\n<p>Exploring the mysteries of programming and uncovering the wonders of life - welcome to my blog!<br>In this world full of infinite possibilities, programming and biology intertwine to create a unique charm. One is synonymous with innovation, while the other is the guardian of the mysteries of life. Here, I will take you to appreciate the subtleties of these two disciplines and explore the wonderful journey of programming and biology together.</p>\n<p>Programming is not just a string of code, it is a way of thinking and a way to solve problems. Its charm lies in its ability to turn imagination into reality and transform intangible ideas into tangible works. In this vast world, I will share my programming insights and experience the endless creativity and enormous potential that programming brings with you.</p>\n<p>At the same time, biology attracts us with its unique charm. The mysteries of life and the miracles of evolution are all fascinating to people. Here, I will delve into high school biology knowledge, take you on a journey to appreciate the charm of biology, and together unravel the mysteries of life.</p>\n<p>My blog is not only a platform for sharing programming and biology knowledge, but also a stage for inspiring thinking and sparking collisions. I hope that through my words, I can ignite your passion for programming and biology, and inspire your innovative potential.</p>\n<p>In addition, we also welcome friends who love writing to submit articles here. Just send your work to <a href=\"mailto:&#x66;&#97;&#x73;&#116;&#x6a;&#x61;&#99;&#107;&#x63;&#111;&#x73;&#116;&#56;&#x38;&#x30;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">&#x66;&#97;&#x73;&#116;&#x6a;&#x61;&#99;&#107;&#x63;&#111;&#x73;&#116;&#56;&#x38;&#x30;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a> Please indicate ‘blog submission’, and your wisdom and insights will have the opportunity to shine here.</p>\n<p>Let’s embark on the journey of exploring programming and biology together, and write our own innovative chapter! Stay tuned, more exciting content is about to be presented. Welcome to subscribe, follow, and grow together with me!</p>\n<h1 id=\"Declaration\"><a href=\"#Declaration\" class=\"headerlink\" title=\"Declaration\"></a>Declaration</h1><p>Dear user:<br>Welcome to visit this website. We solemnly declare that all articles contained on this website are intended for learning and communication purposes. This website is committed to providing users with rich, valuable, and legitimate information resources to promote the dissemination of knowledge and academic progress.<br>According to the provisions of the Cybersecurity Law, Copyright Law, and other relevant laws of the People’s Republic of China, we remind all users to pay attention to the following points:</p>\n<ol>\n<li>All articles published on this website are protected by copyright law. Without the explicit authorization of the article author or this website, no unit or individual may copy, disseminate, publish, reprint, excerpt, translate or use them in any form.</li>\n<li>Users shall comply with national laws and regulations when using the content of articles provided on this website, and shall not use it for any illegal purposes or commercial purposes.</li>\n<li>This website strictly prohibits any behavior that infringes on the intellectual property rights of others, including but not limited to unauthorized uploading, downloading, and dissemination of infringing content.<br>If you believe that the content of this website infringes on your copyright or other legitimate rights and interests, please contact us immediately, and we will handle it promptly and take appropriate measures.</li>\n<li>This website reserves the right to take legal action against users who violate this statement, including but not limited to warning, deleting infringing content, restricting access, and pursuing legal responsibility.</li>\n<li>This website encourages healthy communication and cooperation among users, but requires users to respect the rights of others during the communication process and not publish illegal information and harmful content.</li>\n<li>This website will continuously improve and update its content to ensure the legality, accuracy, and timeliness of information.<br>Please consciously abide by the above regulations when using this website, and jointly maintain a healthy and orderly online environment. If you have any questions or need assistance, please contact us（ <a href=\"mailto:&#x62;&#x6c;&#111;&#103;&#64;&#x69;&#x61;&#x6e;&#119;&#x75;&#115;&#x62;&#46;&#98;&#108;&#x6f;&#x67;\">&#x62;&#x6c;&#111;&#103;&#64;&#x69;&#x61;&#x6e;&#119;&#x75;&#115;&#x62;&#46;&#98;&#108;&#x6f;&#x67;</a> ）.<br>Thank you for your understanding and cooperation.</li>\n</ol>\n<p>在这个信息爆炸的时代，我的博客就像一位不离不弃的挚友，陪我度过了无数难忘的日夜。然而，不幸的是，最近它遭遇了严重的数据丢失，让我痛心不已。</p>\n<p>这个网络角落，曾是我倾诉情感、记载生活点滴、交流思想的避风港。每一篇博文都蕴含着我对生活的热情和对知识的渴求。如今，这些珍贵的文字随风消散，似乎从未出现过。那些深夜与博客相伴的时光，它见证了我的成长轨迹，记录了我的欢笑与泪水，我将永远铭记。</p>\n<p>在此，我要对我的博客表示深切的哀悼。虽然它已经离我而去，但那些美好的记忆将永远珍藏在我心中。我将重新振作，以新的起点，继续书写我的故事。愿我的博客在虚拟世界的另一端得以安息。旧站（<a href=\"https://old.ianwusb.blog/%EF%BC%89%E5%B0%86%E4%BF%9D%E7%95%99%E4%BD%9C%E4%B8%BA%E7%BA%AA%E5%BF%B5%EF%BC%8C%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0%E5%B0%86%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E3%80%82\">https://old.ianwusb.blog/）将保留作为纪念，新的篇章将从这里开始。</a></p>\n<hr>\n<p>探索编程的奥秘，揭秘生命的奇迹——欢迎来到我的博客！</p>\n<p>在这个充满无限可能的世界里，编程与生物学交织出独特的魅力。一方是创新的代名词，另一方则是生命奥秘的守护者。在这里，我将带你领略这两大学科的精妙之处，共同探索编程与生物学的奇妙旅程。<br>编程，不仅仅是一串代码，它是一种思维方式，一种解决问题的途径。它的魅力在于，让我们能够将想象化为现实，将无形的思想转化为有形的作品。在这片广阔的天地里，我将分享我的编程心得，与你一同感受编程带来的无尽创造力和巨大潜力。</p>\n<p>与此同时，生物学以其独特的魅力吸引着我们。生命的奥秘、进化的奇迹，无不让人为之着迷。在这里，我将深入剖析高中生物知识，带你领略生物学的魅力，共同揭开生命之谜。</p>\n<p>我的博客，不仅是一个分享编程与生物学知识的平台，更是一个激发思考、碰撞火花的舞台。希望通过我的文字，能够点燃你对编程和生物学的热情，激发你的创新潜能。</p>\n<p>此外，这里也欢迎广大爱好写作的朋友投稿。只需将你的作品发送至<a href=\"mailto:&#102;&#97;&#115;&#x74;&#x6a;&#97;&#99;&#107;&#x63;&#111;&#x73;&#x74;&#x38;&#56;&#48;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;\">&#102;&#97;&#115;&#x74;&#x6a;&#97;&#99;&#107;&#x63;&#111;&#x73;&#x74;&#x38;&#56;&#48;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;</a>，注明“博客提交”，你的智慧与见解就有机会在这里绽放光芒。</p>\n<p>让我们一起，踏上探索编程与生物学的征途，书写属于我们的创新篇章！敬请期待，更多精彩内容即将呈现。欢迎订阅、关注，与我一同成长！</p>\n<hr>\n<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><p>尊敬的用户：</p>\n<p>欢迎您访问本网站。我们郑重声明，本网站所包含的所有文章内容均为提供学习和交流之用。本网站致力于为用户提供丰富、有价值且合法的信息资源，以促进知识的传播和学术的进步。</p>\n<p>根据中华人民共和国网络安全法、著作权法以及其他相关法律的规定，我们提醒所有用户注意以下几点：</p>\n<ol>\n<li>本网站上发布的所有文章均受著作权法保护，未经文章作者或本网站的明确授权，任何单位或个人不得以任何形式复制、传播、出版、转载、摘编、翻译或进行其他形式的使用。</li>\n<li>用户在使用本网站提供的文章内容时，应遵守国家法律法规，不得用于任何非法目的或商业性使用。</li>\n<li>本网站严格禁止任何侵犯他人知识产权的行为，包括但不限于未经许可的上传、下载、传播侵权内容。</li>\n<li>若您认为本网站的内容侵犯了您的著作权或其他合法权益，请立即与我们联系，我们将及时处理并采取适当措施。</li>\n<li>本网站保留对违反本声明的用户采取法律行动的权利，包括但不限于警告、删除侵权内容、限制访问、追究法律责任等。</li>\n<li>本网站鼓励用户之间的健康交流与合作，但要求用户在交流过程中尊重他人权利，不发布违法信息和不良内容。</li>\n<li>本网站将不断完善和更新内容，以确保信息的合法性、准确性和时效性。</li>\n</ol>\n<p>请您在使用本网站时，自觉遵守上述规定，共同维护一个健康、有序的网络环境。如果您有任何疑问或需要帮助，请联系我们（<a href=\"mailto:&#98;&#x6c;&#111;&#103;&#64;&#105;&#97;&#110;&#x77;&#117;&#115;&#x62;&#x2e;&#98;&#x6c;&#111;&#x67;\">&#98;&#x6c;&#111;&#103;&#64;&#105;&#97;&#110;&#x77;&#117;&#115;&#x62;&#x2e;&#98;&#x6c;&#111;&#x67;</a>）。</p>\n<p>感谢您的理解与合作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>In this era of information explosion, my blog is like a loyal friend who has accompanied me through countless unforgettable days and nights. Unfortunately, it has recently suffered severe data loss, which has left me heartbroken.</p>\n<p>This online corner used to be a safe haven for me to express my emotions, record the details of my life, and exchange ideas. Every blog post contains my passion for life and thirst for knowledge. Nowadays, these precious words have dissipated with the wind and seem to have never appeared before. The time spent late at night with my blog witnessed my growth trajectory, recorded my laughter and tears, and I will always remember them.</p>\n<p>Here, I would like to express my deep condolences for my blog. Although it has passed away, those beautiful memories will forever be cherished in my heart. I will pick myself up again and continue writing my story from a new starting point. May my blog rest in peace on the other side of the virtual world. Old Station（ <a href=\"https://old.ianwusb.blog/\">https://old.ianwusb.blog/</a> ）As a commemoration, a new chapter will begin here.</p>\n<p>Exploring the mysteries of programming and uncovering the wonders of life - welcome to my blog!<br>In this world full of infinite possibilities, programming and biology intertwine to create a unique charm. One is synonymous with innovation, while the other is the guardian of the mysteries of life. Here, I will take you to appreciate the subtleties of these two disciplines and explore the wonderful journey of programming and biology together.</p>\n<p>Programming is not just a string of code, it is a way of thinking and a way to solve problems. Its charm lies in its ability to turn imagination into reality and transform intangible ideas into tangible works. In this vast world, I will share my programming insights and experience the endless creativity and enormous potential that programming brings with you.</p>\n<p>At the same time, biology attracts us with its unique charm. The mysteries of life and the miracles of evolution are all fascinating to people. Here, I will delve into high school biology knowledge, take you on a journey to appreciate the charm of biology, and together unravel the mysteries of life.</p>\n<p>My blog is not only a platform for sharing programming and biology knowledge, but also a stage for inspiring thinking and sparking collisions. I hope that through my words, I can ignite your passion for programming and biology, and inspire your innovative potential.</p>\n<p>In addition, we also welcome friends who love writing to submit articles here. Just send your work to <a href=\"mailto:&#x66;&#97;&#x73;&#116;&#x6a;&#x61;&#99;&#107;&#x63;&#111;&#x73;&#116;&#56;&#x38;&#x30;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">&#x66;&#97;&#x73;&#116;&#x6a;&#x61;&#99;&#107;&#x63;&#111;&#x73;&#116;&#56;&#x38;&#x30;&#64;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a> Please indicate ‘blog submission’, and your wisdom and insights will have the opportunity to shine here.</p>\n<p>Let’s embark on the journey of exploring programming and biology together, and write our own innovative chapter! Stay tuned, more exciting content is about to be presented. Welcome to subscribe, follow, and grow together with me!</p>\n<h1 id=\"Declaration\"><a href=\"#Declaration\" class=\"headerlink\" title=\"Declaration\"></a>Declaration</h1><p>Dear user:<br>Welcome to visit this website. We solemnly declare that all articles contained on this website are intended for learning and communication purposes. This website is committed to providing users with rich, valuable, and legitimate information resources to promote the dissemination of knowledge and academic progress.<br>According to the provisions of the Cybersecurity Law, Copyright Law, and other relevant laws of the People’s Republic of China, we remind all users to pay attention to the following points:</p>\n<ol>\n<li>All articles published on this website are protected by copyright law. Without the explicit authorization of the article author or this website, no unit or individual may copy, disseminate, publish, reprint, excerpt, translate or use them in any form.</li>\n<li>Users shall comply with national laws and regulations when using the content of articles provided on this website, and shall not use it for any illegal purposes or commercial purposes.</li>\n<li>This website strictly prohibits any behavior that infringes on the intellectual property rights of others, including but not limited to unauthorized uploading, downloading, and dissemination of infringing content.<br>If you believe that the content of this website infringes on your copyright or other legitimate rights and interests, please contact us immediately, and we will handle it promptly and take appropriate measures.</li>\n<li>This website reserves the right to take legal action against users who violate this statement, including but not limited to warning, deleting infringing content, restricting access, and pursuing legal responsibility.</li>\n<li>This website encourages healthy communication and cooperation among users, but requires users to respect the rights of others during the communication process and not publish illegal information and harmful content.</li>\n<li>This website will continuously improve and update its content to ensure the legality, accuracy, and timeliness of information.<br>Please consciously abide by the above regulations when using this website, and jointly maintain a healthy and orderly online environment. If you have any questions or need assistance, please contact us（ <a href=\"mailto:&#x62;&#x6c;&#111;&#103;&#64;&#x69;&#x61;&#x6e;&#119;&#x75;&#115;&#x62;&#46;&#98;&#108;&#x6f;&#x67;\">&#x62;&#x6c;&#111;&#103;&#64;&#x69;&#x61;&#x6e;&#119;&#x75;&#115;&#x62;&#46;&#98;&#108;&#x6f;&#x67;</a> ）.<br>Thank you for your understanding and cooperation.</li>\n</ol>\n<p>在这个信息爆炸的时代，我的博客就像一位不离不弃的挚友，陪我度过了无数难忘的日夜。然而，不幸的是，最近它遭遇了严重的数据丢失，让我痛心不已。</p>\n<p>这个网络角落，曾是我倾诉情感、记载生活点滴、交流思想的避风港。每一篇博文都蕴含着我对生活的热情和对知识的渴求。如今，这些珍贵的文字随风消散，似乎从未出现过。那些深夜与博客相伴的时光，它见证了我的成长轨迹，记录了我的欢笑与泪水，我将永远铭记。</p>\n<p>在此，我要对我的博客表示深切的哀悼。虽然它已经离我而去，但那些美好的记忆将永远珍藏在我心中。我将重新振作，以新的起点，继续书写我的故事。愿我的博客在虚拟世界的另一端得以安息。旧站（<a href=\"https://old.ianwusb.blog/%EF%BC%89%E5%B0%86%E4%BF%9D%E7%95%99%E4%BD%9C%E4%B8%BA%E7%BA%AA%E5%BF%B5%EF%BC%8C%E6%96%B0%E7%9A%84%E7%AF%87%E7%AB%A0%E5%B0%86%E4%BB%8E%E8%BF%99%E9%87%8C%E5%BC%80%E5%A7%8B%E3%80%82\">https://old.ianwusb.blog/）将保留作为纪念，新的篇章将从这里开始。</a></p>\n<hr>\n<p>探索编程的奥秘，揭秘生命的奇迹——欢迎来到我的博客！</p>\n<p>在这个充满无限可能的世界里，编程与生物学交织出独特的魅力。一方是创新的代名词，另一方则是生命奥秘的守护者。在这里，我将带你领略这两大学科的精妙之处，共同探索编程与生物学的奇妙旅程。<br>编程，不仅仅是一串代码，它是一种思维方式，一种解决问题的途径。它的魅力在于，让我们能够将想象化为现实，将无形的思想转化为有形的作品。在这片广阔的天地里，我将分享我的编程心得，与你一同感受编程带来的无尽创造力和巨大潜力。</p>\n<p>与此同时，生物学以其独特的魅力吸引着我们。生命的奥秘、进化的奇迹，无不让人为之着迷。在这里，我将深入剖析高中生物知识，带你领略生物学的魅力，共同揭开生命之谜。</p>\n<p>我的博客，不仅是一个分享编程与生物学知识的平台，更是一个激发思考、碰撞火花的舞台。希望通过我的文字，能够点燃你对编程和生物学的热情，激发你的创新潜能。</p>\n<p>此外，这里也欢迎广大爱好写作的朋友投稿。只需将你的作品发送至<a href=\"mailto:&#102;&#97;&#115;&#x74;&#x6a;&#97;&#99;&#107;&#x63;&#111;&#x73;&#x74;&#x38;&#56;&#48;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;\">&#102;&#97;&#115;&#x74;&#x6a;&#97;&#99;&#107;&#x63;&#111;&#x73;&#x74;&#x38;&#56;&#48;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;</a>，注明“博客提交”，你的智慧与见解就有机会在这里绽放光芒。</p>\n<p>让我们一起，踏上探索编程与生物学的征途，书写属于我们的创新篇章！敬请期待，更多精彩内容即将呈现。欢迎订阅、关注，与我一同成长！</p>\n<hr>\n<h1 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h1><p>尊敬的用户：</p>\n<p>欢迎您访问本网站。我们郑重声明，本网站所包含的所有文章内容均为提供学习和交流之用。本网站致力于为用户提供丰富、有价值且合法的信息资源，以促进知识的传播和学术的进步。</p>\n<p>根据中华人民共和国网络安全法、著作权法以及其他相关法律的规定，我们提醒所有用户注意以下几点：</p>\n<ol>\n<li>本网站上发布的所有文章均受著作权法保护，未经文章作者或本网站的明确授权，任何单位或个人不得以任何形式复制、传播、出版、转载、摘编、翻译或进行其他形式的使用。</li>\n<li>用户在使用本网站提供的文章内容时，应遵守国家法律法规，不得用于任何非法目的或商业性使用。</li>\n<li>本网站严格禁止任何侵犯他人知识产权的行为，包括但不限于未经许可的上传、下载、传播侵权内容。</li>\n<li>若您认为本网站的内容侵犯了您的著作权或其他合法权益，请立即与我们联系，我们将及时处理并采取适当措施。</li>\n<li>本网站保留对违反本声明的用户采取法律行动的权利，包括但不限于警告、删除侵权内容、限制访问、追究法律责任等。</li>\n<li>本网站鼓励用户之间的健康交流与合作，但要求用户在交流过程中尊重他人权利，不发布违法信息和不良内容。</li>\n<li>本网站将不断完善和更新内容，以确保信息的合法性、准确性和时效性。</li>\n</ol>\n<p>请您在使用本网站时，自觉遵守上述规定，共同维护一个健康、有序的网络环境。如果您有任何疑问或需要帮助，请联系我们（<a href=\"mailto:&#98;&#x6c;&#111;&#103;&#64;&#105;&#97;&#110;&#x77;&#117;&#115;&#x62;&#x2e;&#98;&#x6c;&#111;&#x67;\">&#98;&#x6c;&#111;&#103;&#64;&#105;&#97;&#110;&#x77;&#117;&#115;&#x62;&#x2e;&#98;&#x6c;&#111;&#x67;</a>）。</p>\n<p>感谢您的理解与合作。</p>\n"},{"title":"题解|算法竞赛团队培训第一次考核","date":"2024-10-27T11:57:37.000Z","_content":"\n\n\n[TOC]\n\n## A.[小红的签到题](https://ac.nowcoder.com/acm/contest/94289/A)\n\n### 解析\n\n题目描述了一个情景，其中 \\( a \\) 是题目的总数，\\( b \\) 是参赛人数，而 \\( c \\) 是所有人通过题目的总数。要找出最多有多少人“ak”，即通过了所有题目。\n\n在这种情况下，如果每个人至少通过了一道题，那么最多可以通过 \\( a * b \\) 道题。但题目只告诉我们总共通过了 \\( c \\) 道题。所以，要找出最多有多少人通过了所有题目，我们可以将 \\( c \\) 除以 \\( a \\)，因为每个人要“ak”就需要通过 \\( a \\) 道题。\n\n为什么不需要计算余数呢？因为题目问的是最多有多少人“ak”，这意味着我们是在寻找一个整数解，即最多有多少完整地通过了所有题目的人。如果 \\( c \\) 不能被 \\( a \\) 整除，那么就意味着不可能有更多的人完全通过所有题目，因为余数代表的是不足以构成一个完整“ak”的人数。\n\n例如，如果 \\( c = 123 \\) 且 \\( a = 6 \\)，那么 \\( 123 / 6 = 20 \\) 余 3。这表示最多有 20 个人可以完全通过所有题目，因为剩下的 3 道题不足以让更多的人完成“ak”。\n\n因此，直接用 \\( c \\) 除以 \\( a \\) 得到的整数部分就是答案。\n\n## Code\n\n```c++\n#include<iostream>\nusing namespace std;\nint main(){\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tcout<<c/a<<endl;\n\treturn 0;\n}\n```\n\n\n\n```python\na,b,c=map(int,input().split())\nprint(int(c/a))\n```\n\n\n\n## B.[判断闰年](https://ac.nowcoder.com/acm/contest/94289/B)\n\n### 解析\n\n公历闰年的简单计算方法（符合以下条件之一的年份即为闰年）：\n\n1.能被4整除而不能被100整除\n\n2.能被400整除\n\n### Code\n\n```c++\n#include<iostream>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tif((n%4==0 && n%100!=0) || (n%400==0)){\n\t\tcout<<\"yes\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n```python\nn=int(input())\nif(((n%4==0) and (n%100!=0)) or (n%400==0)):\n    print(\"yes\")\nelse:\n    print(\"no\")\n```\n\n## C.[[NOIP2010\\]数字统计](https://ac.nowcoder.com/acm/contest/94289/C)\n\n## 解析\n\n见代码\n\n### Code\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint L, R;\n\tcin >> L >> R;\n\tint countTwos = 0;  // 重命名变量以避免冲突\n\t\n\tfor (int i = L; i <= R; ++i) {\n\t\tstring num_str = to_string(i);\n\t\tcountTwos += count(num_str.begin(), num_str.end(), '2');  \n\t}\n\t\n\tcout << countTwos << endl;\n\treturn 0;\n}\n\n```\n\n\n\n```python\nL,R=map(int,input().split())\ncount=0\nfor i in range(L,R+1):\n    count+=str(i).count(\"2\")\nprint(count)\n```\n\n## D.[ [NOIP2017\\]图书管理员](https://ac.nowcoder.com/acm/contest/94289/D)\n\n### 解析\n\n见代码\n\n### Code\n\n```C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint find(const vector<int>& library, const pair<int, string>& tupleX) {\n    for (int i : library) {\n        string num_str = to_string(i);\n        if (num_str.length() >= tupleX.second.length()) {\n            string suffix = num_str.substr(num_str.length() - tupleX.first);\n            if (suffix == tupleX.second) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<int> library(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> library[i];\n    }\n    \n    vector<pair<int, string>> needed(q);\n    for (int i = 0; i < q; ++i) {\n        int x;\n        string s;\n        cin >> x >> s;\n        needed[i] = make_pair(x, s);\n    }\n    \n    sort(library.begin(), library.end());\n    \n    for (const auto& i : needed) {\n        cout << find(library, i) << endl;\n    }\n    \n    return 0;\n}\n\n```\n\n\n\n```python\nn,q=map(int,input().split())\nlibrary=[int(input()) for _ in range(n)]\n#和下面代码是一个意思:\n# for _ in range(n):\n#     library.append(int(input()))\nneeded=[tuple(map(int,input().split())) for _ in range(q)]\n#和下面代码是一个意思:\n# for _ in range(q):\n#     needed.append(tuple(map(int,input().split())))\n#test:\n# print(library)\n# print(needed)\nlibrary.sort()\ndef find(tupleX):\n    for i in library:\n        a=-tupleX[0]\n        if str(i)[a:]==str(tupleX[1]):\n            return i\n    return -1\nfor i in needed:\n    print(find(i))\n\n```\n\n## E.[最大公约数(lcm)](https://ac.nowcoder.com/acm/contest/94289/E)\n\n### 解析\n\n辗转相除法求最大公因数：\n\n```c++\n#include <iostream>\nusing namespace std;\nint gcd(int a, int b)\n{\n    if (a % b==0) return b;\n    else return gcd(b, a % b);\n}\nint x, y; \nint main(){\n\t\n\tcin >> x >> y;\n\tcout << gcd(x, y);\n\t\n\treturn 0;\n}\n```\n\n```python\ndef gcd(m,n):\n    while m%n != 0:\n        oldm = m\n        oldn = n\n\n        m = oldn\n        n = oldm%oldn\n    return n\n```\n\n**最小公倍数（LCM）等于两个数的乘积除以它们的最大公因数（GCD）**\n\n### Code\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tunsigned long long a,b;\n    cin>>a>>b;\n    cout<<lcm(a,b);\n    return 0;\n}\n```\n\n\n\n```python\nimport math\na,b=map(int,input().split())\nprint(math.lcm(a,b))\n```\n\n## F.[ 简单的整除](https://ac.nowcoder.com/acm/contest/94289/F)\n\n### 解析\n\n见代码\n\n### Code\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n\tint x;\n\tcin >> x;\n\tvector<int> li = {2, 3, 5, 7};\n\t\n\tfor (int i : li) {\n\t\tif (x % i == 0) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (x % 2 != 0 && x % 3 != 0 && x % 5 != 0 && x % 7 != 0) {\n\t\tcout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\n```\n\n\n\n```python\nx=int(input())\nli=[2,3,5,7]\nfor i in li:\n    if x%i==0:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")\n```\n\n## I.[悬崖](https://ac.nowcoder.com/acm/contest/94289/I)\n\n### 题目\n\n小沙被困在两个巨大的墙壁之中快要被压死了，但是两个墙壁中间就是万丈悬崖，小沙想要多活一会，他脚底下有一个非常强大的弹跳鞋，每一次跳跃可以使他向着对面的墙壁飞行x米，但是他必须要踩上墙壁才能进行下一次跳跃，现已知两个墙壁中间间隔n米，并且每次跳跃两个墙壁之间的距离会减少1米，也就是说小沙在n秒后就会被压死，如果不考虑跳跃期间墙壁的移动，请问小沙最多能跳(飞)多少米。\n\n**两面墙壁都没有什么物品可以让小沙能够抓住从而挂在墙壁上，所以小沙要保证一直的跳跃才能不摔下悬崖**\n\n说明：小沙第一次跳跃两米，到对面墙壁，然后两个墙壁的距离变成1米，小沙继续跳到对面墙壁（此时虽然两个墙壁之间只有1米，但是小沙还是可以跳跃两米）例如：\n\n![img](https://uploadfiles.nowcoder.com/images/20220303/371724_1646315836289/9976BCCD254C760651A666CBC1845546)\n\n可以看到虽然墙壁之间的距离只有一米，但是小沙还是可以跳两米远\n\n### Code\n\n#### [牛客513205243号](https://ac.nowcoder.com/acm/contest/profile/513205243) 提交的代码\n\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n\tlong long x, n;\n\tcin >> x >> n;\n\tif(x>=n)\n\t\tcout << n * x;\n\telse \n\t\tcout << x ;\n\treturn 0;\n}\n```\n\n#### [砍个价沈](https://ac.nowcoder.com/acm/contest/profile/602481815) 提交的代码\n\n```python\nx,n=map(int,input().split())\nif x>=n:\n    print(int(x*n))\nelse:\n    print(int(x))\n```\n\n### J.[ 猜拳游戏](https://ac.nowcoder.com/acm/contest/94289/J)\n\n### 题目\n\n你正在与*长途*玩石头剪刀布的猜拳游戏。\n\n请回忆石头剪刀布的游戏规则：两个人同时伸出手，分别出示石头（用 shitou 表示）、剪刀（用 jiandao 表示）或布（用 bu 表示）的手势。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出示的手势相同，则是平局，需要重新进行游戏。\n\n在开始游戏之前，*长途*会告诉你他要出石头、剪刀还是布。\n\n然而实际上，*长途*是在欺骗你。他认为你会相信他的话，并且认为你一定会根据他说的话选择能战胜他的手势（例如，他说他会出石头，他便认为你会出布）。\n\n所以最终，*长途*不会按照他告诉你的手势出拳，而是选择自己所认为一定能战胜你的手势。\n\n现在你已经看透了他的小心思。请问，在知道他告诉你他要出什么手势的情况下，你应该出什么手势才能取胜？\n\n### Code\n\n#### [牛客513205243号](https://ac.nowcoder.com/acm/contest/profile/513205243) 提交的代码\n\n```c++\n#include<stdio.h>\nint main(){\n\tchar n[100];\n\tscanf(\"%s\",&n);\n\tprintf(\"%s\",n);\n\treturn 0;\n}\n```\n\n#### [砍个价沈](https://ac.nowcoder.com/acm/contest/profile/602481815) 提交的代码\n\n```python\ni=str(input())\nif i==\"shitou\":\n    print(\"shitou\")\nelif i==\"jiandao\":\n    print(\"jiandao\")\nelse:\n    print(\"bu\")\n```\n\n\n\n```python\nprint(input())\n```\n\n## G.[小苯的石子游戏](https://ac.nowcoder.com/acm/contest/94289/G)\n\n### 解析\n\n\n\n#### 博弈的定义：\n\n博弈的基本要素包括参与人（players）、行动（actions）、信息（information）、策略（strategies）、收益（payoffs）和均衡（equilibria）。\n\n#### 标准表达式（normal form）：\n\n设在有 \\( $n$ \\) 个参与者的博弈中，令 \\( $S_i$ \\) 表示参与者 \\( $i$ \\) 可选择的战略集合（战略空间），其中任意一个特定的战略用 \\( $s_i^*$ \\) 表示（$s_i^* \\in S_i $）。当每个参与者都选定一个策略后，形成了博弈的一个战略组合 \\( (s_1, s_2, \\ldots, s_n) \\)。令 \\( $u_i$ \\) 表示第 \\( $i$ \\) 个参与者选择对应策略后的收益函数。由此可定义博弈的标准表达式：\\( $G = \\{S_1, \\ldots, S_n, u_1, \\ldots, u_n\\}$ \\)。\n\n#### 收益矩阵：\n\n两人博弈的标准表达式通常可以使用收益矩阵来表示。例如，经典的囚徒困境问题。两个犯罪嫌疑人被逮捕并被分别隔离审问，他们不同的行动将带来不同的后果。如果两人都不坦白（沉默），将被判入狱1个月；如果双方都坦白（招认），两人都将判处6个月；如果一人招认而另一人拒不坦白，则招认一方将马上释放，而不坦白的另一人将判处9个月。两人博弈的收益矩阵可表示为如下形式，其中每一单元格有两个数字，分别表示囚徒1和囚徒2的收益：\n![囚徒困境](https://i-blog.csdnimg.cn/blog_migrate/9187d558af8a7ee6b9cb70a47de3f076.png#pic_center)\n\n#### 策略：\n\n参与人关于其行动的完备集合，即考虑每一种可预见情况下选择的行动，即使那种情况出现不一定会出现。例如，如果参与人在1989年自杀，他的策略里也应当包括如果他在1990年还活着应该采取的对应行动。\n策略和行动是有区别的，而在一些简单的博弈中，两者的表现可能是一致的，如上述的囚徒困境中博弈双方的策略和行动可选集都是 \\($\\{沉默, 招认\\}$\\)。\n\n#### 均衡：\n\n由博弈中的 \\( n \\) 个参与人选取的最佳策略所组成的一个策略组合 \\( $s^* = (s_1^*, \\ldots, s_n^*)$ \\)。\n\n#### 巴什博弈（Bash Game）：\n\n有$n$ 个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 $m$ 个（$m < n$ ）。最后取光者得胜。\n分析：\n显然，如果 \\( $n = m + 1$ \\)，那么由于一次最多只能取 \\( $m$ \\) 个物品，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，故后者必然取胜。根据这样的规律，我们发现了如何取胜的法则。\n如果 \\( $n = (m + 1)r + s$ \\) r 为任意自然数，\\( $0 \\leq s \\leq m$ \\)，那么先取者首先拿走 \\( $s$ \\) 个物品，接下来若后取者拿走 \\( $k$ \\)（\\( $1 \\leq k \\leq m$ \\)）个，那么先取者再拿走 \\( $m + 1 - k$ \\) 个，结果剩下 \\( $(m + 1) \\times (r - 1)$ \\) 个，以后都保持这样的取法，那么后取者最终会面临 \\( $m + 1$ \\) 的局面，而先取者则必然获胜。总之，要保持给对手留下 \\( $m + 1$ \\) 的倍数，最后就一定能获胜。\n\n### Code\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t} \n\t// sort(a.begin() + 1, a.end()); // 题目已经保证a有序，可以不写这句\n\tint s1 = 0, s2 = 0;\n\tint f = 0;\n\tfor(int i = n; i; i--) {\n\t\tif(!f) s1 += a[i];\n\t\telse s2 += a[i];\n\t\tf ^= 1;\n\t}\n\tif(s1 > s2) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n}\n```\n\n\n\n```python\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    #player=[\"Alice\",\"Bob\"]\n    player=[0,0]\n    count=0\n    while a!=[]:\n        player[count%2]+=a.pop(-1)\n        count+=1\n    if player[0]>player[1]:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n```\n","source":"_posts/题解-算法竞赛团队培训第一次考核.md","raw":"---\ntitle: 题解|算法竞赛团队培训第一次考核\ndate: 2024-10-27 19:57:37\ntags:\n---\n\n\n\n[TOC]\n\n## A.[小红的签到题](https://ac.nowcoder.com/acm/contest/94289/A)\n\n### 解析\n\n题目描述了一个情景，其中 \\( a \\) 是题目的总数，\\( b \\) 是参赛人数，而 \\( c \\) 是所有人通过题目的总数。要找出最多有多少人“ak”，即通过了所有题目。\n\n在这种情况下，如果每个人至少通过了一道题，那么最多可以通过 \\( a * b \\) 道题。但题目只告诉我们总共通过了 \\( c \\) 道题。所以，要找出最多有多少人通过了所有题目，我们可以将 \\( c \\) 除以 \\( a \\)，因为每个人要“ak”就需要通过 \\( a \\) 道题。\n\n为什么不需要计算余数呢？因为题目问的是最多有多少人“ak”，这意味着我们是在寻找一个整数解，即最多有多少完整地通过了所有题目的人。如果 \\( c \\) 不能被 \\( a \\) 整除，那么就意味着不可能有更多的人完全通过所有题目，因为余数代表的是不足以构成一个完整“ak”的人数。\n\n例如，如果 \\( c = 123 \\) 且 \\( a = 6 \\)，那么 \\( 123 / 6 = 20 \\) 余 3。这表示最多有 20 个人可以完全通过所有题目，因为剩下的 3 道题不足以让更多的人完成“ak”。\n\n因此，直接用 \\( c \\) 除以 \\( a \\) 得到的整数部分就是答案。\n\n## Code\n\n```c++\n#include<iostream>\nusing namespace std;\nint main(){\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tcout<<c/a<<endl;\n\treturn 0;\n}\n```\n\n\n\n```python\na,b,c=map(int,input().split())\nprint(int(c/a))\n```\n\n\n\n## B.[判断闰年](https://ac.nowcoder.com/acm/contest/94289/B)\n\n### 解析\n\n公历闰年的简单计算方法（符合以下条件之一的年份即为闰年）：\n\n1.能被4整除而不能被100整除\n\n2.能被400整除\n\n### Code\n\n```c++\n#include<iostream>\nusing namespace std;\nint main(){\n\tint n;\n\tcin>>n;\n\tif((n%4==0 && n%100!=0) || (n%400==0)){\n\t\tcout<<\"yes\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}\n```\n\n\n\n```python\nn=int(input())\nif(((n%4==0) and (n%100!=0)) or (n%400==0)):\n    print(\"yes\")\nelse:\n    print(\"no\")\n```\n\n## C.[[NOIP2010\\]数字统计](https://ac.nowcoder.com/acm/contest/94289/C)\n\n## 解析\n\n见代码\n\n### Code\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint L, R;\n\tcin >> L >> R;\n\tint countTwos = 0;  // 重命名变量以避免冲突\n\t\n\tfor (int i = L; i <= R; ++i) {\n\t\tstring num_str = to_string(i);\n\t\tcountTwos += count(num_str.begin(), num_str.end(), '2');  \n\t}\n\t\n\tcout << countTwos << endl;\n\treturn 0;\n}\n\n```\n\n\n\n```python\nL,R=map(int,input().split())\ncount=0\nfor i in range(L,R+1):\n    count+=str(i).count(\"2\")\nprint(count)\n```\n\n## D.[ [NOIP2017\\]图书管理员](https://ac.nowcoder.com/acm/contest/94289/D)\n\n### 解析\n\n见代码\n\n### Code\n\n```C++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint find(const vector<int>& library, const pair<int, string>& tupleX) {\n    for (int i : library) {\n        string num_str = to_string(i);\n        if (num_str.length() >= tupleX.second.length()) {\n            string suffix = num_str.substr(num_str.length() - tupleX.first);\n            if (suffix == tupleX.second) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    vector<int> library(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> library[i];\n    }\n    \n    vector<pair<int, string>> needed(q);\n    for (int i = 0; i < q; ++i) {\n        int x;\n        string s;\n        cin >> x >> s;\n        needed[i] = make_pair(x, s);\n    }\n    \n    sort(library.begin(), library.end());\n    \n    for (const auto& i : needed) {\n        cout << find(library, i) << endl;\n    }\n    \n    return 0;\n}\n\n```\n\n\n\n```python\nn,q=map(int,input().split())\nlibrary=[int(input()) for _ in range(n)]\n#和下面代码是一个意思:\n# for _ in range(n):\n#     library.append(int(input()))\nneeded=[tuple(map(int,input().split())) for _ in range(q)]\n#和下面代码是一个意思:\n# for _ in range(q):\n#     needed.append(tuple(map(int,input().split())))\n#test:\n# print(library)\n# print(needed)\nlibrary.sort()\ndef find(tupleX):\n    for i in library:\n        a=-tupleX[0]\n        if str(i)[a:]==str(tupleX[1]):\n            return i\n    return -1\nfor i in needed:\n    print(find(i))\n\n```\n\n## E.[最大公约数(lcm)](https://ac.nowcoder.com/acm/contest/94289/E)\n\n### 解析\n\n辗转相除法求最大公因数：\n\n```c++\n#include <iostream>\nusing namespace std;\nint gcd(int a, int b)\n{\n    if (a % b==0) return b;\n    else return gcd(b, a % b);\n}\nint x, y; \nint main(){\n\t\n\tcin >> x >> y;\n\tcout << gcd(x, y);\n\t\n\treturn 0;\n}\n```\n\n```python\ndef gcd(m,n):\n    while m%n != 0:\n        oldm = m\n        oldn = n\n\n        m = oldn\n        n = oldm%oldn\n    return n\n```\n\n**最小公倍数（LCM）等于两个数的乘积除以它们的最大公因数（GCD）**\n\n### Code\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tunsigned long long a,b;\n    cin>>a>>b;\n    cout<<lcm(a,b);\n    return 0;\n}\n```\n\n\n\n```python\nimport math\na,b=map(int,input().split())\nprint(math.lcm(a,b))\n```\n\n## F.[ 简单的整除](https://ac.nowcoder.com/acm/contest/94289/F)\n\n### 解析\n\n见代码\n\n### Code\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n\tint x;\n\tcin >> x;\n\tvector<int> li = {2, 3, 5, 7};\n\t\n\tfor (int i : li) {\n\t\tif (x % i == 0) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (x % 2 != 0 && x % 3 != 0 && x % 5 != 0 && x % 7 != 0) {\n\t\tcout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}\n\n```\n\n\n\n```python\nx=int(input())\nli=[2,3,5,7]\nfor i in li:\n    if x%i==0:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")\n```\n\n## I.[悬崖](https://ac.nowcoder.com/acm/contest/94289/I)\n\n### 题目\n\n小沙被困在两个巨大的墙壁之中快要被压死了，但是两个墙壁中间就是万丈悬崖，小沙想要多活一会，他脚底下有一个非常强大的弹跳鞋，每一次跳跃可以使他向着对面的墙壁飞行x米，但是他必须要踩上墙壁才能进行下一次跳跃，现已知两个墙壁中间间隔n米，并且每次跳跃两个墙壁之间的距离会减少1米，也就是说小沙在n秒后就会被压死，如果不考虑跳跃期间墙壁的移动，请问小沙最多能跳(飞)多少米。\n\n**两面墙壁都没有什么物品可以让小沙能够抓住从而挂在墙壁上，所以小沙要保证一直的跳跃才能不摔下悬崖**\n\n说明：小沙第一次跳跃两米，到对面墙壁，然后两个墙壁的距离变成1米，小沙继续跳到对面墙壁（此时虽然两个墙壁之间只有1米，但是小沙还是可以跳跃两米）例如：\n\n![img](https://uploadfiles.nowcoder.com/images/20220303/371724_1646315836289/9976BCCD254C760651A666CBC1845546)\n\n可以看到虽然墙壁之间的距离只有一米，但是小沙还是可以跳两米远\n\n### Code\n\n#### [牛客513205243号](https://ac.nowcoder.com/acm/contest/profile/513205243) 提交的代码\n\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n\tlong long x, n;\n\tcin >> x >> n;\n\tif(x>=n)\n\t\tcout << n * x;\n\telse \n\t\tcout << x ;\n\treturn 0;\n}\n```\n\n#### [砍个价沈](https://ac.nowcoder.com/acm/contest/profile/602481815) 提交的代码\n\n```python\nx,n=map(int,input().split())\nif x>=n:\n    print(int(x*n))\nelse:\n    print(int(x))\n```\n\n### J.[ 猜拳游戏](https://ac.nowcoder.com/acm/contest/94289/J)\n\n### 题目\n\n你正在与*长途*玩石头剪刀布的猜拳游戏。\n\n请回忆石头剪刀布的游戏规则：两个人同时伸出手，分别出示石头（用 shitou 表示）、剪刀（用 jiandao 表示）或布（用 bu 表示）的手势。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出示的手势相同，则是平局，需要重新进行游戏。\n\n在开始游戏之前，*长途*会告诉你他要出石头、剪刀还是布。\n\n然而实际上，*长途*是在欺骗你。他认为你会相信他的话，并且认为你一定会根据他说的话选择能战胜他的手势（例如，他说他会出石头，他便认为你会出布）。\n\n所以最终，*长途*不会按照他告诉你的手势出拳，而是选择自己所认为一定能战胜你的手势。\n\n现在你已经看透了他的小心思。请问，在知道他告诉你他要出什么手势的情况下，你应该出什么手势才能取胜？\n\n### Code\n\n#### [牛客513205243号](https://ac.nowcoder.com/acm/contest/profile/513205243) 提交的代码\n\n```c++\n#include<stdio.h>\nint main(){\n\tchar n[100];\n\tscanf(\"%s\",&n);\n\tprintf(\"%s\",n);\n\treturn 0;\n}\n```\n\n#### [砍个价沈](https://ac.nowcoder.com/acm/contest/profile/602481815) 提交的代码\n\n```python\ni=str(input())\nif i==\"shitou\":\n    print(\"shitou\")\nelif i==\"jiandao\":\n    print(\"jiandao\")\nelse:\n    print(\"bu\")\n```\n\n\n\n```python\nprint(input())\n```\n\n## G.[小苯的石子游戏](https://ac.nowcoder.com/acm/contest/94289/G)\n\n### 解析\n\n\n\n#### 博弈的定义：\n\n博弈的基本要素包括参与人（players）、行动（actions）、信息（information）、策略（strategies）、收益（payoffs）和均衡（equilibria）。\n\n#### 标准表达式（normal form）：\n\n设在有 \\( $n$ \\) 个参与者的博弈中，令 \\( $S_i$ \\) 表示参与者 \\( $i$ \\) 可选择的战略集合（战略空间），其中任意一个特定的战略用 \\( $s_i^*$ \\) 表示（$s_i^* \\in S_i $）。当每个参与者都选定一个策略后，形成了博弈的一个战略组合 \\( (s_1, s_2, \\ldots, s_n) \\)。令 \\( $u_i$ \\) 表示第 \\( $i$ \\) 个参与者选择对应策略后的收益函数。由此可定义博弈的标准表达式：\\( $G = \\{S_1, \\ldots, S_n, u_1, \\ldots, u_n\\}$ \\)。\n\n#### 收益矩阵：\n\n两人博弈的标准表达式通常可以使用收益矩阵来表示。例如，经典的囚徒困境问题。两个犯罪嫌疑人被逮捕并被分别隔离审问，他们不同的行动将带来不同的后果。如果两人都不坦白（沉默），将被判入狱1个月；如果双方都坦白（招认），两人都将判处6个月；如果一人招认而另一人拒不坦白，则招认一方将马上释放，而不坦白的另一人将判处9个月。两人博弈的收益矩阵可表示为如下形式，其中每一单元格有两个数字，分别表示囚徒1和囚徒2的收益：\n![囚徒困境](https://i-blog.csdnimg.cn/blog_migrate/9187d558af8a7ee6b9cb70a47de3f076.png#pic_center)\n\n#### 策略：\n\n参与人关于其行动的完备集合，即考虑每一种可预见情况下选择的行动，即使那种情况出现不一定会出现。例如，如果参与人在1989年自杀，他的策略里也应当包括如果他在1990年还活着应该采取的对应行动。\n策略和行动是有区别的，而在一些简单的博弈中，两者的表现可能是一致的，如上述的囚徒困境中博弈双方的策略和行动可选集都是 \\($\\{沉默, 招认\\}$\\)。\n\n#### 均衡：\n\n由博弈中的 \\( n \\) 个参与人选取的最佳策略所组成的一个策略组合 \\( $s^* = (s_1^*, \\ldots, s_n^*)$ \\)。\n\n#### 巴什博弈（Bash Game）：\n\n有$n$ 个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 $m$ 个（$m < n$ ）。最后取光者得胜。\n分析：\n显然，如果 \\( $n = m + 1$ \\)，那么由于一次最多只能取 \\( $m$ \\) 个物品，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，故后者必然取胜。根据这样的规律，我们发现了如何取胜的法则。\n如果 \\( $n = (m + 1)r + s$ \\) r 为任意自然数，\\( $0 \\leq s \\leq m$ \\)，那么先取者首先拿走 \\( $s$ \\) 个物品，接下来若后取者拿走 \\( $k$ \\)（\\( $1 \\leq k \\leq m$ \\)）个，那么先取者再拿走 \\( $m + 1 - k$ \\) 个，结果剩下 \\( $(m + 1) \\times (r - 1)$ \\) 个，以后都保持这样的取法，那么后取者最终会面临 \\( $m + 1$ \\) 的局面，而先取者则必然获胜。总之，要保持给对手留下 \\( $m + 1$ \\) 的倍数，最后就一定能获胜。\n\n### Code\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> a(n + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t} \n\t// sort(a.begin() + 1, a.end()); // 题目已经保证a有序，可以不写这句\n\tint s1 = 0, s2 = 0;\n\tint f = 0;\n\tfor(int i = n; i; i--) {\n\t\tif(!f) s1 += a[i];\n\t\telse s2 += a[i];\n\t\tf ^= 1;\n\t}\n\tif(s1 > s2) {\n\t\tcout << \"Alice\" << endl;\n\t}\n\telse {\n\t\tcout << \"Bob\" << endl;\n\t}\n}\n```\n\n\n\n```python\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    #player=[\"Alice\",\"Bob\"]\n    player=[0,0]\n    count=0\n    while a!=[]:\n        player[count%2]+=a.pop(-1)\n        count+=1\n    if player[0]>player[1]:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n```\n","slug":"题解-算法竞赛团队培训第一次考核","published":1,"updated":"2024-10-27T11:58:22.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm42iv3er0008c0wcfmpw7bdj","content":"<p>[TOC]</p>\n<h2 id=\"A-小红的签到题\"><a href=\"#A-小红的签到题\" class=\"headerlink\" title=\"A.小红的签到题\"></a>A.<a href=\"https://ac.nowcoder.com/acm/contest/94289/A\">小红的签到题</a></h2><h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>题目描述了一个情景，其中 ( a ) 是题目的总数，( b ) 是参赛人数，而 ( c ) 是所有人通过题目的总数。要找出最多有多少人“ak”，即通过了所有题目。</p>\n<p>在这种情况下，如果每个人至少通过了一道题，那么最多可以通过 ( a * b ) 道题。但题目只告诉我们总共通过了 ( c ) 道题。所以，要找出最多有多少人通过了所有题目，我们可以将 ( c ) 除以 ( a )，因为每个人要“ak”就需要通过 ( a ) 道题。</p>\n<p>为什么不需要计算余数呢？因为题目问的是最多有多少人“ak”，这意味着我们是在寻找一个整数解，即最多有多少完整地通过了所有题目的人。如果 ( c ) 不能被 ( a ) 整除，那么就意味着不可能有更多的人完全通过所有题目，因为余数代表的是不足以构成一个完整“ak”的人数。</p>\n<p>例如，如果 ( c &#x3D; 123 ) 且 ( a &#x3D; 6 )，那么 ( 123 &#x2F; 6 &#x3D; 20 ) 余 3。这表示最多有 20 个人可以完全通过所有题目，因为剩下的 3 道题不足以让更多的人完成“ak”。</p>\n<p>因此，直接用 ( c ) 除以 ( a ) 得到的整数部分就是答案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a,b,c;<br>\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>\tcout&lt;&lt;c/a&lt;&lt;endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a,b,c=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(c/a))<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"B-判断闰年\"><a href=\"#B-判断闰年\" class=\"headerlink\" title=\"B.判断闰年\"></a>B.<a href=\"https://ac.nowcoder.com/acm/contest/94289/B\">判断闰年</a></h2><h3 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>公历闰年的简单计算方法（符合以下条件之一的年份即为闰年）：</p>\n<p>1.能被4整除而不能被100整除</p>\n<p>2.能被400整除</p>\n<h3 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin&gt;&gt;n;<br>\t<span class=\"hljs-keyword\">if</span>((n%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span> &amp;&amp; n%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>) || (n%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span>))&#123;<br>\t\tcout&lt;&lt;<span class=\"hljs-string\">&quot;yes&quot;</span>&lt;&lt;endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\tcout&lt;&lt;<span class=\"hljs-string\">&quot;no&quot;</span>&lt;&lt;endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">if</span>(((n%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">and</span> (n%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>)) <span class=\"hljs-keyword\">or</span> (n%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span>)):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;yes&quot;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;no&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"C-NOIP2010-数字统计\"><a href=\"#C-NOIP2010-数字统计\" class=\"headerlink\" title=\"C.[NOIP2010]数字统计\"></a>C.[<a href=\"https://ac.nowcoder.com/acm/contest/94289/C\">NOIP2010]数字统计</a></h2><h2 id=\"解析-2\"><a href=\"#解析-2\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>见代码</p>\n<h3 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> L, R;<br>\tcin &gt;&gt; L &gt;&gt; R;<br>\t<span class=\"hljs-type\">int</span> countTwos = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 重命名变量以避免冲突</span><br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = L; i &lt;= R; ++i) &#123;<br>\t\tstring num_str = <span class=\"hljs-built_in\">to_string</span>(i);<br>\t\tcountTwos += <span class=\"hljs-built_in\">count</span>(num_str.<span class=\"hljs-built_in\">begin</span>(), num_str.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-string\">&#x27;2&#x27;</span>);  <br>\t&#125;<br>\t<br>\tcout &lt;&lt; countTwos &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">L,R=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br>count=<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(L,R+<span class=\"hljs-number\">1</span>):<br>    count+=<span class=\"hljs-built_in\">str</span>(i).count(<span class=\"hljs-string\">&quot;2&quot;</span>)<br><span class=\"hljs-built_in\">print</span>(count)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"D-NOIP2017-图书管理员\"><a href=\"#D-NOIP2017-图书管理员\" class=\"headerlink\" title=\"D.[ NOIP2017]图书管理员\"></a>D.[ <a href=\"https://ac.nowcoder.com/acm/contest/94289/D\">NOIP2017]图书管理员</a></h2><h3 id=\"解析-3\"><a href=\"#解析-3\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>见代码</p>\n<h3 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; library, <span class=\"hljs-type\">const</span> pair&lt;<span class=\"hljs-type\">int</span>, string&gt;&amp; tupleX)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : library) &#123;<br>        string num_str = <span class=\"hljs-built_in\">to_string</span>(i);<br>        <span class=\"hljs-keyword\">if</span> (num_str.<span class=\"hljs-built_in\">length</span>() &gt;= tupleX.second.<span class=\"hljs-built_in\">length</span>()) &#123;<br>            string suffix = num_str.<span class=\"hljs-built_in\">substr</span>(num_str.<span class=\"hljs-built_in\">length</span>() - tupleX.first);<br>            <span class=\"hljs-keyword\">if</span> (suffix == tupleX.second) &#123;<br>                <span class=\"hljs-keyword\">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">library</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; library[i];<br>    &#125;<br>    <br>    vector&lt;pair&lt;<span class=\"hljs-type\">int</span>, string&gt;&gt; <span class=\"hljs-built_in\">needed</span>(q);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; q; ++i) &#123;<br>        <span class=\"hljs-type\">int</span> x;<br>        string s;<br>        cin &gt;&gt; x &gt;&gt; s;<br>        needed[i] = <span class=\"hljs-built_in\">make_pair</span>(x, s);<br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">sort</span>(library.<span class=\"hljs-built_in\">begin</span>(), library.<span class=\"hljs-built_in\">end</span>());<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; i : needed) &#123;<br>        cout &lt;&lt; <span class=\"hljs-built_in\">find</span>(library, i) &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n,q=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br>library=[<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>()) <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]<br><span class=\"hljs-comment\">#和下面代码是一个意思:</span><br><span class=\"hljs-comment\"># for _ in range(n):</span><br><span class=\"hljs-comment\">#     library.append(int(input()))</span><br>needed=[<span class=\"hljs-built_in\">tuple</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())) <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(q)]<br><span class=\"hljs-comment\">#和下面代码是一个意思:</span><br><span class=\"hljs-comment\"># for _ in range(q):</span><br><span class=\"hljs-comment\">#     needed.append(tuple(map(int,input().split())))</span><br><span class=\"hljs-comment\">#test:</span><br><span class=\"hljs-comment\"># print(library)</span><br><span class=\"hljs-comment\"># print(needed)</span><br>library.sort()<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find</span>(<span class=\"hljs-params\">tupleX</span>):<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> library:<br>        a=-tupleX[<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">str</span>(i)[a:]==<span class=\"hljs-built_in\">str</span>(tupleX[<span class=\"hljs-number\">1</span>]):<br>            <span class=\"hljs-keyword\">return</span> i<br>    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> needed:<br>    <span class=\"hljs-built_in\">print</span>(find(i))<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"E-最大公约数-lcm\"><a href=\"#E-最大公约数-lcm\" class=\"headerlink\" title=\"E.最大公约数(lcm)\"></a>E.<a href=\"https://ac.nowcoder.com/acm/contest/94289/E\">最大公约数(lcm)</a></h2><h3 id=\"解析-4\"><a href=\"#解析-4\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>辗转相除法求最大公因数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (a % b==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> b;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">gcd</span>(b, a % b);<br>&#125;<br><span class=\"hljs-type\">int</span> x, y; <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<br>\tcin &gt;&gt; x &gt;&gt; y;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">gcd</span>(x, y);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">gcd</span>(<span class=\"hljs-params\">m,n</span>):<br>    <span class=\"hljs-keyword\">while</span> m%n != <span class=\"hljs-number\">0</span>:<br>        oldm = m<br>        oldn = n<br><br>        m = oldn<br>        n = oldm%oldn<br>    <span class=\"hljs-keyword\">return</span> n<br></code></pre></td></tr></table></figure>\n\n<p><strong>最小公倍数（LCM）等于两个数的乘积除以它们的最大公因数（GCD）</strong></p>\n<h3 id=\"Code-4\"><a href=\"#Code-4\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">lcm</span>(a,b);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> math<br>a,b=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-built_in\">print</span>(math.lcm(a,b))<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"F-简单的整除\"><a href=\"#F-简单的整除\" class=\"headerlink\" title=\"F. 简单的整除\"></a>F.<a href=\"https://ac.nowcoder.com/acm/contest/94289/F\"> 简单的整除</a></h2><h3 id=\"解析-5\"><a href=\"#解析-5\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>见代码</p>\n<h3 id=\"Code-5\"><a href=\"#Code-5\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> x;<br>\tcin &gt;&gt; x;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; li = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>&#125;;<br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : li) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (x % i == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;YES&quot;</span> &lt;&lt; endl;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">7</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;NO&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">x=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br>li=[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>]<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> li:<br>    <span class=\"hljs-keyword\">if</span> x%i==<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;YES&quot;</span>)<br>        <span class=\"hljs-keyword\">break</span><br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I-悬崖\"><a href=\"#I-悬崖\" class=\"headerlink\" title=\"I.悬崖\"></a>I.<a href=\"https://ac.nowcoder.com/acm/contest/94289/I\">悬崖</a></h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>小沙被困在两个巨大的墙壁之中快要被压死了，但是两个墙壁中间就是万丈悬崖，小沙想要多活一会，他脚底下有一个非常强大的弹跳鞋，每一次跳跃可以使他向着对面的墙壁飞行x米，但是他必须要踩上墙壁才能进行下一次跳跃，现已知两个墙壁中间间隔n米，并且每次跳跃两个墙壁之间的距离会减少1米，也就是说小沙在n秒后就会被压死，如果不考虑跳跃期间墙壁的移动，请问小沙最多能跳(飞)多少米。</p>\n<p><strong>两面墙壁都没有什么物品可以让小沙能够抓住从而挂在墙壁上，所以小沙要保证一直的跳跃才能不摔下悬崖</strong></p>\n<p>说明：小沙第一次跳跃两米，到对面墙壁，然后两个墙壁的距离变成1米，小沙继续跳到对面墙壁（此时虽然两个墙壁之间只有1米，但是小沙还是可以跳跃两米）例如：</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20220303/371724_1646315836289/9976BCCD254C760651A666CBC1845546\" alt=\"img\"></p>\n<p>可以看到虽然墙壁之间的距离只有一米，但是小沙还是可以跳两米远</p>\n<h3 id=\"Code-6\"><a href=\"#Code-6\" class=\"headerlink\" title=\"Code\"></a>Code</h3><h4 id=\"牛客513205243号-提交的代码\"><a href=\"#牛客513205243号-提交的代码\" class=\"headerlink\" title=\"牛客513205243号 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/513205243\">牛客513205243号</a> 提交的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> x, n;<br>\tcin &gt;&gt; x &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">if</span>(x&gt;=n)<br>\t\tcout &lt;&lt; n * x;<br>\t<span class=\"hljs-keyword\">else</span> <br>\t\tcout &lt;&lt; x ;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"砍个价沈-提交的代码\"><a href=\"#砍个价沈-提交的代码\" class=\"headerlink\" title=\"砍个价沈 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/602481815\">砍个价沈</a> 提交的代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">x,n=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-keyword\">if</span> x&gt;=n:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(x*n))<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(x))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"J-猜拳游戏\"><a href=\"#J-猜拳游戏\" class=\"headerlink\" title=\"J. 猜拳游戏\"></a>J.<a href=\"https://ac.nowcoder.com/acm/contest/94289/J\"> 猜拳游戏</a></h3><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>你正在与<em>长途</em>玩石头剪刀布的猜拳游戏。</p>\n<p>请回忆石头剪刀布的游戏规则：两个人同时伸出手，分别出示石头（用 shitou 表示）、剪刀（用 jiandao 表示）或布（用 bu 表示）的手势。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出示的手势相同，则是平局，需要重新进行游戏。</p>\n<p>在开始游戏之前，<em>长途</em>会告诉你他要出石头、剪刀还是布。</p>\n<p>然而实际上，<em>长途</em>是在欺骗你。他认为你会相信他的话，并且认为你一定会根据他说的话选择能战胜他的手势（例如，他说他会出石头，他便认为你会出布）。</p>\n<p>所以最终，<em>长途</em>不会按照他告诉你的手势出拳，而是选择自己所认为一定能战胜你的手势。</p>\n<p>现在你已经看透了他的小心思。请问，在知道他告诉你他要出什么手势的情况下，你应该出什么手势才能取胜？</p>\n<h3 id=\"Code-7\"><a href=\"#Code-7\" class=\"headerlink\" title=\"Code\"></a>Code</h3><h4 id=\"牛客513205243号-提交的代码-1\"><a href=\"#牛客513205243号-提交的代码-1\" class=\"headerlink\" title=\"牛客513205243号 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/513205243\">牛客513205243号</a> 提交的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">char</span> n[<span class=\"hljs-number\">100</span>];<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,&amp;n);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"砍个价沈-提交的代码-1\"><a href=\"#砍个价沈-提交的代码-1\" class=\"headerlink\" title=\"砍个价沈 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/602481815\">砍个价沈</a> 提交的代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">i=<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-string\">&quot;shitou&quot;</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;shitou&quot;</span>)<br><span class=\"hljs-keyword\">elif</span> i==<span class=\"hljs-string\">&quot;jiandao&quot;</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;jiandao&quot;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;bu&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">input</span>())<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"G-小苯的石子游戏\"><a href=\"#G-小苯的石子游戏\" class=\"headerlink\" title=\"G.小苯的石子游戏\"></a>G.<a href=\"https://ac.nowcoder.com/acm/contest/94289/G\">小苯的石子游戏</a></h2><h3 id=\"解析-6\"><a href=\"#解析-6\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"博弈的定义：\"><a href=\"#博弈的定义：\" class=\"headerlink\" title=\"博弈的定义：\"></a>博弈的定义：</h4><p>博弈的基本要素包括参与人（players）、行动（actions）、信息（information）、策略（strategies）、收益（payoffs）和均衡（equilibria）。</p>\n<h4 id=\"标准表达式（normal-form）：\"><a href=\"#标准表达式（normal-form）：\" class=\"headerlink\" title=\"标准表达式（normal form）：\"></a>标准表达式（normal form）：</h4><p>设在有 ( $n$ ) 个参与者的博弈中，令 ( $S_i$ ) 表示参与者 ( $i$ ) 可选择的战略集合（战略空间），其中任意一个特定的战略用 ( $s_i^*$ ) 表示（$s_i^* \\in S_i $）。当每个参与者都选定一个策略后，形成了博弈的一个战略组合 ( (s_1, s_2, \\ldots, s_n) )。令 ( $u_i$ ) 表示第 ( $i$ ) 个参与者选择对应策略后的收益函数。由此可定义博弈的标准表达式：( $G &#x3D; {S_1, \\ldots, S_n, u_1, \\ldots, u_n}$ )。</p>\n<h4 id=\"收益矩阵：\"><a href=\"#收益矩阵：\" class=\"headerlink\" title=\"收益矩阵：\"></a>收益矩阵：</h4><p>两人博弈的标准表达式通常可以使用收益矩阵来表示。例如，经典的囚徒困境问题。两个犯罪嫌疑人被逮捕并被分别隔离审问，他们不同的行动将带来不同的后果。如果两人都不坦白（沉默），将被判入狱1个月；如果双方都坦白（招认），两人都将判处6个月；如果一人招认而另一人拒不坦白，则招认一方将马上释放，而不坦白的另一人将判处9个月。两人博弈的收益矩阵可表示为如下形式，其中每一单元格有两个数字，分别表示囚徒1和囚徒2的收益：<br><img src=\"https://i-blog.csdnimg.cn/blog_migrate/9187d558af8a7ee6b9cb70a47de3f076.png#pic_center\" alt=\"囚徒困境\"></p>\n<h4 id=\"策略：\"><a href=\"#策略：\" class=\"headerlink\" title=\"策略：\"></a>策略：</h4><p>参与人关于其行动的完备集合，即考虑每一种可预见情况下选择的行动，即使那种情况出现不一定会出现。例如，如果参与人在1989年自杀，他的策略里也应当包括如果他在1990年还活着应该采取的对应行动。<br>策略和行动是有区别的，而在一些简单的博弈中，两者的表现可能是一致的，如上述的囚徒困境中博弈双方的策略和行动可选集都是 (${沉默, 招认}$)。</p>\n<h4 id=\"均衡：\"><a href=\"#均衡：\" class=\"headerlink\" title=\"均衡：\"></a>均衡：</h4><p>由博弈中的 ( n ) 个参与人选取的最佳策略所组成的一个策略组合 ( $s^* &#x3D; (s_1^*, \\ldots, s_n^*)$ )。</p>\n<h4 id=\"巴什博弈（Bash-Game）：\"><a href=\"#巴什博弈（Bash-Game）：\" class=\"headerlink\" title=\"巴什博弈（Bash Game）：\"></a>巴什博弈（Bash Game）：</h4><p>有$n$ 个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 $m$ 个（$m &lt; n$ ）。最后取光者得胜。<br>分析：<br>显然，如果 ( $n &#x3D; m + 1$ )，那么由于一次最多只能取 ( $m$ ) 个物品，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，故后者必然取胜。根据这样的规律，我们发现了如何取胜的法则。<br>如果 ( $n &#x3D; (m + 1)r + s$ ) r 为任意自然数，( $0 \\leq s \\leq m$ )，那么先取者首先拿走 ( $s$ ) 个物品，接下来若后取者拿走 ( $k$ )（( $1 \\leq k \\leq m$ )）个，那么先取者再拿走 ( $m + 1 - k$ ) 个，结果剩下 ( $(m + 1) \\times (r - 1)$ ) 个，以后都保持这样的取法，那么后取者最终会面临 ( $m + 1$ ) 的局面，而先取者则必然获胜。总之，要保持给对手留下 ( $m + 1$ ) 的倍数，最后就一定能获胜。</p>\n<h3 id=\"Code-8\"><a href=\"#Code-8\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">solve</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(n + <span class=\"hljs-number\">1</span>)</span></span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>\t\tcin &gt;&gt; a[i];<br>\t&#125; <br>\t<span class=\"hljs-comment\">// sort(a.begin() + 1, a.end()); // 题目已经保证a有序，可以不写这句</span><br>\t<span class=\"hljs-type\">int</span> s1 = <span class=\"hljs-number\">0</span>, s2 = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> f = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = n; i; i--) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(!f) s1 += a[i];<br>\t\t<span class=\"hljs-keyword\">else</span> s2 += a[i];<br>\t\tf ^= <span class=\"hljs-number\">1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(s1 &gt; s2) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Alice&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Bob&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(t):<br>    n=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br>    a=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split()))<br>    <span class=\"hljs-comment\">#player=[&quot;Alice&quot;,&quot;Bob&quot;]</span><br>    player=[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>]<br>    count=<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">while</span> a!=[]:<br>        player[count%<span class=\"hljs-number\">2</span>]+=a.pop(-<span class=\"hljs-number\">1</span>)<br>        count+=<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> player[<span class=\"hljs-number\">0</span>]&gt;player[<span class=\"hljs-number\">1</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>)<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>)<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"A-小红的签到题\"><a href=\"#A-小红的签到题\" class=\"headerlink\" title=\"A.小红的签到题\"></a>A.<a href=\"https://ac.nowcoder.com/acm/contest/94289/A\">小红的签到题</a></h2><h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>题目描述了一个情景，其中 ( a ) 是题目的总数，( b ) 是参赛人数，而 ( c ) 是所有人通过题目的总数。要找出最多有多少人“ak”，即通过了所有题目。</p>\n<p>在这种情况下，如果每个人至少通过了一道题，那么最多可以通过 ( a * b ) 道题。但题目只告诉我们总共通过了 ( c ) 道题。所以，要找出最多有多少人通过了所有题目，我们可以将 ( c ) 除以 ( a )，因为每个人要“ak”就需要通过 ( a ) 道题。</p>\n<p>为什么不需要计算余数呢？因为题目问的是最多有多少人“ak”，这意味着我们是在寻找一个整数解，即最多有多少完整地通过了所有题目的人。如果 ( c ) 不能被 ( a ) 整除，那么就意味着不可能有更多的人完全通过所有题目，因为余数代表的是不足以构成一个完整“ak”的人数。</p>\n<p>例如，如果 ( c &#x3D; 123 ) 且 ( a &#x3D; 6 )，那么 ( 123 &#x2F; 6 &#x3D; 20 ) 余 3。这表示最多有 20 个人可以完全通过所有题目，因为剩下的 3 道题不足以让更多的人完成“ak”。</p>\n<p>因此，直接用 ( c ) 除以 ( a ) 得到的整数部分就是答案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a,b,c;<br>\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>\tcout&lt;&lt;c/a&lt;&lt;endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a,b,c=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(c/a))<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"B-判断闰年\"><a href=\"#B-判断闰年\" class=\"headerlink\" title=\"B.判断闰年\"></a>B.<a href=\"https://ac.nowcoder.com/acm/contest/94289/B\">判断闰年</a></h2><h3 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>公历闰年的简单计算方法（符合以下条件之一的年份即为闰年）：</p>\n<p>1.能被4整除而不能被100整除</p>\n<p>2.能被400整除</p>\n<h3 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin&gt;&gt;n;<br>\t<span class=\"hljs-keyword\">if</span>((n%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span> &amp;&amp; n%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>) || (n%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span>))&#123;<br>\t\tcout&lt;&lt;<span class=\"hljs-string\">&quot;yes&quot;</span>&lt;&lt;endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\tcout&lt;&lt;<span class=\"hljs-string\">&quot;no&quot;</span>&lt;&lt;endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">if</span>(((n%<span class=\"hljs-number\">4</span>==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">and</span> (n%<span class=\"hljs-number\">100</span>!=<span class=\"hljs-number\">0</span>)) <span class=\"hljs-keyword\">or</span> (n%<span class=\"hljs-number\">400</span>==<span class=\"hljs-number\">0</span>)):<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;yes&quot;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;no&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"C-NOIP2010-数字统计\"><a href=\"#C-NOIP2010-数字统计\" class=\"headerlink\" title=\"C.[NOIP2010]数字统计\"></a>C.[<a href=\"https://ac.nowcoder.com/acm/contest/94289/C\">NOIP2010]数字统计</a></h2><h2 id=\"解析-2\"><a href=\"#解析-2\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>见代码</p>\n<h3 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> L, R;<br>\tcin &gt;&gt; L &gt;&gt; R;<br>\t<span class=\"hljs-type\">int</span> countTwos = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 重命名变量以避免冲突</span><br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = L; i &lt;= R; ++i) &#123;<br>\t\tstring num_str = <span class=\"hljs-built_in\">to_string</span>(i);<br>\t\tcountTwos += <span class=\"hljs-built_in\">count</span>(num_str.<span class=\"hljs-built_in\">begin</span>(), num_str.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-string\">&#x27;2&#x27;</span>);  <br>\t&#125;<br>\t<br>\tcout &lt;&lt; countTwos &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">L,R=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br>count=<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(L,R+<span class=\"hljs-number\">1</span>):<br>    count+=<span class=\"hljs-built_in\">str</span>(i).count(<span class=\"hljs-string\">&quot;2&quot;</span>)<br><span class=\"hljs-built_in\">print</span>(count)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"D-NOIP2017-图书管理员\"><a href=\"#D-NOIP2017-图书管理员\" class=\"headerlink\" title=\"D.[ NOIP2017]图书管理员\"></a>D.[ <a href=\"https://ac.nowcoder.com/acm/contest/94289/D\">NOIP2017]图书管理员</a></h2><h3 id=\"解析-3\"><a href=\"#解析-3\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>见代码</p>\n<h3 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; library, <span class=\"hljs-type\">const</span> pair&lt;<span class=\"hljs-type\">int</span>, string&gt;&amp; tupleX)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : library) &#123;<br>        string num_str = <span class=\"hljs-built_in\">to_string</span>(i);<br>        <span class=\"hljs-keyword\">if</span> (num_str.<span class=\"hljs-built_in\">length</span>() &gt;= tupleX.second.<span class=\"hljs-built_in\">length</span>()) &#123;<br>            string suffix = num_str.<span class=\"hljs-built_in\">substr</span>(num_str.<span class=\"hljs-built_in\">length</span>() - tupleX.first);<br>            <span class=\"hljs-keyword\">if</span> (suffix == tupleX.second) &#123;<br>                <span class=\"hljs-keyword\">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">library</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; library[i];<br>    &#125;<br>    <br>    vector&lt;pair&lt;<span class=\"hljs-type\">int</span>, string&gt;&gt; <span class=\"hljs-built_in\">needed</span>(q);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; q; ++i) &#123;<br>        <span class=\"hljs-type\">int</span> x;<br>        string s;<br>        cin &gt;&gt; x &gt;&gt; s;<br>        needed[i] = <span class=\"hljs-built_in\">make_pair</span>(x, s);<br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">sort</span>(library.<span class=\"hljs-built_in\">begin</span>(), library.<span class=\"hljs-built_in\">end</span>());<br>    <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; i : needed) &#123;<br>        cout &lt;&lt; <span class=\"hljs-built_in\">find</span>(library, i) &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">n,q=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br>library=[<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>()) <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]<br><span class=\"hljs-comment\">#和下面代码是一个意思:</span><br><span class=\"hljs-comment\"># for _ in range(n):</span><br><span class=\"hljs-comment\">#     library.append(int(input()))</span><br>needed=[<span class=\"hljs-built_in\">tuple</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())) <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(q)]<br><span class=\"hljs-comment\">#和下面代码是一个意思:</span><br><span class=\"hljs-comment\"># for _ in range(q):</span><br><span class=\"hljs-comment\">#     needed.append(tuple(map(int,input().split())))</span><br><span class=\"hljs-comment\">#test:</span><br><span class=\"hljs-comment\"># print(library)</span><br><span class=\"hljs-comment\"># print(needed)</span><br>library.sort()<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find</span>(<span class=\"hljs-params\">tupleX</span>):<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> library:<br>        a=-tupleX[<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">str</span>(i)[a:]==<span class=\"hljs-built_in\">str</span>(tupleX[<span class=\"hljs-number\">1</span>]):<br>            <span class=\"hljs-keyword\">return</span> i<br>    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> needed:<br>    <span class=\"hljs-built_in\">print</span>(find(i))<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"E-最大公约数-lcm\"><a href=\"#E-最大公约数-lcm\" class=\"headerlink\" title=\"E.最大公约数(lcm)\"></a>E.<a href=\"https://ac.nowcoder.com/acm/contest/94289/E\">最大公约数(lcm)</a></h2><h3 id=\"解析-4\"><a href=\"#解析-4\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>辗转相除法求最大公因数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (a % b==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> b;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">gcd</span>(b, a % b);<br>&#125;<br><span class=\"hljs-type\">int</span> x, y; <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<br>\tcin &gt;&gt; x &gt;&gt; y;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">gcd</span>(x, y);<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">gcd</span>(<span class=\"hljs-params\">m,n</span>):<br>    <span class=\"hljs-keyword\">while</span> m%n != <span class=\"hljs-number\">0</span>:<br>        oldm = m<br>        oldn = n<br><br>        m = oldn<br>        n = oldm%oldn<br>    <span class=\"hljs-keyword\">return</span> n<br></code></pre></td></tr></table></figure>\n\n<p><strong>最小公倍数（LCM）等于两个数的乘积除以它们的最大公因数（GCD）</strong></p>\n<h3 id=\"Code-4\"><a href=\"#Code-4\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;<span class=\"hljs-built_in\">lcm</span>(a,b);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> math<br>a,b=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-built_in\">print</span>(math.lcm(a,b))<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"F-简单的整除\"><a href=\"#F-简单的整除\" class=\"headerlink\" title=\"F. 简单的整除\"></a>F.<a href=\"https://ac.nowcoder.com/acm/contest/94289/F\"> 简单的整除</a></h2><h3 id=\"解析-5\"><a href=\"#解析-5\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>见代码</p>\n<h3 id=\"Code-5\"><a href=\"#Code-5\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> x;<br>\tcin &gt;&gt; x;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; li = &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>&#125;;<br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : li) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (x % i == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;YES&quot;</span> &lt;&lt; endl;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span> &amp;&amp; x % <span class=\"hljs-number\">7</span> != <span class=\"hljs-number\">0</span>) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;NO&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">x=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br>li=[<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>]<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> li:<br>    <span class=\"hljs-keyword\">if</span> x%i==<span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;YES&quot;</span>)<br>        <span class=\"hljs-keyword\">break</span><br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;NO&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"I-悬崖\"><a href=\"#I-悬崖\" class=\"headerlink\" title=\"I.悬崖\"></a>I.<a href=\"https://ac.nowcoder.com/acm/contest/94289/I\">悬崖</a></h2><h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>小沙被困在两个巨大的墙壁之中快要被压死了，但是两个墙壁中间就是万丈悬崖，小沙想要多活一会，他脚底下有一个非常强大的弹跳鞋，每一次跳跃可以使他向着对面的墙壁飞行x米，但是他必须要踩上墙壁才能进行下一次跳跃，现已知两个墙壁中间间隔n米，并且每次跳跃两个墙壁之间的距离会减少1米，也就是说小沙在n秒后就会被压死，如果不考虑跳跃期间墙壁的移动，请问小沙最多能跳(飞)多少米。</p>\n<p><strong>两面墙壁都没有什么物品可以让小沙能够抓住从而挂在墙壁上，所以小沙要保证一直的跳跃才能不摔下悬崖</strong></p>\n<p>说明：小沙第一次跳跃两米，到对面墙壁，然后两个墙壁的距离变成1米，小沙继续跳到对面墙壁（此时虽然两个墙壁之间只有1米，但是小沙还是可以跳跃两米）例如：</p>\n<p><img src=\"https://uploadfiles.nowcoder.com/images/20220303/371724_1646315836289/9976BCCD254C760651A666CBC1845546\" alt=\"img\"></p>\n<p>可以看到虽然墙壁之间的距离只有一米，但是小沙还是可以跳两米远</p>\n<h3 id=\"Code-6\"><a href=\"#Code-6\" class=\"headerlink\" title=\"Code\"></a>Code</h3><h4 id=\"牛客513205243号-提交的代码\"><a href=\"#牛客513205243号-提交的代码\" class=\"headerlink\" title=\"牛客513205243号 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/513205243\">牛客513205243号</a> 提交的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> x, n;<br>\tcin &gt;&gt; x &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">if</span>(x&gt;=n)<br>\t\tcout &lt;&lt; n * x;<br>\t<span class=\"hljs-keyword\">else</span> <br>\t\tcout &lt;&lt; x ;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"砍个价沈-提交的代码\"><a href=\"#砍个价沈-提交的代码\" class=\"headerlink\" title=\"砍个价沈 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/602481815\">砍个价沈</a> 提交的代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">x,n=<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split())<br><span class=\"hljs-keyword\">if</span> x&gt;=n:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(x*n))<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">int</span>(x))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"J-猜拳游戏\"><a href=\"#J-猜拳游戏\" class=\"headerlink\" title=\"J. 猜拳游戏\"></a>J.<a href=\"https://ac.nowcoder.com/acm/contest/94289/J\"> 猜拳游戏</a></h3><h3 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>你正在与<em>长途</em>玩石头剪刀布的猜拳游戏。</p>\n<p>请回忆石头剪刀布的游戏规则：两个人同时伸出手，分别出示石头（用 shitou 表示）、剪刀（用 jiandao 表示）或布（用 bu 表示）的手势。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出示的手势相同，则是平局，需要重新进行游戏。</p>\n<p>在开始游戏之前，<em>长途</em>会告诉你他要出石头、剪刀还是布。</p>\n<p>然而实际上，<em>长途</em>是在欺骗你。他认为你会相信他的话，并且认为你一定会根据他说的话选择能战胜他的手势（例如，他说他会出石头，他便认为你会出布）。</p>\n<p>所以最终，<em>长途</em>不会按照他告诉你的手势出拳，而是选择自己所认为一定能战胜你的手势。</p>\n<p>现在你已经看透了他的小心思。请问，在知道他告诉你他要出什么手势的情况下，你应该出什么手势才能取胜？</p>\n<h3 id=\"Code-7\"><a href=\"#Code-7\" class=\"headerlink\" title=\"Code\"></a>Code</h3><h4 id=\"牛客513205243号-提交的代码-1\"><a href=\"#牛客513205243号-提交的代码-1\" class=\"headerlink\" title=\"牛客513205243号 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/513205243\">牛客513205243号</a> 提交的代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t<span class=\"hljs-type\">char</span> n[<span class=\"hljs-number\">100</span>];<br>\t<span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,&amp;n);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"砍个价沈-提交的代码-1\"><a href=\"#砍个价沈-提交的代码-1\" class=\"headerlink\" title=\"砍个价沈 提交的代码\"></a><a href=\"https://ac.nowcoder.com/acm/contest/profile/602481815\">砍个价沈</a> 提交的代码</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">i=<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">if</span> i==<span class=\"hljs-string\">&quot;shitou&quot;</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;shitou&quot;</span>)<br><span class=\"hljs-keyword\">elif</span> i==<span class=\"hljs-string\">&quot;jiandao&quot;</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;jiandao&quot;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;bu&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">input</span>())<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"G-小苯的石子游戏\"><a href=\"#G-小苯的石子游戏\" class=\"headerlink\" title=\"G.小苯的石子游戏\"></a>G.<a href=\"https://ac.nowcoder.com/acm/contest/94289/G\">小苯的石子游戏</a></h2><h3 id=\"解析-6\"><a href=\"#解析-6\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"博弈的定义：\"><a href=\"#博弈的定义：\" class=\"headerlink\" title=\"博弈的定义：\"></a>博弈的定义：</h4><p>博弈的基本要素包括参与人（players）、行动（actions）、信息（information）、策略（strategies）、收益（payoffs）和均衡（equilibria）。</p>\n<h4 id=\"标准表达式（normal-form）：\"><a href=\"#标准表达式（normal-form）：\" class=\"headerlink\" title=\"标准表达式（normal form）：\"></a>标准表达式（normal form）：</h4><p>设在有 ( $n$ ) 个参与者的博弈中，令 ( $S_i$ ) 表示参与者 ( $i$ ) 可选择的战略集合（战略空间），其中任意一个特定的战略用 ( $s_i^*$ ) 表示（$s_i^* \\in S_i $）。当每个参与者都选定一个策略后，形成了博弈的一个战略组合 ( (s_1, s_2, \\ldots, s_n) )。令 ( $u_i$ ) 表示第 ( $i$ ) 个参与者选择对应策略后的收益函数。由此可定义博弈的标准表达式：( $G &#x3D; {S_1, \\ldots, S_n, u_1, \\ldots, u_n}$ )。</p>\n<h4 id=\"收益矩阵：\"><a href=\"#收益矩阵：\" class=\"headerlink\" title=\"收益矩阵：\"></a>收益矩阵：</h4><p>两人博弈的标准表达式通常可以使用收益矩阵来表示。例如，经典的囚徒困境问题。两个犯罪嫌疑人被逮捕并被分别隔离审问，他们不同的行动将带来不同的后果。如果两人都不坦白（沉默），将被判入狱1个月；如果双方都坦白（招认），两人都将判处6个月；如果一人招认而另一人拒不坦白，则招认一方将马上释放，而不坦白的另一人将判处9个月。两人博弈的收益矩阵可表示为如下形式，其中每一单元格有两个数字，分别表示囚徒1和囚徒2的收益：<br><img src=\"https://i-blog.csdnimg.cn/blog_migrate/9187d558af8a7ee6b9cb70a47de3f076.png#pic_center\" alt=\"囚徒困境\"></p>\n<h4 id=\"策略：\"><a href=\"#策略：\" class=\"headerlink\" title=\"策略：\"></a>策略：</h4><p>参与人关于其行动的完备集合，即考虑每一种可预见情况下选择的行动，即使那种情况出现不一定会出现。例如，如果参与人在1989年自杀，他的策略里也应当包括如果他在1990年还活着应该采取的对应行动。<br>策略和行动是有区别的，而在一些简单的博弈中，两者的表现可能是一致的，如上述的囚徒困境中博弈双方的策略和行动可选集都是 (${沉默, 招认}$)。</p>\n<h4 id=\"均衡：\"><a href=\"#均衡：\" class=\"headerlink\" title=\"均衡：\"></a>均衡：</h4><p>由博弈中的 ( n ) 个参与人选取的最佳策略所组成的一个策略组合 ( $s^* &#x3D; (s_1^*, \\ldots, s_n^*)$ )。</p>\n<h4 id=\"巴什博弈（Bash-Game）：\"><a href=\"#巴什博弈（Bash-Game）：\" class=\"headerlink\" title=\"巴什博弈（Bash Game）：\"></a>巴什博弈（Bash Game）：</h4><p>有$n$ 个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 $m$ 个（$m &lt; n$ ）。最后取光者得胜。<br>分析：<br>显然，如果 ( $n &#x3D; m + 1$ )，那么由于一次最多只能取 ( $m$ ) 个物品，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，故后者必然取胜。根据这样的规律，我们发现了如何取胜的法则。<br>如果 ( $n &#x3D; (m + 1)r + s$ ) r 为任意自然数，( $0 \\leq s \\leq m$ )，那么先取者首先拿走 ( $s$ ) 个物品，接下来若后取者拿走 ( $k$ )（( $1 \\leq k \\leq m$ )）个，那么先取者再拿走 ( $m + 1 - k$ ) 个，结果剩下 ( $(m + 1) \\times (r - 1)$ ) 个，以后都保持这样的取法，那么后取者最终会面临 ( $m + 1$ ) 的局面，而先取者则必然获胜。总之，要保持给对手留下 ( $m + 1$ ) 的倍数，最后就一定能获胜。</p>\n<h3 id=\"Code-8\"><a href=\"#Code-8\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;bits/stdc++.h&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">solve</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(n + <span class=\"hljs-number\">1</span>)</span></span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>\t\tcin &gt;&gt; a[i];<br>\t&#125; <br>\t<span class=\"hljs-comment\">// sort(a.begin() + 1, a.end()); // 题目已经保证a有序，可以不写这句</span><br>\t<span class=\"hljs-type\">int</span> s1 = <span class=\"hljs-number\">0</span>, s2 = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> f = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = n; i; i--) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(!f) s1 += a[i];<br>\t\t<span class=\"hljs-keyword\">else</span> s2 += a[i];<br>\t\tf ^= <span class=\"hljs-number\">1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(s1 &gt; s2) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Alice&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Bob&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">t=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br><span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(t):<br>    n=<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>())<br>    a=<span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>,<span class=\"hljs-built_in\">input</span>().split()))<br>    <span class=\"hljs-comment\">#player=[&quot;Alice&quot;,&quot;Bob&quot;]</span><br>    player=[<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>]<br>    count=<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">while</span> a!=[]:<br>        player[count%<span class=\"hljs-number\">2</span>]+=a.pop(-<span class=\"hljs-number\">1</span>)<br>        count+=<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">if</span> player[<span class=\"hljs-number\">0</span>]&gt;player[<span class=\"hljs-number\">1</span>]:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>)<br>    <span class=\"hljs-keyword\">else</span>:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>)<br></code></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cm42iv3eo0002c0wc7tat3s3d","tag_id":"cm42iv3ep0003c0wc20ymcwid","_id":"cm42iv3eq0004c0wc974v5bap"}],"Tag":[{"name":"数据结构","_id":"cm42iv3ep0003c0wc20ymcwid"}]}}